//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {AIForgedBase} from "./AIForgedBase";
import {AIForgedConfig} from "./AIForgedConfig";

export interface IAccountClient {

    /**
     * Get current logged in user
     * @param x_Api_Version (optional) 
     * @return User data
     */
    getCurrentUser(x_Api_Version: string | null | undefined): Promise<UserViewModel>;

    /**
     * Get api key for a user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     * @return API-Key
     */
    getApiKey(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string>;

    /**
     * Get user by Id
     * @param userid (optional) The user id
     * @param x_Api_Version (optional) 
     */
    getById(userid: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserViewModel>;

    /**
     * Get user info by username
     * @param userName (optional) 
     * @param x_Api_Version (optional) 
     */
    getByUserName(userName: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserViewModel>;

    /**
     * Find users
     * @param filter (optional) 
     * @param x_Api_Version (optional) 
     */
    find(filter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserViewModel[]>;

    /**
     * Get count of users
     * @param filter (optional) 
     * @param x_Api_Version (optional) 
     */
    getUserCount(filter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Get all users
     * @param x_Api_Version (optional) 
     */
    getAll(x_Api_Version: string | null | undefined): Promise<UserViewModel[]>;

    /**
     * Get users paged
     * @param filter (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param x_Api_Version (optional) 
     */
    getPaged(filter: string | null | undefined, page: number | undefined, pageSize: number | undefined, x_Api_Version: string | null | undefined): Promise<UserViewModel[]>;

    /**
     * Update current user
     * @param x_Api_Version (optional) 
     */
    updateCurrentUser(x_Api_Version: string | null | undefined, user: UserEditViewModel): Promise<boolean>;

    /**
     * Patch current user
     * @param x_Api_Version (optional) 
     */
    patchUpdateCurrentUser(x_Api_Version: string | null | undefined, patch: Operation[]): Promise<boolean>;

    /**
     * Update a different users
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    update(userId: string | null | undefined, x_Api_Version: string | null | undefined, user: UserEditViewModel): Promise<boolean>;

    /**
     * Patch a different user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    patchUpdate(userId: string | null | undefined, x_Api_Version: string | null | undefined, patch: Operation[]): Promise<boolean>;

    /**
     * Create a new user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    create(userId: string | null | undefined, x_Api_Version: string | null | undefined, user: UserEditViewModel): Promise<boolean>;

    /**
     * Delete a user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    delete(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserViewModel>;

    /**
     * Unblock a user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    unblockUser(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;

    /**
     * Unblock a user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    blockUser(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;

    /**
     * Activate a user account
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    activateUser(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;

    /**
     * Register a new user account
     * @param x_Api_Version (optional) 
     */
    register(x_Api_Version: string | null | undefined, user: UserEditViewModel): Promise<UserViewModel>;

    /**
     * Send a registration email
     * @param x_Api_Version (optional) 
     */
    sendRegistrationMail(x_Api_Version: string | null | undefined, data: UserActivateViewModel): Promise<boolean>;

    /**
     * Activate a new user account
     * @param x_Api_Version (optional) 
     */
    activateAccount(x_Api_Version: string | null | undefined, data: UserActivateViewModel): Promise<boolean>;

    /**
     * Request a reset a user account
     * @param x_Api_Version (optional) 
     */
    passwordResetRequest(x_Api_Version: string | null | undefined, data: UserActivateViewModel): Promise<boolean>;

    /**
     * Reset a password request
     * @param x_Api_Version (optional) 
     */
    passwordReset(x_Api_Version: string | null | undefined, data: UserPasswordResetViewModel): Promise<boolean>;

    /**
     * Verify Phone number
     * @param userId (optional) 
     * @param phoneNo (optional) 
     * @param token (optional) 
     * @param x_Api_Version (optional) 
     */
    verifyPhoneNo(userId: string | null | undefined, phoneNo: string | null | undefined, token: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string>;

    /**
     * Get 2FAProviders
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    get2FAProviders(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string[]>;

    /**
     * Get Verify 2FA Token
     * @param userId (optional) 
     * @param provider (optional) 
     * @param token (optional) 
     * @param x_Api_Version (optional) 
     */
    verify2FAToken(userId: string | null | undefined, provider: string | null | undefined, token: string | null | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;

    /**
     * Enable 2FA
     * @param userId (optional) 
     * @param provider (optional) 
     * @param x_Api_Version (optional) 
     */
    enable2FA(userId: string | null | undefined, provider: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string>;

    /**
     * Disable 2FA
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    disable2FA(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;

    /**
     * Get Authenticator Url
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    getAuthenticatorUrl(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string>;

    /**
     * Enabled and Generate Authenticator Key
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    generateAuthenticatorKey(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string>;

    /**
     * Get list of current user login providers
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    getUserLoginProviders(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserLoginInfo[]>;

    /**
     * Get list of current user login providers
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteUserLoginProvider(userId: string | null | undefined, x_Api_Version: string | null | undefined, logininfo: UserLoginInfo): Promise<UserLoginInfo>;
}

export class AccountClient extends AIForgedBase implements IAccountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get current logged in user
     * @param x_Api_Version (optional) 
     * @return User data
     */
    getCurrentUser(x_Api_Version: string | null | undefined): Promise<UserViewModel> {
        let url_ = this.baseUrl + "/api/Account/GetCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCurrentUser(_response));
        });
    }

    protected processGetCurrentUser(response: Response): Promise<UserViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserViewModel>(null as any);
    }

    /**
     * Get api key for a user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     * @return API-Key
     */
    getApiKey(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Account/GetAPIKey?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetApiKey(_response));
        });
    }

    protected processGetApiKey(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get user by Id
     * @param userid (optional) The user id
     * @param x_Api_Version (optional) 
     */
    getById(userid: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserViewModel> {
        let url_ = this.baseUrl + "/api/Account/GetById?";
        if (userid !== undefined && userid !== null)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetById(_response));
        });
    }

    protected processGetById(response: Response): Promise<UserViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserViewModel>(null as any);
    }

    /**
     * Get user info by username
     * @param userName (optional) 
     * @param x_Api_Version (optional) 
     */
    getByUserName(userName: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserViewModel> {
        let url_ = this.baseUrl + "/api/Account/GetByUserName?";
        if (userName !== undefined && userName !== null)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetByUserName(_response));
        });
    }

    protected processGetByUserName(response: Response): Promise<UserViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserViewModel>(null as any);
    }

    /**
     * Find users
     * @param filter (optional) 
     * @param x_Api_Version (optional) 
     */
    find(filter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserViewModel[]> {
        let url_ = this.baseUrl + "/api/Account/Find?";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processFind(_response));
        });
    }

    protected processFind(response: Response): Promise<UserViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserViewModel[]>(null as any);
    }

    /**
     * Get count of users
     * @param filter (optional) 
     * @param x_Api_Version (optional) 
     */
    getUserCount(filter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Account/GetUserCount?";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetUserCount(_response));
        });
    }

    protected processGetUserCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get all users
     * @param x_Api_Version (optional) 
     */
    getAll(x_Api_Version: string | null | undefined): Promise<UserViewModel[]> {
        let url_ = this.baseUrl + "/api/Account/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<UserViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserViewModel[]>(null as any);
    }

    /**
     * Get users paged
     * @param filter (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param x_Api_Version (optional) 
     */
    getPaged(filter: string | null | undefined, page: number | undefined, pageSize: number | undefined, x_Api_Version: string | null | undefined): Promise<UserViewModel[]> {
        let url_ = this.baseUrl + "/api/Account/GetPaged?";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPaged(_response));
        });
    }

    protected processGetPaged(response: Response): Promise<UserViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserViewModel[]>(null as any);
    }

    /**
     * Update current user
     * @param x_Api_Version (optional) 
     */
    updateCurrentUser(x_Api_Version: string | null | undefined, user: UserEditViewModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/UpdateCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateCurrentUser(_response));
        });
    }

    protected processUpdateCurrentUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Patch current user
     * @param x_Api_Version (optional) 
     */
    patchUpdateCurrentUser(x_Api_Version: string | null | undefined, patch: Operation[]): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/PatchUpdateCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patch);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPatchUpdateCurrentUser(_response));
        });
    }

    protected processPatchUpdateCurrentUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Update a different users
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    update(userId: string | null | undefined, x_Api_Version: string | null | undefined, user: UserEditViewModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/Update?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Patch a different user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    patchUpdate(userId: string | null | undefined, x_Api_Version: string | null | undefined, patch: Operation[]): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/PatchUpdate?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patch);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPatchUpdate(_response));
        });
    }

    protected processPatchUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Create a new user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    create(userId: string | null | undefined, x_Api_Version: string | null | undefined, user: UserEditViewModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/Create?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Delete a user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    delete(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserViewModel> {
        let url_ = this.baseUrl + "/api/Account/Delete?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<UserViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserViewModel>(null as any);
    }

    /**
     * Unblock a user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    unblockUser(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/UnblockUser?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUnblockUser(_response));
        });
    }

    protected processUnblockUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Unblock a user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    blockUser(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/BlockUser?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processBlockUser(_response));
        });
    }

    protected processBlockUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Activate a user account
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    activateUser(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/ActivateUser?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processActivateUser(_response));
        });
    }

    protected processActivateUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Register a new user account
     * @param x_Api_Version (optional) 
     */
    register(x_Api_Version: string | null | undefined, user: UserEditViewModel): Promise<UserViewModel> {
        let url_ = this.baseUrl + "/api/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRegister(_response));
        });
    }

    protected processRegister(response: Response): Promise<UserViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserViewModel>(null as any);
    }

    /**
     * Send a registration email
     * @param x_Api_Version (optional) 
     */
    sendRegistrationMail(x_Api_Version: string | null | undefined, data: UserActivateViewModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/SendRegistrationMail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSendRegistrationMail(_response));
        });
    }

    protected processSendRegistrationMail(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Activate a new user account
     * @param x_Api_Version (optional) 
     */
    activateAccount(x_Api_Version: string | null | undefined, data: UserActivateViewModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/ActivateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processActivateAccount(_response));
        });
    }

    protected processActivateAccount(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Request a reset a user account
     * @param x_Api_Version (optional) 
     */
    passwordResetRequest(x_Api_Version: string | null | undefined, data: UserActivateViewModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/PasswordResetRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPasswordResetRequest(_response));
        });
    }

    protected processPasswordResetRequest(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Reset a password request
     * @param x_Api_Version (optional) 
     */
    passwordReset(x_Api_Version: string | null | undefined, data: UserPasswordResetViewModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/PasswordReset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPasswordReset(_response));
        });
    }

    protected processPasswordReset(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Verify Phone number
     * @param userId (optional) 
     * @param phoneNo (optional) 
     * @param token (optional) 
     * @param x_Api_Version (optional) 
     */
    verifyPhoneNo(userId: string | null | undefined, phoneNo: string | null | undefined, token: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Account/VerifyPhoneNo?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (phoneNo !== undefined && phoneNo !== null)
            url_ += "phoneNo=" + encodeURIComponent("" + phoneNo) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processVerifyPhoneNo(_response));
        });
    }

    protected processVerifyPhoneNo(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get 2FAProviders
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    get2FAProviders(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Account/Get2FAProviders?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet2FAProviders(_response));
        });
    }

    protected processGet2FAProviders(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * Get Verify 2FA Token
     * @param userId (optional) 
     * @param provider (optional) 
     * @param token (optional) 
     * @param x_Api_Version (optional) 
     */
    verify2FAToken(userId: string | null | undefined, provider: string | null | undefined, token: string | null | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Account/Verify2FAToken?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (provider !== undefined && provider !== null)
            url_ += "provider=" + encodeURIComponent("" + provider) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processVerify2FAToken(_response));
        });
    }

    protected processVerify2FAToken(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Enable 2FA
     * @param userId (optional) 
     * @param provider (optional) 
     * @param x_Api_Version (optional) 
     */
    enable2FA(userId: string | null | undefined, provider: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Account/Enable2FA?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (provider !== undefined && provider !== null)
            url_ += "provider=" + encodeURIComponent("" + provider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEnable2FA(_response));
        });
    }

    protected processEnable2FA(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Disable 2FA
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    disable2FA(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Account/Disable2FA?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDisable2FA(_response));
        });
    }

    protected processDisable2FA(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get Authenticator Url
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    getAuthenticatorUrl(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Account/GetAuthenticatorUrl?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAuthenticatorUrl(_response));
        });
    }

    protected processGetAuthenticatorUrl(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Enabled and Generate Authenticator Key
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    generateAuthenticatorKey(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Account/GenerateAuthenticator?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGenerateAuthenticatorKey(_response));
        });
    }

    protected processGenerateAuthenticatorKey(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get list of current user login providers
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    getUserLoginProviders(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserLoginInfo[]> {
        let url_ = this.baseUrl + "/api/Account/GetUserLoginProviders?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetUserLoginProviders(_response));
        });
    }

    protected processGetUserLoginProviders(response: Response): Promise<UserLoginInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserLoginInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserLoginInfo[]>(null as any);
    }

    /**
     * Get list of current user login providers
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteUserLoginProvider(userId: string | null | undefined, x_Api_Version: string | null | undefined, logininfo: UserLoginInfo): Promise<UserLoginInfo> {
        let url_ = this.baseUrl + "/api/Account/DeleteUserLoginProvider?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(logininfo);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteUserLoginProvider(_response));
        });
    }

    protected processDeleteUserLoginProvider(response: Response): Promise<UserLoginInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLoginInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserLoginInfo>(null as any);
    }
}

export interface IAuditClient {

    /**
     * Get audit info by Id
     * @param id (optional) Log record id
     * @param x_Api_Version (optional) 
     */
    get(id: number | undefined, x_Api_Version: string | null | undefined): Promise<AuditViewModel>;

    /**
     * Get audit by search criteria
     * @param userId (optional) User id
     * @param groupId (optional) 
     * @param entity (optional) Entity type
     * @param entityId (optional) Entity id
     * @param from (optional) From date
     * @param to (optional) To date
     * @param x_Api_Version (optional) 
     */
    getAll(userId: string | null | undefined, groupId: number | null | undefined, entity: AuditEntity | null | undefined, entityId: number | null | undefined, from: Date | null | undefined, to: Date | null | undefined, x_Api_Version: string | null | undefined): Promise<AuditViewModel[]>;
}

export class AuditClient extends AIForgedBase implements IAuditClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get audit info by Id
     * @param id (optional) Log record id
     * @param x_Api_Version (optional) 
     */
    get(id: number | undefined, x_Api_Version: string | null | undefined): Promise<AuditViewModel> {
        let url_ = this.baseUrl + "/api/Audit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<AuditViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditViewModel>(null as any);
    }

    /**
     * Get audit by search criteria
     * @param userId (optional) User id
     * @param groupId (optional) 
     * @param entity (optional) Entity type
     * @param entityId (optional) Entity id
     * @param from (optional) From date
     * @param to (optional) To date
     * @param x_Api_Version (optional) 
     */
    getAll(userId: string | null | undefined, groupId: number | null | undefined, entity: AuditEntity | null | undefined, entityId: number | null | undefined, from: Date | null | undefined, to: Date | null | undefined, x_Api_Version: string | null | undefined): Promise<AuditViewModel[]> {
        let url_ = this.baseUrl + "/api/Audit/GetAll?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (entity !== undefined && entity !== null)
            url_ += "entity=" + encodeURIComponent("" + entity) + "&";
        if (entityId !== undefined && entityId !== null)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<AuditViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuditViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditViewModel[]>(null as any);
    }
}

export interface IBundlesClient {

    /**
     * Get all bundles
     * @param x_Api_Version (optional) 
     */
    getAll(x_Api_Version: string | null | undefined): Promise<BundlesViewModel[]>;

    /**
     * Create a new bundle
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, bundle: BundlesViewModel): Promise<BundlesViewModel>;

    /**
     * Update a bundle
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, bundle: BundlesViewModel): Promise<BundlesViewModel>;

    /**
     * Delete a bundle
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<BundlesViewModel>;
}

export class BundlesClient extends AIForgedBase implements IBundlesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get all bundles
     * @param x_Api_Version (optional) 
     */
    getAll(x_Api_Version: string | null | undefined): Promise<BundlesViewModel[]> {
        let url_ = this.baseUrl + "/api/Bundles/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<BundlesViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BundlesViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BundlesViewModel[]>(null as any);
    }

    /**
     * Create a new bundle
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, bundle: BundlesViewModel): Promise<BundlesViewModel> {
        let url_ = this.baseUrl + "/api/Bundles/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bundle);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<BundlesViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BundlesViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BundlesViewModel>(null as any);
    }

    /**
     * Update a bundle
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, bundle: BundlesViewModel): Promise<BundlesViewModel> {
        let url_ = this.baseUrl + "/api/Bundles/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bundle);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<BundlesViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BundlesViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BundlesViewModel>(null as any);
    }

    /**
     * Delete a bundle
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<BundlesViewModel> {
        let url_ = this.baseUrl + "/api/Bundles/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<BundlesViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BundlesViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BundlesViewModel>(null as any);
    }
}

export interface IClassesClient {

    /**
     * Get classification information
     * @param id (optional) The id of the classification
     * @param x_Api_Version (optional) 
     * @return The class/category
     */
    get(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ClassesViewModel>;

    /**
     * Get all categories by project
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     * @return List of classes
     */
    getByProject(projectId: number | undefined, x_Api_Version: string | null | undefined): Promise<ClassesViewModel[]>;

    /**
     * Get category by project / name
     * @param projectId (optional) The project id
     * @param name (optional) 
     * @param lookupMethod (optional) 
     * @param minConfidence (optional) 
     * @param x_Api_Version (optional) 
     * @return List of classes
     */
    findByName(projectId: number | undefined, name: string | null | undefined, lookupMethod: DictionaryLookupMethod | null | undefined, minConfidence: number | undefined, x_Api_Version: string | null | undefined): Promise<ClassesViewModel>;

    /**
     * Get by user and project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     * @return List of classes
     */
    getByUser(userId: string | null | undefined, projectId: number | undefined, x_Api_Version: string | null | undefined): Promise<ClassesViewModel[]>;

    /**
     * Create a new category
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, newclass: ClassesViewModel): Promise<ClassesViewModel>;

    /**
     * Update a category
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, docclass: ClassesViewModel): Promise<ClassesViewModel>;

    /**
     * Delete a category
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param classId (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(userId: string | null | undefined, projectId: number | undefined, classId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;
}

export class ClassesClient extends AIForgedBase implements IClassesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get classification information
     * @param id (optional) The id of the classification
     * @param x_Api_Version (optional) 
     * @return The class/category
     */
    get(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ClassesViewModel> {
        let url_ = this.baseUrl + "/api/Classes/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<ClassesViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassesViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClassesViewModel>(null as any);
    }

    /**
     * Get all categories by project
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     * @return List of classes
     */
    getByProject(projectId: number | undefined, x_Api_Version: string | null | undefined): Promise<ClassesViewModel[]> {
        let url_ = this.baseUrl + "/api/Classes/GetByProject?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetByProject(_response));
        });
    }

    protected processGetByProject(response: Response): Promise<ClassesViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassesViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClassesViewModel[]>(null as any);
    }

    /**
     * Get category by project / name
     * @param projectId (optional) The project id
     * @param name (optional) 
     * @param lookupMethod (optional) 
     * @param minConfidence (optional) 
     * @param x_Api_Version (optional) 
     * @return List of classes
     */
    findByName(projectId: number | undefined, name: string | null | undefined, lookupMethod: DictionaryLookupMethod | null | undefined, minConfidence: number | undefined, x_Api_Version: string | null | undefined): Promise<ClassesViewModel> {
        let url_ = this.baseUrl + "/api/Classes/FindByName?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (lookupMethod !== undefined && lookupMethod !== null)
            url_ += "lookupMethod=" + encodeURIComponent("" + lookupMethod) + "&";
        if (minConfidence === null)
            throw new Error("The parameter 'minConfidence' cannot be null.");
        else if (minConfidence !== undefined)
            url_ += "minConfidence=" + encodeURIComponent("" + minConfidence) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processFindByName(_response));
        });
    }

    protected processFindByName(response: Response): Promise<ClassesViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassesViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClassesViewModel>(null as any);
    }

    /**
     * Get by user and project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     * @return List of classes
     */
    getByUser(userId: string | null | undefined, projectId: number | undefined, x_Api_Version: string | null | undefined): Promise<ClassesViewModel[]> {
        let url_ = this.baseUrl + "/api/Classes/GetByUser?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetByUser(_response));
        });
    }

    protected processGetByUser(response: Response): Promise<ClassesViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClassesViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClassesViewModel[]>(null as any);
    }

    /**
     * Create a new category
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, newclass: ClassesViewModel): Promise<ClassesViewModel> {
        let url_ = this.baseUrl + "/api/Classes/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newclass);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<ClassesViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassesViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClassesViewModel>(null as any);
    }

    /**
     * Update a category
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, docclass: ClassesViewModel): Promise<ClassesViewModel> {
        let url_ = this.baseUrl + "/api/Classes/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(docclass);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<ClassesViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassesViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClassesViewModel>(null as any);
    }

    /**
     * Delete a category
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param classId (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(userId: string | null | undefined, projectId: number | undefined, classId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Classes/Delete?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface IContactClient {

    /**
     * Get Contacts
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    get(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ContactViewModel[]>;

    /**
     * Create contacts
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, contact: ContactViewModel): Promise<ContactViewModel>;

    /**
     * Update contacts
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, contact: ContactViewModel): Promise<ContactViewModel>;

    /**
     * Delete
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ContactViewModel>;
}

export class ContactClient extends AIForgedBase implements IContactClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get Contacts
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    get(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ContactViewModel[]> {
        let url_ = this.baseUrl + "/api/Contact/Get?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<ContactViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactViewModel[]>(null as any);
    }

    /**
     * Create contacts
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, contact: ContactViewModel): Promise<ContactViewModel> {
        let url_ = this.baseUrl + "/api/Contact/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contact);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<ContactViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactViewModel>(null as any);
    }

    /**
     * Update contacts
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, contact: ContactViewModel): Promise<ContactViewModel> {
        let url_ = this.baseUrl + "/api/Contact/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contact);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<ContactViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactViewModel>(null as any);
    }

    /**
     * Delete
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ContactViewModel> {
        let url_ = this.baseUrl + "/api/Contact/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<ContactViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactViewModel>(null as any);
    }
}

export interface IDataSetClient {

    /**
     * Get custom dataset and data
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param includeData (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortFieldDefId (optional) 
     * @param sortDirection (optional) 
     * @param searchField (optional) 
     * @param searchFilter (optional) 
     * @param x_Api_Version (optional) 
     */
    get(docId: number | undefined, defId: number | undefined, includeData: boolean | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortFieldDefId: number | null | undefined, sortDirection: SortDirection | null | undefined, searchField: string | null | undefined, searchFilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet>;

    /**
     * Extract custom dataset
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param dataSetName (optional) 
     * @param includeData (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortFieldDefId (optional) 
     * @param sortDirection (optional) 
     * @param searchField (optional) 
     * @param searchFilter (optional) 
     * @param x_Api_Version (optional) 
     */
    getByName(projectId: number | undefined, stpdId: number | undefined, dataSetName: string | null | undefined, includeData: boolean | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortFieldDefId: number | null | undefined, sortDirection: SortDirection | null | undefined, searchField: string | null | undefined, searchFilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet>;

    /**
     * Extract custom dataset
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param pdId (optional) 
     * @param includeData (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortFieldDefId (optional) 
     * @param sortDirection (optional) 
     * @param searchField (optional) 
     * @param searchFilter (optional) 
     * @param x_Api_Version (optional) 
     */
    getByDef(projectId: number | undefined, stpdId: number | undefined, pdId: number | undefined, includeData: boolean | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortFieldDefId: number | null | undefined, sortDirection: SortDirection | null | undefined, searchField: string | null | undefined, searchFilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet>;

    /**
     * Extract custom dataset by dataset id
     * @param dataSetId (optional) The project id
     * @param includeData (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortFieldDefId (optional) 
     * @param sortDirection (optional) 
     * @param searchField (optional) 
     * @param searchFilter (optional) 
     * @param x_Api_Version (optional) 
     */
    getById(dataSetId: number | undefined, includeData: boolean | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortFieldDefId: number | null | undefined, sortDirection: SortDirection | null | undefined, searchField: string | null | undefined, searchFilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet>;

    /**
     * Get all datasets
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param x_Api_Version (optional) 
     */
    getAll(projectId: number | undefined, stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet[]>;

    /**
     * Create a new empty custom dataset
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param dataSetName (optional) 
     * @param x_Api_Version (optional) 
     */
    create(projectId: number | undefined, stpdId: number | undefined, dataSetName: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet>;

    /**
     * Delete custom dataset
     * @param docid (optional) 
     * @param defId (optional) 
     * @param definition (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(docid: number | undefined, defId: number | undefined, definition: boolean | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Get a custom dataset record
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param keyId (optional) 
     * @param includeVerifications (optional) 
     * @param x_Api_Version (optional) 
     */
    getRecord(docId: number | undefined, defId: number | undefined, keyId: number | undefined, includeVerifications: boolean | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSetRecord>;

    /**
     * Find a custom dataset by key
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param keyValue (optional) 
     * @param includeVerifications (optional) 
     * @param x_Api_Version (optional) 
     */
    getRecordByKeyValue(docId: number | undefined, defId: number | undefined, keyValue: string | null | undefined, includeVerifications: boolean | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSetRecord>;

    /**
     * Update a custom dataset record
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param x_Api_Version (optional) 
     */
    updateRecord(docId: number | undefined, defId: number | undefined, x_Api_Version: string | null | undefined, record: CustomDataSetRecord): Promise<CustomDataSetRecord>;

    /**
     * Delete a custom dataset record by key id
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param keyId (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteRecord(docId: number | undefined, defId: number | undefined, keyId: number | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSetRecord[]>;

    /**
     * Delete multiple custom dataset records by key ids
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteRecords(docId: number | undefined, defId: number | undefined, x_Api_Version: string | null | undefined, keyIds: number[]): Promise<CustomDataSetRecord[]>;

    /**
     * Delete a custom dataset record by key value
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param keyValue (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteRecordByKeyValue(docId: number | undefined, defId: number | undefined, keyValue: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSetRecord[]>;

    /**
     * Save custom dataset
     * @param mergeData (optional) 
     * @param x_Api_Version (optional) 
     */
    save(mergeData: boolean | undefined, x_Api_Version: string | null | undefined, dataset: CustomDataSet): Promise<number>;

    /**
     * Sync custom dataset with service / categories
     * @param projectId (optional) 
     * @param stpdId (optional) 
     * @param pdId (optional) 
     * @param x_Api_Version (optional) 
     */
    sync(projectId: number | undefined, stpdId: number | undefined, pdId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;
}

export class DataSetClient extends AIForgedBase implements IDataSetClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get custom dataset and data
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param includeData (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortFieldDefId (optional) 
     * @param sortDirection (optional) 
     * @param searchField (optional) 
     * @param searchFilter (optional) 
     * @param x_Api_Version (optional) 
     */
    get(docId: number | undefined, defId: number | undefined, includeData: boolean | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortFieldDefId: number | null | undefined, sortDirection: SortDirection | null | undefined, searchField: string | null | undefined, searchFilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet> {
        let url_ = this.baseUrl + "/api/DataSet/Get?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (defId === null)
            throw new Error("The parameter 'defId' cannot be null.");
        else if (defId !== undefined)
            url_ += "defId=" + encodeURIComponent("" + defId) + "&";
        if (includeData === null)
            throw new Error("The parameter 'includeData' cannot be null.");
        else if (includeData !== undefined)
            url_ += "includeData=" + encodeURIComponent("" + includeData) + "&";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "pageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortFieldDefId !== undefined && sortFieldDefId !== null)
            url_ += "sortFieldDefId=" + encodeURIComponent("" + sortFieldDefId) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchField !== undefined && searchField !== null)
            url_ += "searchField=" + encodeURIComponent("" + searchField) + "&";
        if (searchFilter !== undefined && searchFilter !== null)
            url_ += "searchFilter=" + encodeURIComponent("" + searchFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<CustomDataSet> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomDataSet.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSet>(null as any);
    }

    /**
     * Extract custom dataset
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param dataSetName (optional) 
     * @param includeData (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortFieldDefId (optional) 
     * @param sortDirection (optional) 
     * @param searchField (optional) 
     * @param searchFilter (optional) 
     * @param x_Api_Version (optional) 
     */
    getByName(projectId: number | undefined, stpdId: number | undefined, dataSetName: string | null | undefined, includeData: boolean | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortFieldDefId: number | null | undefined, sortDirection: SortDirection | null | undefined, searchField: string | null | undefined, searchFilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet> {
        let url_ = this.baseUrl + "/api/DataSet/GetByName?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (dataSetName !== undefined && dataSetName !== null)
            url_ += "dataSetName=" + encodeURIComponent("" + dataSetName) + "&";
        if (includeData === null)
            throw new Error("The parameter 'includeData' cannot be null.");
        else if (includeData !== undefined)
            url_ += "includeData=" + encodeURIComponent("" + includeData) + "&";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "pageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortFieldDefId !== undefined && sortFieldDefId !== null)
            url_ += "sortFieldDefId=" + encodeURIComponent("" + sortFieldDefId) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchField !== undefined && searchField !== null)
            url_ += "searchField=" + encodeURIComponent("" + searchField) + "&";
        if (searchFilter !== undefined && searchFilter !== null)
            url_ += "searchFilter=" + encodeURIComponent("" + searchFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetByName(_response));
        });
    }

    protected processGetByName(response: Response): Promise<CustomDataSet> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomDataSet.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSet>(null as any);
    }

    /**
     * Extract custom dataset
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param pdId (optional) 
     * @param includeData (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortFieldDefId (optional) 
     * @param sortDirection (optional) 
     * @param searchField (optional) 
     * @param searchFilter (optional) 
     * @param x_Api_Version (optional) 
     */
    getByDef(projectId: number | undefined, stpdId: number | undefined, pdId: number | undefined, includeData: boolean | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortFieldDefId: number | null | undefined, sortDirection: SortDirection | null | undefined, searchField: string | null | undefined, searchFilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet> {
        let url_ = this.baseUrl + "/api/DataSet/GetByDef?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (pdId === null)
            throw new Error("The parameter 'pdId' cannot be null.");
        else if (pdId !== undefined)
            url_ += "pdId=" + encodeURIComponent("" + pdId) + "&";
        if (includeData === null)
            throw new Error("The parameter 'includeData' cannot be null.");
        else if (includeData !== undefined)
            url_ += "includeData=" + encodeURIComponent("" + includeData) + "&";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "pageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortFieldDefId !== undefined && sortFieldDefId !== null)
            url_ += "sortFieldDefId=" + encodeURIComponent("" + sortFieldDefId) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchField !== undefined && searchField !== null)
            url_ += "searchField=" + encodeURIComponent("" + searchField) + "&";
        if (searchFilter !== undefined && searchFilter !== null)
            url_ += "searchFilter=" + encodeURIComponent("" + searchFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetByDef(_response));
        });
    }

    protected processGetByDef(response: Response): Promise<CustomDataSet> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomDataSet.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSet>(null as any);
    }

    /**
     * Extract custom dataset by dataset id
     * @param dataSetId (optional) The project id
     * @param includeData (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortFieldDefId (optional) 
     * @param sortDirection (optional) 
     * @param searchField (optional) 
     * @param searchFilter (optional) 
     * @param x_Api_Version (optional) 
     */
    getById(dataSetId: number | undefined, includeData: boolean | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortFieldDefId: number | null | undefined, sortDirection: SortDirection | null | undefined, searchField: string | null | undefined, searchFilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet> {
        let url_ = this.baseUrl + "/api/DataSet/GetById?";
        if (dataSetId === null)
            throw new Error("The parameter 'dataSetId' cannot be null.");
        else if (dataSetId !== undefined)
            url_ += "dataSetId=" + encodeURIComponent("" + dataSetId) + "&";
        if (includeData === null)
            throw new Error("The parameter 'includeData' cannot be null.");
        else if (includeData !== undefined)
            url_ += "includeData=" + encodeURIComponent("" + includeData) + "&";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "pageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortFieldDefId !== undefined && sortFieldDefId !== null)
            url_ += "sortFieldDefId=" + encodeURIComponent("" + sortFieldDefId) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (searchField !== undefined && searchField !== null)
            url_ += "searchField=" + encodeURIComponent("" + searchField) + "&";
        if (searchFilter !== undefined && searchFilter !== null)
            url_ += "searchFilter=" + encodeURIComponent("" + searchFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetById(_response));
        });
    }

    protected processGetById(response: Response): Promise<CustomDataSet> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomDataSet.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSet>(null as any);
    }

    /**
     * Get all datasets
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param x_Api_Version (optional) 
     */
    getAll(projectId: number | undefined, stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet[]> {
        let url_ = this.baseUrl + "/api/DataSet/GetAll?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<CustomDataSet[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomDataSet.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSet[]>(null as any);
    }

    /**
     * Create a new empty custom dataset
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param dataSetName (optional) 
     * @param x_Api_Version (optional) 
     */
    create(projectId: number | undefined, stpdId: number | undefined, dataSetName: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSet> {
        let url_ = this.baseUrl + "/api/DataSet/Create?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (dataSetName !== undefined && dataSetName !== null)
            url_ += "dataSetName=" + encodeURIComponent("" + dataSetName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<CustomDataSet> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomDataSet.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSet>(null as any);
    }

    /**
     * Delete custom dataset
     * @param docid (optional) 
     * @param defId (optional) 
     * @param definition (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(docid: number | undefined, defId: number | undefined, definition: boolean | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/DataSet/Delete?";
        if (docid === null)
            throw new Error("The parameter 'docid' cannot be null.");
        else if (docid !== undefined)
            url_ += "docid=" + encodeURIComponent("" + docid) + "&";
        if (defId === null)
            throw new Error("The parameter 'defId' cannot be null.");
        else if (defId !== undefined)
            url_ += "defId=" + encodeURIComponent("" + defId) + "&";
        if (definition === null)
            throw new Error("The parameter 'definition' cannot be null.");
        else if (definition !== undefined)
            url_ += "definition=" + encodeURIComponent("" + definition) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get a custom dataset record
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param keyId (optional) 
     * @param includeVerifications (optional) 
     * @param x_Api_Version (optional) 
     */
    getRecord(docId: number | undefined, defId: number | undefined, keyId: number | undefined, includeVerifications: boolean | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSetRecord> {
        let url_ = this.baseUrl + "/api/DataSet/GetRecord?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (defId === null)
            throw new Error("The parameter 'defId' cannot be null.");
        else if (defId !== undefined)
            url_ += "defId=" + encodeURIComponent("" + defId) + "&";
        if (keyId === null)
            throw new Error("The parameter 'keyId' cannot be null.");
        else if (keyId !== undefined)
            url_ += "keyId=" + encodeURIComponent("" + keyId) + "&";
        if (includeVerifications === null)
            throw new Error("The parameter 'includeVerifications' cannot be null.");
        else if (includeVerifications !== undefined)
            url_ += "includeVerifications=" + encodeURIComponent("" + includeVerifications) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetRecord(_response));
        });
    }

    protected processGetRecord(response: Response): Promise<CustomDataSetRecord> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomDataSetRecord.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSetRecord>(null as any);
    }

    /**
     * Find a custom dataset by key
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param keyValue (optional) 
     * @param includeVerifications (optional) 
     * @param x_Api_Version (optional) 
     */
    getRecordByKeyValue(docId: number | undefined, defId: number | undefined, keyValue: string | null | undefined, includeVerifications: boolean | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSetRecord> {
        let url_ = this.baseUrl + "/api/DataSet/GetRecordByKeyValue?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (defId === null)
            throw new Error("The parameter 'defId' cannot be null.");
        else if (defId !== undefined)
            url_ += "defId=" + encodeURIComponent("" + defId) + "&";
        if (keyValue !== undefined && keyValue !== null)
            url_ += "keyValue=" + encodeURIComponent("" + keyValue) + "&";
        if (includeVerifications === null)
            throw new Error("The parameter 'includeVerifications' cannot be null.");
        else if (includeVerifications !== undefined)
            url_ += "includeVerifications=" + encodeURIComponent("" + includeVerifications) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetRecordByKeyValue(_response));
        });
    }

    protected processGetRecordByKeyValue(response: Response): Promise<CustomDataSetRecord> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomDataSetRecord.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSetRecord>(null as any);
    }

    /**
     * Update a custom dataset record
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param x_Api_Version (optional) 
     */
    updateRecord(docId: number | undefined, defId: number | undefined, x_Api_Version: string | null | undefined, record: CustomDataSetRecord): Promise<CustomDataSetRecord> {
        let url_ = this.baseUrl + "/api/DataSet/UpdateRecord?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (defId === null)
            throw new Error("The parameter 'defId' cannot be null.");
        else if (defId !== undefined)
            url_ += "defId=" + encodeURIComponent("" + defId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(record);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateRecord(_response));
        });
    }

    protected processUpdateRecord(response: Response): Promise<CustomDataSetRecord> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomDataSetRecord.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSetRecord>(null as any);
    }

    /**
     * Delete a custom dataset record by key id
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param keyId (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteRecord(docId: number | undefined, defId: number | undefined, keyId: number | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSetRecord[]> {
        let url_ = this.baseUrl + "/api/DataSet/DeleteRecord?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (defId === null)
            throw new Error("The parameter 'defId' cannot be null.");
        else if (defId !== undefined)
            url_ += "defId=" + encodeURIComponent("" + defId) + "&";
        if (keyId === null)
            throw new Error("The parameter 'keyId' cannot be null.");
        else if (keyId !== undefined)
            url_ += "keyId=" + encodeURIComponent("" + keyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteRecord(_response));
        });
    }

    protected processDeleteRecord(response: Response): Promise<CustomDataSetRecord[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomDataSetRecord.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSetRecord[]>(null as any);
    }

    /**
     * Delete multiple custom dataset records by key ids
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteRecords(docId: number | undefined, defId: number | undefined, x_Api_Version: string | null | undefined, keyIds: number[]): Promise<CustomDataSetRecord[]> {
        let url_ = this.baseUrl + "/api/DataSet/DeleteRecords?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (defId === null)
            throw new Error("The parameter 'defId' cannot be null.");
        else if (defId !== undefined)
            url_ += "defId=" + encodeURIComponent("" + defId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(keyIds);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteRecords(_response));
        });
    }

    protected processDeleteRecords(response: Response): Promise<CustomDataSetRecord[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomDataSetRecord.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSetRecord[]>(null as any);
    }

    /**
     * Delete a custom dataset record by key value
     * @param docId (optional) The document id
     * @param defId (optional) 
     * @param keyValue (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteRecordByKeyValue(docId: number | undefined, defId: number | undefined, keyValue: string | null | undefined, x_Api_Version: string | null | undefined): Promise<CustomDataSetRecord[]> {
        let url_ = this.baseUrl + "/api/DataSet/DeleteByKeyValue?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (defId === null)
            throw new Error("The parameter 'defId' cannot be null.");
        else if (defId !== undefined)
            url_ += "defId=" + encodeURIComponent("" + defId) + "&";
        if (keyValue !== undefined && keyValue !== null)
            url_ += "keyValue=" + encodeURIComponent("" + keyValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteRecordByKeyValue(_response));
        });
    }

    protected processDeleteRecordByKeyValue(response: Response): Promise<CustomDataSetRecord[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomDataSetRecord.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomDataSetRecord[]>(null as any);
    }

    /**
     * Save custom dataset
     * @param mergeData (optional) 
     * @param x_Api_Version (optional) 
     */
    save(mergeData: boolean | undefined, x_Api_Version: string | null | undefined, dataset: CustomDataSet): Promise<number> {
        let url_ = this.baseUrl + "/api/DataSet/Save?";
        if (mergeData === null)
            throw new Error("The parameter 'mergeData' cannot be null.");
        else if (mergeData !== undefined)
            url_ += "mergeData=" + encodeURIComponent("" + mergeData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dataset);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSave(_response));
        });
    }

    protected processSave(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Sync custom dataset with service / categories
     * @param projectId (optional) 
     * @param stpdId (optional) 
     * @param pdId (optional) 
     * @param x_Api_Version (optional) 
     */
    sync(projectId: number | undefined, stpdId: number | undefined, pdId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/DataSet/Sync?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (pdId === null)
            throw new Error("The parameter 'pdId' cannot be null.");
        else if (pdId !== undefined)
            url_ += "pdId=" + encodeURIComponent("" + pdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSync(_response));
        });
    }

    protected processSync(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface IDocumentClient {

    /**
     * Get a document by Id
     * @param id (optional) The document id
     * @param x_Api_Version (optional) 
     * @return The document
     */
    getDocument(id: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel>;

    /**
     * Get a document and its related documents
     * @param id (optional) Document id
     * @param x_Api_Version (optional) 
     * @return Hierarchy of documents
     */
    getHierarchy(id: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel>;

    /**
     * Update a document
     * @param x_Api_Version (optional) 
     * @param document The document to update
     * @return The updated document
     */
    update(x_Api_Version: string | null | undefined, document: DocumentViewModel): Promise<DocumentViewModel>;

    /**
     * Delete a document by id
     * @param id (optional) Document id to delete
     * @param x_Api_Version (optional) 
     * @return The deleted document
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel>;

    /**
     * Delete multiple documents
     * @param ids (optional) The document Ids to delete
     * @param x_Api_Version (optional) 
     */
    deleteMulti(ids: number[] | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]>;

    /**
     * UnDelete a document by id
     * @param id (optional) Document id to undelete
     * @param newstatus (optional) The new status after undelete
     * @param usagefilter (optional) Only update documents for a specific usage
     * @param recursive (optional) Recursively undelete
     * @param x_Api_Version (optional) 
     * @return The master undeleted document
     */
    unDelete(id: number | undefined, newstatus: DocumentStatus | undefined, usagefilter: UsageType | null | undefined, recursive: boolean | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel>;

    /**
     * Copy a document to another project/service and supply a new status and usage
     * @param projectId (optional) Destination project
     * @param stpdId (optional) Destination service
     * @param status (optional) New status
     * @param usage (optional) New usage
     * @param includeAllData (optional) Include all image date
     * @param docIds (optional) List of socument Ids to copy
     * @param x_Api_Version (optional) 
     */
    copy(projectId: number | undefined, stpdId: number | undefined, status: DocumentStatus | undefined, usage: UsageType | undefined, includeAllData: boolean | undefined, docIds: number[] | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]>;

    /**
     * Move a document to another project and service
     * @param projectId (optional) The project id
     * @param toStpdId (optional) 
     * @param toStatus (optional) 
     * @param toUsage (optional) 
     * @param docIds (optional) 
     * @param x_Api_Version (optional) 
     */
    move(projectId: number | undefined, toStpdId: number | undefined, toStatus: DocumentStatus | undefined, toUsage: UsageType | undefined, docIds: number[] | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]>;

    /**
     * Bulk Copy document by status and usage to another service
     * @param projectFromId (optional) 
     * @param stpdIdFrom (optional) 
     * @param statusFrom (optional) 
     * @param usageFrom (optional) 
     * @param projectToId (optional) 
     * @param stpdIdTo (optional) 
     * @param statusTo (optional) 
     * @param usageTo (optional) 
     * @param includeAllData (optional) 
     * @param x_Api_Version (optional) 
     */
    bulkCopy(projectFromId: number | undefined, stpdIdFrom: number | undefined, statusFrom: DocumentStatus | undefined, usageFrom: UsageType | undefined, projectToId: number | undefined, stpdIdTo: number | undefined, statusTo: DocumentStatus | undefined, usageTo: UsageType | undefined, includeAllData: boolean | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Bulk update document by status and usage
     * @param projectId (optional) The project id
     * @param stpdIdFrom (optional) 
     * @param statusFrom (optional) 
     * @param usageFrom (optional) 
     * @param statusTo (optional) 
     * @param usageTo (optional) 
     * @param x_Api_Version (optional) 
     */
    bulkUpdate(projectId: number | undefined, stpdIdFrom: number | undefined, statusFrom: DocumentStatus | undefined, usageFrom: UsageType | undefined, statusTo: DocumentStatus | undefined, usageTo: UsageType | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Bulk Mode document by status and usage to another service
     * @param projectFromId (optional) 
     * @param stpdIdFrom (optional) 
     * @param statusFrom (optional) 
     * @param usageFrom (optional) 
     * @param projectToId (optional) 
     * @param stpdIdTo (optional) 
     * @param statusTo (optional) 
     * @param usageTo (optional) 
     * @param x_Api_Version (optional) 
     */
    bulkMove(projectFromId: number | undefined, stpdIdFrom: number | undefined, statusFrom: DocumentStatus | undefined, usageFrom: UsageType | undefined, projectToId: number | undefined, stpdIdTo: number | undefined, statusTo: DocumentStatus | undefined, usageTo: UsageType | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Bulk change document classes by status and usage
     * @param projectId (optional) The project id
     * @param stpdIdFrom (optional) 
     * @param statusFrom (optional) 
     * @param usageFrom (optional) 
     * @param fromClassId (optional) 
     * @param toClassId (optional) 
     * @param x_Api_Version (optional) 
     */
    bulkClassChange(projectId: number | undefined, stpdIdFrom: number | undefined, statusFrom: DocumentStatus | undefined, usageFrom: UsageType | undefined, fromClassId: number | null | undefined, toClassId: number | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Find latest child document to assist with verification
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param usage (optional) 
     * @param statuses (optional) 
     * @param filename (optional) 
     * @param classname (optional) 
     * @param masterid (optional) 
     * @param x_Api_Version (optional) 
     */
    findLatestChild(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, usage: UsageType | undefined, statuses: DocumentStatus[] | null | undefined, filename: string | null | undefined, classname: string | null | undefined, masterid: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]>;

    /**
     * Get preview documents and images for a service
     * @param userId (optional) The user that owns the service
     * @param projectId (optional) The project id
     * @param stpdId (optional) The service id
     * @param x_Api_Version (optional) 
     * @return The preview document
     */
    getPreviews(userId: string | null | undefined, projectId: number | undefined, stpdId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]>;

    /**
     * Find documnets by using structured search criteria.  The results can be paged
     * @param userId (optional) Owner of the document
     * @param projectId (optional) The project Id
     * @param stpdId (optional) The service id
     * @param usage (optional) The folder or usage
     * @param statuses (optional) List of statuses
     * @param classname (optional) A class name fileter
     * @param filename (optional) Filename filter
     * @param filetype (optional) File type filter
     * @param start (optional) Start date range for documents
     * @param end (optional) End date range for documents
     * @param masterid (optional) Master or parent of the document
     * @param includeparamdefcategories (optional) include gategories
     * @param pageNo (optional) Page number
     * @param pageSize (optional) Size of a page
     * @param sortField (optional) Sort by field
     * @param sortDirection (optional) Sort direction based on the sortfield
     * @param comment (optional) Filter for comments
     * @param result (optional) Filter for results
     * @param resultId (optional) Filter for a result id
     * @param resultIndex (optional) Filter for result index
     * @param externalId (optional) Filter for external ids
     * @param docGuid (optional) Filter for doc guids
     * @param x_Api_Version (optional) 
     */
    getExtended(userId: string | null | undefined, projectId: number | undefined, stpdId: number | null | undefined, usage: UsageType | null | undefined, statuses: DocumentStatus[] | null | undefined, classname: string | null | undefined, filename: string | null | undefined, filetype: string | null | undefined, start: Date | null | undefined, end: Date | null | undefined, masterid: number | null | undefined, includeparamdefcategories: (ParameterDefinitionCategory | undefined)[] | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, comment: string | null | undefined, result: string | null | undefined, resultId: string | null | undefined, resultIndex: number | null | undefined, externalId: string | null | undefined, docGuid: string | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]>;

    /**
     * Find documnets count by using structured search criteria
    This is used to detemine paging
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param usage (optional) 
     * @param statuses (optional) 
     * @param classname (optional) 
     * @param filename (optional) 
     * @param filetype (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @param masterid (optional) 
     * @param comment (optional) 
     * @param result (optional) 
     * @param resultId (optional) 
     * @param resultIndex (optional) 
     * @param externalId (optional) 
     * @param docGuid (optional) 
     * @param x_Api_Version (optional) 
     */
    getExtendedCount(userId: string | null | undefined, projectId: number | null | undefined, stpdId: number | null | undefined, usage: UsageType | null | undefined, statuses: DocumentStatus[] | null | undefined, classname: string | null | undefined, filename: string | null | undefined, filetype: string | null | undefined, start: Date | null | undefined, end: Date | null | undefined, masterid: number | null | undefined, comment: string | null | undefined, result: string | null | undefined, resultId: string | null | undefined, resultIndex: number | null | undefined, externalId: string | null | undefined, docGuid: string | null | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Get a summary of documents for analytics
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param usage (optional) 
     * @param statuses (optional) 
     * @param classname (optional) 
     * @param masterid (optional) 
     * @param interval (optional) 
     * @param getLabelledStats (optional) 
     * @param x_Api_Version (optional) 
     */
    getExSummary(userId: string | null | undefined, projectId: number | null | undefined, stpdId: number | null | undefined, usage: UsageType | null | undefined, statuses: DocumentStatus[] | null | undefined, classname: string | null | undefined, masterid: number | null | undefined, interval: string | null | undefined, getLabelledStats: boolean | undefined, x_Api_Version: string | null | undefined): Promise<DocumentsSummary[]>;

    /**
     * Get document images
     * @param id (optional) The document id
     * @param stpdId (optional) Service id
     * @param x_Api_Version (optional) 
     * @return List of document images
     */
    getImages(id: number | undefined, stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentDataViewModel[]>;

    /**
     * Get document images
     * @param id (optional) 
     * @param types (optional) 
     * @param contentType (optional) 
     * @param text (optional) 
     * @param blobid (optional) 
     * @param pageindex (optional) 
     * @param imagesCount (optional) 
     * @param x_Api_Version (optional) 
     */
    getData(id: number | undefined, types: (DocumentDataType | undefined)[] | null | undefined, contentType: string | null | undefined, text: string | null | undefined, blobid: number | null | undefined, pageindex: number | null | undefined, imagesCount: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentDataViewModel[]>;

    /**
     * Get system document
     * @param filename (optional) 
     * @param x_Api_Version (optional) 
     */
    getSystemDocument(filename: string | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentDataViewModel>;

    /**
     * Get system documents
     * @param pattern (optional) Filename pattern
     * @param filetype (optional) Optional: File type / extention
     * @param contenttype (optional) Optional: Content type
     * @param statuses (optional) Optional: statuses
     * @param masterId (optional) Optional: master id
     * @param x_Api_Version (optional) 
     */
    getSystemDocuments(pattern: string | null | undefined, filetype: string | null | undefined, contenttype: string | null | undefined, statuses: DocumentStatus[] | null | undefined, masterId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentDataViewModel[]>;

    getBlob(userId: string | null | undefined, id: number | undefined, types: (DocumentDataType | undefined)[] | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;

    /**
     * Get blob by blob key
     * @param id (optional) The blob id
     * @param x_Api_Version (optional) 
     * @return The blob
     */
    getBlobById(id: number | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;

    /**
     * Update a blob
     * @param userId (optional) Owner user id
     * @param x_Api_Version (optional) 
     * @param data The blob data to update
     * @return The result
     */
    updateBlob(userId: string | null | undefined, x_Api_Version: string | null | undefined, data: DocumentDataViewModel): Promise<FileResponse>;

    /**
     * Delete a document blob
     * @param id (optional) The blob id
     * @param x_Api_Version (optional) 
     * @return The result
     */
    deleteBlob(id: number | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;

    /**
     * Delete pages from a document
     * @param id (optional) The document id
     * @param childUsage (optional) 
     * @param childStatus (optional) 
     * @param childDeleteOptions (optional) 
     * @param x_Api_Version (optional) 
     * @return The result
     */
    deletePages(id: number | undefined, childUsage: UsageType | undefined, childStatus: DocumentStatus | undefined, childDeleteOptions: OperationOption | undefined, x_Api_Version: string | null | undefined, pageIndexes: number[]): Promise<DocumentDataViewModel>;

    /**
     * Change parameters and training to another page
     * @param id (optional) The document id
     * @param pageIndex (optional) 
     * @param x_Api_Version (optional) 
     * @return The result
     */
    deleteFieldsOnPage(id: number | undefined, pageIndex: number | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;

    /**
     * Change parameters and training to another page
     * @param id (optional) The document id
     * @param fromPageIndex (optional) 
     * @param toPageIndex (optional) 
     * @param x_Api_Version (optional) 
     * @return The result
     */
    changeFieldPageIndex(id: number | undefined, fromPageIndex: number | undefined, toPageIndex: number | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;

    /**
     * Change parameters and training to another page
     * @param id (optional) The document id
     * @param fromPageIndex (optional) 
     * @param toPageIndex (optional) 
     * @param x_Api_Version (optional) 
     * @return The result
     */
    setFieldPageVerificationIndex(id: number | undefined, fromPageIndex: number | undefined, toPageIndex: number | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;

    /**
     * Get Training Report
     * @param id (optional) The document id
     * @param x_Api_Version (optional) 
     * @return The result
     */
    getTrainingReport(id: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]>;

    /**
     * Fix page parameter index
     * @param id (optional) The document id
     * @param x_Api_Version (optional) 
     * @return The result
     */
    fixPageVerificationIndex(id: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]>;

    /**
     * Upload a document
     * @param stpdId (optional) Service id
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param classId (optional) 
     * @param status (optional) 
     * @param usage (optional) 
     * @param masterid (optional) 
     * @param comment (optional) 
     * @param externalId (optional) 
     * @param result (optional) 
     * @param resultId (optional) 
     * @param resultIndex (optional) 
     * @param guid (optional) 
     * @param x_Api_Version (optional) 
     * @param data (optional) 
     */
    upload(stpdId: number | undefined, userId: string | null | undefined, projectId: number | undefined, classId: number | null | undefined, status: DocumentStatus | undefined, usage: UsageType | undefined, masterid: number | null | undefined, comment: string | null | undefined, externalId: string | null | undefined, result: string | null | undefined, resultId: string | null | undefined, resultIndex: number | null | undefined, guid: string | undefined, x_Api_Version: string | null | undefined, data: any[] | null | undefined): Promise<DocumentViewModel[]>;

    /**
     * Store structured doument and containing data blob
     * @param stpdId (optional) Service id
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param masterid (optional) 
     * @param x_Api_Version (optional) 
     */
    store(stpdId: number | undefined, userId: string | null | undefined, projectId: number | undefined, masterid: number | null | undefined, x_Api_Version: string | null | undefined, docs: DocumentViewModel[]): Promise<DocumentViewModel[]>;

    /**
     * Upload and classify a document
     * @param stpdId (optional) The service id
     * @param projectId (optional) Project id
     * @param masterId (optional) 
     * @param comment (optional) 
     * @param externalId (optional) 
     * @param result (optional) 
     * @param resultId (optional) 
     * @param resultIndex (optional) 
     * @param guid (optional) 
     * @param x_Api_Version (optional) 
     * @param file (optional) 
     * @return The document
     */
    classify(stpdId: number | undefined, projectId: number | undefined, masterId: number | null | undefined, comment: string | null | undefined, externalId: string | null | undefined, result: string | null | undefined, resultId: string | null | undefined, resultIndex: number | null | undefined, guid: string | undefined, x_Api_Version: string | null | undefined, file: FileParameter | null | undefined): Promise<DocumentViewModel>;

    /**
     * Upload and extract information for verification
     * @param stpdId (optional) The service id
     * @param projectId (optional) The project id
     * @param masterId (optional) 
     * @param comment (optional) 
     * @param externalId (optional) 
     * @param result (optional) 
     * @param resultId (optional) 
     * @param resultIndex (optional) 
     * @param guid (optional) 
     * @param x_Api_Version (optional) 
     * @param file (optional) 
     * @return The document
     */
    extractAndVerify(stpdId: number | undefined, projectId: number | undefined, masterId: number | null | undefined, comment: string | null | undefined, externalId: string | null | undefined, result: string | null | undefined, resultId: string | null | undefined, resultIndex: number | null | undefined, guid: string | undefined, x_Api_Version: string | null | undefined, file: FileParameter | null | undefined): Promise<DocumentViewModel>;

    /**
     * Upload get a document classification
     * @param stpdId (optional) The service id
     * @param projectId (optional) The project id
     * @param docId (optional) The document id
     * @param x_Api_Version (optional) 
     * @return The document classification
     */
    getClassification(stpdId: number | undefined, projectId: number | undefined, docId: number | undefined, x_Api_Version: string | null | undefined): Promise<ClassesViewModel>;
}

export class DocumentClient extends AIForgedBase implements IDocumentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get a document by Id
     * @param id (optional) The document id
     * @param x_Api_Version (optional) 
     * @return The document
     */
    getDocument(id: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel> {
        let url_ = this.baseUrl + "/api/Document/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetDocument(_response));
        });
    }

    protected processGetDocument(response: Response): Promise<DocumentViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel>(null as any);
    }

    /**
     * Get a document and its related documents
     * @param id (optional) Document id
     * @param x_Api_Version (optional) 
     * @return Hierarchy of documents
     */
    getHierarchy(id: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel> {
        let url_ = this.baseUrl + "/api/Document/GetHierarchy?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetHierarchy(_response));
        });
    }

    protected processGetHierarchy(response: Response): Promise<DocumentViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel>(null as any);
    }

    /**
     * Update a document
     * @param x_Api_Version (optional) 
     * @param document The document to update
     * @return The updated document
     */
    update(x_Api_Version: string | null | undefined, document: DocumentViewModel): Promise<DocumentViewModel> {
        let url_ = this.baseUrl + "/api/Document/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(document);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<DocumentViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel>(null as any);
    }

    /**
     * Delete a document by id
     * @param id (optional) Document id to delete
     * @param x_Api_Version (optional) 
     * @return The deleted document
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel> {
        let url_ = this.baseUrl + "/api/Document/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<DocumentViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel>(null as any);
    }

    /**
     * Delete multiple documents
     * @param ids (optional) The document Ids to delete
     * @param x_Api_Version (optional) 
     */
    deleteMulti(ids: number[] | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/DeleteMulti?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteMulti(_response));
        });
    }

    protected processDeleteMulti(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * UnDelete a document by id
     * @param id (optional) Document id to undelete
     * @param newstatus (optional) The new status after undelete
     * @param usagefilter (optional) Only update documents for a specific usage
     * @param recursive (optional) Recursively undelete
     * @param x_Api_Version (optional) 
     * @return The master undeleted document
     */
    unDelete(id: number | undefined, newstatus: DocumentStatus | undefined, usagefilter: UsageType | null | undefined, recursive: boolean | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel> {
        let url_ = this.baseUrl + "/api/Document/UnDelete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (newstatus === null)
            throw new Error("The parameter 'newstatus' cannot be null.");
        else if (newstatus !== undefined)
            url_ += "newstatus=" + encodeURIComponent("" + newstatus) + "&";
        if (usagefilter !== undefined && usagefilter !== null)
            url_ += "usagefilter=" + encodeURIComponent("" + usagefilter) + "&";
        if (recursive === null)
            throw new Error("The parameter 'recursive' cannot be null.");
        else if (recursive !== undefined)
            url_ += "recursive=" + encodeURIComponent("" + recursive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUnDelete(_response));
        });
    }

    protected processUnDelete(response: Response): Promise<DocumentViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel>(null as any);
    }

    /**
     * Copy a document to another project/service and supply a new status and usage
     * @param projectId (optional) Destination project
     * @param stpdId (optional) Destination service
     * @param status (optional) New status
     * @param usage (optional) New usage
     * @param includeAllData (optional) Include all image date
     * @param docIds (optional) List of socument Ids to copy
     * @param x_Api_Version (optional) 
     */
    copy(projectId: number | undefined, stpdId: number | undefined, status: DocumentStatus | undefined, usage: UsageType | undefined, includeAllData: boolean | undefined, docIds: number[] | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/Copy?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (usage === null)
            throw new Error("The parameter 'usage' cannot be null.");
        else if (usage !== undefined)
            url_ += "usage=" + encodeURIComponent("" + usage) + "&";
        if (includeAllData === null)
            throw new Error("The parameter 'includeAllData' cannot be null.");
        else if (includeAllData !== undefined)
            url_ += "includeAllData=" + encodeURIComponent("" + includeAllData) + "&";
        if (docIds !== undefined && docIds !== null)
            docIds && docIds.forEach(item => { url_ += "docIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCopy(_response));
        });
    }

    protected processCopy(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * Move a document to another project and service
     * @param projectId (optional) The project id
     * @param toStpdId (optional) 
     * @param toStatus (optional) 
     * @param toUsage (optional) 
     * @param docIds (optional) 
     * @param x_Api_Version (optional) 
     */
    move(projectId: number | undefined, toStpdId: number | undefined, toStatus: DocumentStatus | undefined, toUsage: UsageType | undefined, docIds: number[] | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/Move?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (toStpdId === null)
            throw new Error("The parameter 'toStpdId' cannot be null.");
        else if (toStpdId !== undefined)
            url_ += "toStpdId=" + encodeURIComponent("" + toStpdId) + "&";
        if (toStatus === null)
            throw new Error("The parameter 'toStatus' cannot be null.");
        else if (toStatus !== undefined)
            url_ += "toStatus=" + encodeURIComponent("" + toStatus) + "&";
        if (toUsage === null)
            throw new Error("The parameter 'toUsage' cannot be null.");
        else if (toUsage !== undefined)
            url_ += "toUsage=" + encodeURIComponent("" + toUsage) + "&";
        if (docIds !== undefined && docIds !== null)
            docIds && docIds.forEach(item => { url_ += "docIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMove(_response));
        });
    }

    protected processMove(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * Bulk Copy document by status and usage to another service
     * @param projectFromId (optional) 
     * @param stpdIdFrom (optional) 
     * @param statusFrom (optional) 
     * @param usageFrom (optional) 
     * @param projectToId (optional) 
     * @param stpdIdTo (optional) 
     * @param statusTo (optional) 
     * @param usageTo (optional) 
     * @param includeAllData (optional) 
     * @param x_Api_Version (optional) 
     */
    bulkCopy(projectFromId: number | undefined, stpdIdFrom: number | undefined, statusFrom: DocumentStatus | undefined, usageFrom: UsageType | undefined, projectToId: number | undefined, stpdIdTo: number | undefined, statusTo: DocumentStatus | undefined, usageTo: UsageType | undefined, includeAllData: boolean | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Document/BulkCopy?";
        if (projectFromId === null)
            throw new Error("The parameter 'projectFromId' cannot be null.");
        else if (projectFromId !== undefined)
            url_ += "projectFromId=" + encodeURIComponent("" + projectFromId) + "&";
        if (stpdIdFrom === null)
            throw new Error("The parameter 'stpdIdFrom' cannot be null.");
        else if (stpdIdFrom !== undefined)
            url_ += "stpdIdFrom=" + encodeURIComponent("" + stpdIdFrom) + "&";
        if (statusFrom === null)
            throw new Error("The parameter 'statusFrom' cannot be null.");
        else if (statusFrom !== undefined)
            url_ += "statusFrom=" + encodeURIComponent("" + statusFrom) + "&";
        if (usageFrom === null)
            throw new Error("The parameter 'usageFrom' cannot be null.");
        else if (usageFrom !== undefined)
            url_ += "usageFrom=" + encodeURIComponent("" + usageFrom) + "&";
        if (projectToId === null)
            throw new Error("The parameter 'projectToId' cannot be null.");
        else if (projectToId !== undefined)
            url_ += "projectToId=" + encodeURIComponent("" + projectToId) + "&";
        if (stpdIdTo === null)
            throw new Error("The parameter 'stpdIdTo' cannot be null.");
        else if (stpdIdTo !== undefined)
            url_ += "stpdIdTo=" + encodeURIComponent("" + stpdIdTo) + "&";
        if (statusTo === null)
            throw new Error("The parameter 'statusTo' cannot be null.");
        else if (statusTo !== undefined)
            url_ += "statusTo=" + encodeURIComponent("" + statusTo) + "&";
        if (usageTo === null)
            throw new Error("The parameter 'usageTo' cannot be null.");
        else if (usageTo !== undefined)
            url_ += "usageTo=" + encodeURIComponent("" + usageTo) + "&";
        if (includeAllData === null)
            throw new Error("The parameter 'includeAllData' cannot be null.");
        else if (includeAllData !== undefined)
            url_ += "includeAllData=" + encodeURIComponent("" + includeAllData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processBulkCopy(_response));
        });
    }

    protected processBulkCopy(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Bulk update document by status and usage
     * @param projectId (optional) The project id
     * @param stpdIdFrom (optional) 
     * @param statusFrom (optional) 
     * @param usageFrom (optional) 
     * @param statusTo (optional) 
     * @param usageTo (optional) 
     * @param x_Api_Version (optional) 
     */
    bulkUpdate(projectId: number | undefined, stpdIdFrom: number | undefined, statusFrom: DocumentStatus | undefined, usageFrom: UsageType | undefined, statusTo: DocumentStatus | undefined, usageTo: UsageType | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Document/BulkUpdate?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdIdFrom === null)
            throw new Error("The parameter 'stpdIdFrom' cannot be null.");
        else if (stpdIdFrom !== undefined)
            url_ += "stpdIdFrom=" + encodeURIComponent("" + stpdIdFrom) + "&";
        if (statusFrom === null)
            throw new Error("The parameter 'statusFrom' cannot be null.");
        else if (statusFrom !== undefined)
            url_ += "statusFrom=" + encodeURIComponent("" + statusFrom) + "&";
        if (usageFrom === null)
            throw new Error("The parameter 'usageFrom' cannot be null.");
        else if (usageFrom !== undefined)
            url_ += "usageFrom=" + encodeURIComponent("" + usageFrom) + "&";
        if (statusTo === null)
            throw new Error("The parameter 'statusTo' cannot be null.");
        else if (statusTo !== undefined)
            url_ += "statusTo=" + encodeURIComponent("" + statusTo) + "&";
        if (usageTo === null)
            throw new Error("The parameter 'usageTo' cannot be null.");
        else if (usageTo !== undefined)
            url_ += "usageTo=" + encodeURIComponent("" + usageTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processBulkUpdate(_response));
        });
    }

    protected processBulkUpdate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Bulk Mode document by status and usage to another service
     * @param projectFromId (optional) 
     * @param stpdIdFrom (optional) 
     * @param statusFrom (optional) 
     * @param usageFrom (optional) 
     * @param projectToId (optional) 
     * @param stpdIdTo (optional) 
     * @param statusTo (optional) 
     * @param usageTo (optional) 
     * @param x_Api_Version (optional) 
     */
    bulkMove(projectFromId: number | undefined, stpdIdFrom: number | undefined, statusFrom: DocumentStatus | undefined, usageFrom: UsageType | undefined, projectToId: number | undefined, stpdIdTo: number | undefined, statusTo: DocumentStatus | undefined, usageTo: UsageType | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Document/BulkMove?";
        if (projectFromId === null)
            throw new Error("The parameter 'projectFromId' cannot be null.");
        else if (projectFromId !== undefined)
            url_ += "projectFromId=" + encodeURIComponent("" + projectFromId) + "&";
        if (stpdIdFrom === null)
            throw new Error("The parameter 'stpdIdFrom' cannot be null.");
        else if (stpdIdFrom !== undefined)
            url_ += "stpdIdFrom=" + encodeURIComponent("" + stpdIdFrom) + "&";
        if (statusFrom === null)
            throw new Error("The parameter 'statusFrom' cannot be null.");
        else if (statusFrom !== undefined)
            url_ += "statusFrom=" + encodeURIComponent("" + statusFrom) + "&";
        if (usageFrom === null)
            throw new Error("The parameter 'usageFrom' cannot be null.");
        else if (usageFrom !== undefined)
            url_ += "usageFrom=" + encodeURIComponent("" + usageFrom) + "&";
        if (projectToId === null)
            throw new Error("The parameter 'projectToId' cannot be null.");
        else if (projectToId !== undefined)
            url_ += "projectToId=" + encodeURIComponent("" + projectToId) + "&";
        if (stpdIdTo === null)
            throw new Error("The parameter 'stpdIdTo' cannot be null.");
        else if (stpdIdTo !== undefined)
            url_ += "stpdIdTo=" + encodeURIComponent("" + stpdIdTo) + "&";
        if (statusTo === null)
            throw new Error("The parameter 'statusTo' cannot be null.");
        else if (statusTo !== undefined)
            url_ += "statusTo=" + encodeURIComponent("" + statusTo) + "&";
        if (usageTo === null)
            throw new Error("The parameter 'usageTo' cannot be null.");
        else if (usageTo !== undefined)
            url_ += "usageTo=" + encodeURIComponent("" + usageTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processBulkMove(_response));
        });
    }

    protected processBulkMove(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Bulk change document classes by status and usage
     * @param projectId (optional) The project id
     * @param stpdIdFrom (optional) 
     * @param statusFrom (optional) 
     * @param usageFrom (optional) 
     * @param fromClassId (optional) 
     * @param toClassId (optional) 
     * @param x_Api_Version (optional) 
     */
    bulkClassChange(projectId: number | undefined, stpdIdFrom: number | undefined, statusFrom: DocumentStatus | undefined, usageFrom: UsageType | undefined, fromClassId: number | null | undefined, toClassId: number | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Document/BulkClassChange?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdIdFrom === null)
            throw new Error("The parameter 'stpdIdFrom' cannot be null.");
        else if (stpdIdFrom !== undefined)
            url_ += "stpdIdFrom=" + encodeURIComponent("" + stpdIdFrom) + "&";
        if (statusFrom === null)
            throw new Error("The parameter 'statusFrom' cannot be null.");
        else if (statusFrom !== undefined)
            url_ += "statusFrom=" + encodeURIComponent("" + statusFrom) + "&";
        if (usageFrom === null)
            throw new Error("The parameter 'usageFrom' cannot be null.");
        else if (usageFrom !== undefined)
            url_ += "usageFrom=" + encodeURIComponent("" + usageFrom) + "&";
        if (fromClassId !== undefined && fromClassId !== null)
            url_ += "fromClassId=" + encodeURIComponent("" + fromClassId) + "&";
        if (toClassId === null)
            throw new Error("The parameter 'toClassId' cannot be null.");
        else if (toClassId !== undefined)
            url_ += "toClassId=" + encodeURIComponent("" + toClassId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processBulkClassChange(_response));
        });
    }

    protected processBulkClassChange(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Find latest child document to assist with verification
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param usage (optional) 
     * @param statuses (optional) 
     * @param filename (optional) 
     * @param classname (optional) 
     * @param masterid (optional) 
     * @param x_Api_Version (optional) 
     */
    findLatestChild(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, usage: UsageType | undefined, statuses: DocumentStatus[] | null | undefined, filename: string | null | undefined, classname: string | null | undefined, masterid: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/FindLatestChild?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (usage === null)
            throw new Error("The parameter 'usage' cannot be null.");
        else if (usage !== undefined)
            url_ += "usage=" + encodeURIComponent("" + usage) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        if (classname !== undefined && classname !== null)
            url_ += "classname=" + encodeURIComponent("" + classname) + "&";
        if (masterid === null)
            throw new Error("The parameter 'masterid' cannot be null.");
        else if (masterid !== undefined)
            url_ += "masterid=" + encodeURIComponent("" + masterid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processFindLatestChild(_response));
        });
    }

    protected processFindLatestChild(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * Get preview documents and images for a service
     * @param userId (optional) The user that owns the service
     * @param projectId (optional) The project id
     * @param stpdId (optional) The service id
     * @param x_Api_Version (optional) 
     * @return The preview document
     */
    getPreviews(userId: string | null | undefined, projectId: number | undefined, stpdId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/GetPreviews?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId !== undefined && stpdId !== null)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPreviews(_response));
        });
    }

    protected processGetPreviews(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * Find documnets by using structured search criteria.  The results can be paged
     * @param userId (optional) Owner of the document
     * @param projectId (optional) The project Id
     * @param stpdId (optional) The service id
     * @param usage (optional) The folder or usage
     * @param statuses (optional) List of statuses
     * @param classname (optional) A class name fileter
     * @param filename (optional) Filename filter
     * @param filetype (optional) File type filter
     * @param start (optional) Start date range for documents
     * @param end (optional) End date range for documents
     * @param masterid (optional) Master or parent of the document
     * @param includeparamdefcategories (optional) include gategories
     * @param pageNo (optional) Page number
     * @param pageSize (optional) Size of a page
     * @param sortField (optional) Sort by field
     * @param sortDirection (optional) Sort direction based on the sortfield
     * @param comment (optional) Filter for comments
     * @param result (optional) Filter for results
     * @param resultId (optional) Filter for a result id
     * @param resultIndex (optional) Filter for result index
     * @param externalId (optional) Filter for external ids
     * @param docGuid (optional) Filter for doc guids
     * @param x_Api_Version (optional) 
     */
    getExtended(userId: string | null | undefined, projectId: number | undefined, stpdId: number | null | undefined, usage: UsageType | null | undefined, statuses: DocumentStatus[] | null | undefined, classname: string | null | undefined, filename: string | null | undefined, filetype: string | null | undefined, start: Date | null | undefined, end: Date | null | undefined, masterid: number | null | undefined, includeparamdefcategories: (ParameterDefinitionCategory | undefined)[] | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, comment: string | null | undefined, result: string | null | undefined, resultId: string | null | undefined, resultIndex: number | null | undefined, externalId: string | null | undefined, docGuid: string | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/GetExtended?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId !== undefined && stpdId !== null)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (usage !== undefined && usage !== null)
            url_ += "usage=" + encodeURIComponent("" + usage) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (classname !== undefined && classname !== null)
            url_ += "classname=" + encodeURIComponent("" + classname) + "&";
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        if (filetype !== undefined && filetype !== null)
            url_ += "filetype=" + encodeURIComponent("" + filetype) + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toISOString() : "") + "&";
        if (end !== undefined && end !== null)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toISOString() : "") + "&";
        if (masterid !== undefined && masterid !== null)
            url_ += "masterid=" + encodeURIComponent("" + masterid) + "&";
        if (includeparamdefcategories !== undefined && includeparamdefcategories !== null)
            includeparamdefcategories && includeparamdefcategories.forEach(item => { url_ += "includeparamdefcategories=" + encodeURIComponent("" + item) + "&"; });
        if (pageNo !== undefined && pageNo !== null)
            url_ += "pageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (result !== undefined && result !== null)
            url_ += "result=" + encodeURIComponent("" + result) + "&";
        if (resultId !== undefined && resultId !== null)
            url_ += "resultId=" + encodeURIComponent("" + resultId) + "&";
        if (resultIndex !== undefined && resultIndex !== null)
            url_ += "resultIndex=" + encodeURIComponent("" + resultIndex) + "&";
        if (externalId !== undefined && externalId !== null)
            url_ += "externalId=" + encodeURIComponent("" + externalId) + "&";
        if (docGuid !== undefined && docGuid !== null)
            url_ += "docGuid=" + encodeURIComponent("" + docGuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetExtended(_response));
        });
    }

    protected processGetExtended(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * Find documnets count by using structured search criteria
    This is used to detemine paging
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param usage (optional) 
     * @param statuses (optional) 
     * @param classname (optional) 
     * @param filename (optional) 
     * @param filetype (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @param masterid (optional) 
     * @param comment (optional) 
     * @param result (optional) 
     * @param resultId (optional) 
     * @param resultIndex (optional) 
     * @param externalId (optional) 
     * @param docGuid (optional) 
     * @param x_Api_Version (optional) 
     */
    getExtendedCount(userId: string | null | undefined, projectId: number | null | undefined, stpdId: number | null | undefined, usage: UsageType | null | undefined, statuses: DocumentStatus[] | null | undefined, classname: string | null | undefined, filename: string | null | undefined, filetype: string | null | undefined, start: Date | null | undefined, end: Date | null | undefined, masterid: number | null | undefined, comment: string | null | undefined, result: string | null | undefined, resultId: string | null | undefined, resultIndex: number | null | undefined, externalId: string | null | undefined, docGuid: string | null | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Document/GetExtendedCount?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId !== undefined && stpdId !== null)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (usage !== undefined && usage !== null)
            url_ += "usage=" + encodeURIComponent("" + usage) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (classname !== undefined && classname !== null)
            url_ += "classname=" + encodeURIComponent("" + classname) + "&";
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        if (filetype !== undefined && filetype !== null)
            url_ += "filetype=" + encodeURIComponent("" + filetype) + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toISOString() : "") + "&";
        if (end !== undefined && end !== null)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toISOString() : "") + "&";
        if (masterid !== undefined && masterid !== null)
            url_ += "masterid=" + encodeURIComponent("" + masterid) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (result !== undefined && result !== null)
            url_ += "result=" + encodeURIComponent("" + result) + "&";
        if (resultId !== undefined && resultId !== null)
            url_ += "resultId=" + encodeURIComponent("" + resultId) + "&";
        if (resultIndex !== undefined && resultIndex !== null)
            url_ += "resultIndex=" + encodeURIComponent("" + resultIndex) + "&";
        if (externalId !== undefined && externalId !== null)
            url_ += "externalId=" + encodeURIComponent("" + externalId) + "&";
        if (docGuid !== undefined && docGuid !== null)
            url_ += "docGuid=" + encodeURIComponent("" + docGuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetExtendedCount(_response));
        });
    }

    protected processGetExtendedCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get a summary of documents for analytics
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param usage (optional) 
     * @param statuses (optional) 
     * @param classname (optional) 
     * @param masterid (optional) 
     * @param interval (optional) 
     * @param getLabelledStats (optional) 
     * @param x_Api_Version (optional) 
     */
    getExSummary(userId: string | null | undefined, projectId: number | null | undefined, stpdId: number | null | undefined, usage: UsageType | null | undefined, statuses: DocumentStatus[] | null | undefined, classname: string | null | undefined, masterid: number | null | undefined, interval: string | null | undefined, getLabelledStats: boolean | undefined, x_Api_Version: string | null | undefined): Promise<DocumentsSummary[]> {
        let url_ = this.baseUrl + "/api/Document/GetExtendedSummary?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId !== undefined && stpdId !== null)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (usage !== undefined && usage !== null)
            url_ += "usage=" + encodeURIComponent("" + usage) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (classname !== undefined && classname !== null)
            url_ += "classname=" + encodeURIComponent("" + classname) + "&";
        if (masterid !== undefined && masterid !== null)
            url_ += "masterid=" + encodeURIComponent("" + masterid) + "&";
        if (interval !== undefined && interval !== null)
            url_ += "interval=" + encodeURIComponent("" + interval) + "&";
        if (getLabelledStats === null)
            throw new Error("The parameter 'getLabelledStats' cannot be null.");
        else if (getLabelledStats !== undefined)
            url_ += "getLabelledStats=" + encodeURIComponent("" + getLabelledStats) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetExSummary(_response));
        });
    }

    protected processGetExSummary(response: Response): Promise<DocumentsSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentsSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentsSummary[]>(null as any);
    }

    /**
     * Get document images
     * @param id (optional) The document id
     * @param stpdId (optional) Service id
     * @param x_Api_Version (optional) 
     * @return List of document images
     */
    getImages(id: number | undefined, stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentDataViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/GetImages?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetImages(_response));
        });
    }

    protected processGetImages(response: Response): Promise<DocumentDataViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentDataViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentDataViewModel[]>(null as any);
    }

    /**
     * Get document images
     * @param id (optional) 
     * @param types (optional) 
     * @param contentType (optional) 
     * @param text (optional) 
     * @param blobid (optional) 
     * @param pageindex (optional) 
     * @param imagesCount (optional) 
     * @param x_Api_Version (optional) 
     */
    getData(id: number | undefined, types: (DocumentDataType | undefined)[] | null | undefined, contentType: string | null | undefined, text: string | null | undefined, blobid: number | null | undefined, pageindex: number | null | undefined, imagesCount: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentDataViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/GetData?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (types !== undefined && types !== null)
            types && types.forEach(item => { url_ += "types=" + encodeURIComponent("" + item) + "&"; });
        if (contentType !== undefined && contentType !== null)
            url_ += "contentType=" + encodeURIComponent("" + contentType) + "&";
        if (text !== undefined && text !== null)
            url_ += "text=" + encodeURIComponent("" + text) + "&";
        if (blobid !== undefined && blobid !== null)
            url_ += "blobid=" + encodeURIComponent("" + blobid) + "&";
        if (pageindex !== undefined && pageindex !== null)
            url_ += "pageindex=" + encodeURIComponent("" + pageindex) + "&";
        if (imagesCount !== undefined && imagesCount !== null)
            url_ += "imagesCount=" + encodeURIComponent("" + imagesCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetData(_response));
        });
    }

    protected processGetData(response: Response): Promise<DocumentDataViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentDataViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentDataViewModel[]>(null as any);
    }

    /**
     * Get system document
     * @param filename (optional) 
     * @param x_Api_Version (optional) 
     */
    getSystemDocument(filename: string | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentDataViewModel> {
        let url_ = this.baseUrl + "/api/Document/GetSystemDocument?";
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetSystemDocument(_response));
        });
    }

    protected processGetSystemDocument(response: Response): Promise<DocumentDataViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentDataViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentDataViewModel>(null as any);
    }

    /**
     * Get system documents
     * @param pattern (optional) Filename pattern
     * @param filetype (optional) Optional: File type / extention
     * @param contenttype (optional) Optional: Content type
     * @param statuses (optional) Optional: statuses
     * @param masterId (optional) Optional: master id
     * @param x_Api_Version (optional) 
     */
    getSystemDocuments(pattern: string | null | undefined, filetype: string | null | undefined, contenttype: string | null | undefined, statuses: DocumentStatus[] | null | undefined, masterId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentDataViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/GetSystemDocuments?";
        if (pattern !== undefined && pattern !== null)
            url_ += "pattern=" + encodeURIComponent("" + pattern) + "&";
        if (filetype !== undefined && filetype !== null)
            url_ += "filetype=" + encodeURIComponent("" + filetype) + "&";
        if (contenttype !== undefined && contenttype !== null)
            url_ += "contenttype=" + encodeURIComponent("" + contenttype) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (masterId !== undefined && masterId !== null)
            url_ += "masterId=" + encodeURIComponent("" + masterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetSystemDocuments(_response));
        });
    }

    protected processGetSystemDocuments(response: Response): Promise<DocumentDataViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentDataViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentDataViewModel[]>(null as any);
    }

    getBlob(userId: string | null | undefined, id: number | undefined, types: (DocumentDataType | undefined)[] | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Document/GetBlob?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (types !== undefined && types !== null)
            types && types.forEach(item => { url_ += "types=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetBlob(_response));
        });
    }

    protected processGetBlob(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get blob by blob key
     * @param id (optional) The blob id
     * @param x_Api_Version (optional) 
     * @return The blob
     */
    getBlobById(id: number | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Document/GetBlobById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetBlobById(_response));
        });
    }

    protected processGetBlobById(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Update a blob
     * @param userId (optional) Owner user id
     * @param x_Api_Version (optional) 
     * @param data The blob data to update
     * @return The result
     */
    updateBlob(userId: string | null | undefined, x_Api_Version: string | null | undefined, data: DocumentDataViewModel): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Document/UpdateBlob?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateBlob(_response));
        });
    }

    protected processUpdateBlob(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Delete a document blob
     * @param id (optional) The blob id
     * @param x_Api_Version (optional) 
     * @return The result
     */
    deleteBlob(id: number | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Document/DeleteBlob?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteBlob(_response));
        });
    }

    protected processDeleteBlob(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Delete pages from a document
     * @param id (optional) The document id
     * @param childUsage (optional) 
     * @param childStatus (optional) 
     * @param childDeleteOptions (optional) 
     * @param x_Api_Version (optional) 
     * @return The result
     */
    deletePages(id: number | undefined, childUsage: UsageType | undefined, childStatus: DocumentStatus | undefined, childDeleteOptions: OperationOption | undefined, x_Api_Version: string | null | undefined, pageIndexes: number[]): Promise<DocumentDataViewModel> {
        let url_ = this.baseUrl + "/api/Document/DeletePages?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (childUsage === null)
            throw new Error("The parameter 'childUsage' cannot be null.");
        else if (childUsage !== undefined)
            url_ += "childUsage=" + encodeURIComponent("" + childUsage) + "&";
        if (childStatus === null)
            throw new Error("The parameter 'childStatus' cannot be null.");
        else if (childStatus !== undefined)
            url_ += "childStatus=" + encodeURIComponent("" + childStatus) + "&";
        if (childDeleteOptions === null)
            throw new Error("The parameter 'childDeleteOptions' cannot be null.");
        else if (childDeleteOptions !== undefined)
            url_ += "childDeleteOptions=" + encodeURIComponent("" + childDeleteOptions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageIndexes);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeletePages(_response));
        });
    }

    protected processDeletePages(response: Response): Promise<DocumentDataViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentDataViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentDataViewModel>(null as any);
    }

    /**
     * Change parameters and training to another page
     * @param id (optional) The document id
     * @param pageIndex (optional) 
     * @param x_Api_Version (optional) 
     * @return The result
     */
    deleteFieldsOnPage(id: number | undefined, pageIndex: number | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Document/DeleteFieldsOnPage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteFieldsOnPage(_response));
        });
    }

    protected processDeleteFieldsOnPage(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Change parameters and training to another page
     * @param id (optional) The document id
     * @param fromPageIndex (optional) 
     * @param toPageIndex (optional) 
     * @param x_Api_Version (optional) 
     * @return The result
     */
    changeFieldPageIndex(id: number | undefined, fromPageIndex: number | undefined, toPageIndex: number | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Document/ChangeFieldPageIndex?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (fromPageIndex === null)
            throw new Error("The parameter 'fromPageIndex' cannot be null.");
        else if (fromPageIndex !== undefined)
            url_ += "fromPageIndex=" + encodeURIComponent("" + fromPageIndex) + "&";
        if (toPageIndex === null)
            throw new Error("The parameter 'toPageIndex' cannot be null.");
        else if (toPageIndex !== undefined)
            url_ += "toPageIndex=" + encodeURIComponent("" + toPageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processChangeFieldPageIndex(_response));
        });
    }

    protected processChangeFieldPageIndex(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Change parameters and training to another page
     * @param id (optional) The document id
     * @param fromPageIndex (optional) 
     * @param toPageIndex (optional) 
     * @param x_Api_Version (optional) 
     * @return The result
     */
    setFieldPageVerificationIndex(id: number | undefined, fromPageIndex: number | undefined, toPageIndex: number | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Document/SetFieldPageVerificationIndex?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (fromPageIndex === null)
            throw new Error("The parameter 'fromPageIndex' cannot be null.");
        else if (fromPageIndex !== undefined)
            url_ += "fromPageIndex=" + encodeURIComponent("" + fromPageIndex) + "&";
        if (toPageIndex === null)
            throw new Error("The parameter 'toPageIndex' cannot be null.");
        else if (toPageIndex !== undefined)
            url_ += "toPageIndex=" + encodeURIComponent("" + toPageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSetFieldPageVerificationIndex(_response));
        });
    }

    protected processSetFieldPageVerificationIndex(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get Training Report
     * @param id (optional) The document id
     * @param x_Api_Version (optional) 
     * @return The result
     */
    getTrainingReport(id: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/GetTrainingReport?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetTrainingReport(_response));
        });
    }

    protected processGetTrainingReport(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * Fix page parameter index
     * @param id (optional) The document id
     * @param x_Api_Version (optional) 
     * @return The result
     */
    fixPageVerificationIndex(id: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/FixPageVerificationIndex?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processFixPageVerificationIndex(_response));
        });
    }

    protected processFixPageVerificationIndex(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * Upload a document
     * @param stpdId (optional) Service id
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param classId (optional) 
     * @param status (optional) 
     * @param usage (optional) 
     * @param masterid (optional) 
     * @param comment (optional) 
     * @param externalId (optional) 
     * @param result (optional) 
     * @param resultId (optional) 
     * @param resultIndex (optional) 
     * @param guid (optional) 
     * @param x_Api_Version (optional) 
     * @param data (optional) 
     */
    upload(stpdId: number | undefined, userId: string | null | undefined, projectId: number | undefined, classId: number | null | undefined, status: DocumentStatus | undefined, usage: UsageType | undefined, masterid: number | null | undefined, comment: string | null | undefined, externalId: string | null | undefined, result: string | null | undefined, resultId: string | null | undefined, resultIndex: number | null | undefined, guid: string | undefined, x_Api_Version: string | null | undefined, data: any[] | null | undefined): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/Upload?";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (classId !== undefined && classId !== null)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (usage === null)
            throw new Error("The parameter 'usage' cannot be null.");
        else if (usage !== undefined)
            url_ += "usage=" + encodeURIComponent("" + usage) + "&";
        if (masterid !== undefined && masterid !== null)
            url_ += "masterid=" + encodeURIComponent("" + masterid) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (externalId !== undefined && externalId !== null)
            url_ += "externalId=" + encodeURIComponent("" + externalId) + "&";
        if (result !== undefined && result !== null)
            url_ += "result=" + encodeURIComponent("" + result) + "&";
        if (resultId !== undefined && resultId !== null)
            url_ += "resultId=" + encodeURIComponent("" + resultId) + "&";
        if (resultIndex !== undefined && resultIndex !== null)
            url_ += "resultIndex=" + encodeURIComponent("" + resultIndex) + "&";
        if (guid === null)
            throw new Error("The parameter 'guid' cannot be null.");
        else if (guid !== undefined)
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (data !== null && data !== undefined)
            data.forEach(item_ => content_.append("data", item_.toString()));

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpload(_response));
        });
    }

    protected processUpload(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * Store structured doument and containing data blob
     * @param stpdId (optional) Service id
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param masterid (optional) 
     * @param x_Api_Version (optional) 
     */
    store(stpdId: number | undefined, userId: string | null | undefined, projectId: number | undefined, masterid: number | null | undefined, x_Api_Version: string | null | undefined, docs: DocumentViewModel[]): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Document/Store?";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (masterid !== undefined && masterid !== null)
            url_ += "masterid=" + encodeURIComponent("" + masterid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(docs);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processStore(_response));
        });
    }

    protected processStore(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * Upload and classify a document
     * @param stpdId (optional) The service id
     * @param projectId (optional) Project id
     * @param masterId (optional) 
     * @param comment (optional) 
     * @param externalId (optional) 
     * @param result (optional) 
     * @param resultId (optional) 
     * @param resultIndex (optional) 
     * @param guid (optional) 
     * @param x_Api_Version (optional) 
     * @param file (optional) 
     * @return The document
     */
    classify(stpdId: number | undefined, projectId: number | undefined, masterId: number | null | undefined, comment: string | null | undefined, externalId: string | null | undefined, result: string | null | undefined, resultId: string | null | undefined, resultIndex: number | null | undefined, guid: string | undefined, x_Api_Version: string | null | undefined, file: FileParameter | null | undefined): Promise<DocumentViewModel> {
        let url_ = this.baseUrl + "/api/Document/Classify?";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (masterId !== undefined && masterId !== null)
            url_ += "masterId=" + encodeURIComponent("" + masterId) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (externalId !== undefined && externalId !== null)
            url_ += "externalId=" + encodeURIComponent("" + externalId) + "&";
        if (result !== undefined && result !== null)
            url_ += "result=" + encodeURIComponent("" + result) + "&";
        if (resultId !== undefined && resultId !== null)
            url_ += "resultId=" + encodeURIComponent("" + resultId) + "&";
        if (resultIndex !== undefined && resultIndex !== null)
            url_ += "resultIndex=" + encodeURIComponent("" + resultIndex) + "&";
        if (guid === null)
            throw new Error("The parameter 'guid' cannot be null.");
        else if (guid !== undefined)
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processClassify(_response));
        });
    }

    protected processClassify(response: Response): Promise<DocumentViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel>(null as any);
    }

    /**
     * Upload and extract information for verification
     * @param stpdId (optional) The service id
     * @param projectId (optional) The project id
     * @param masterId (optional) 
     * @param comment (optional) 
     * @param externalId (optional) 
     * @param result (optional) 
     * @param resultId (optional) 
     * @param resultIndex (optional) 
     * @param guid (optional) 
     * @param x_Api_Version (optional) 
     * @param file (optional) 
     * @return The document
     */
    extractAndVerify(stpdId: number | undefined, projectId: number | undefined, masterId: number | null | undefined, comment: string | null | undefined, externalId: string | null | undefined, result: string | null | undefined, resultId: string | null | undefined, resultIndex: number | null | undefined, guid: string | undefined, x_Api_Version: string | null | undefined, file: FileParameter | null | undefined): Promise<DocumentViewModel> {
        let url_ = this.baseUrl + "/api/Document/ExtractAndVerify?";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (masterId !== undefined && masterId !== null)
            url_ += "masterId=" + encodeURIComponent("" + masterId) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (externalId !== undefined && externalId !== null)
            url_ += "externalId=" + encodeURIComponent("" + externalId) + "&";
        if (result !== undefined && result !== null)
            url_ += "result=" + encodeURIComponent("" + result) + "&";
        if (resultId !== undefined && resultId !== null)
            url_ += "resultId=" + encodeURIComponent("" + resultId) + "&";
        if (resultIndex !== undefined && resultIndex !== null)
            url_ += "resultIndex=" + encodeURIComponent("" + resultIndex) + "&";
        if (guid === null)
            throw new Error("The parameter 'guid' cannot be null.");
        else if (guid !== undefined)
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processExtractAndVerify(_response));
        });
    }

    protected processExtractAndVerify(response: Response): Promise<DocumentViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel>(null as any);
    }

    /**
     * Upload get a document classification
     * @param stpdId (optional) The service id
     * @param projectId (optional) The project id
     * @param docId (optional) The document id
     * @param x_Api_Version (optional) 
     * @return The document classification
     */
    getClassification(stpdId: number | undefined, projectId: number | undefined, docId: number | undefined, x_Api_Version: string | null | undefined): Promise<ClassesViewModel> {
        let url_ = this.baseUrl + "/api/Document/GetClassification?";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetClassification(_response));
        });
    }

    protected processGetClassification(response: Response): Promise<ClassesViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClassesViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClassesViewModel>(null as any);
    }
}

export interface ILogClient {

    /**
     * Get Log info by Id
     * @param id (optional) Log record id
     * @param x_Api_Version (optional) 
     */
    get(id: number | undefined, x_Api_Version: string | null | undefined): Promise<LogViewModel>;

    /**
     * Get logs by search criteria
     * @param projectId (optional) Project id
     * @param serviceId (optional) Service id
     * @param documentId (optional) Document id
     * @param defId (optional) Definition / rule id
     * @param parameterId (optional) Parameter id
     * @param verId (optional) Verification id
     * @param workitemId (optional) Workitem id
     * @param userId (optional) User id
     * @param x_Api_Version (optional) 
     */
    getAll(projectId: number | undefined, serviceId: number | null | undefined, documentId: number | null | undefined, defId: number | null | undefined, parameterId: number | null | undefined, verId: number | null | undefined, workitemId: number | null | undefined, userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<LogViewModel[]>;
}

export class LogClient extends AIForgedBase implements ILogClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get Log info by Id
     * @param id (optional) Log record id
     * @param x_Api_Version (optional) 
     */
    get(id: number | undefined, x_Api_Version: string | null | undefined): Promise<LogViewModel> {
        let url_ = this.baseUrl + "/api/Log?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<LogViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogViewModel>(null as any);
    }

    /**
     * Get logs by search criteria
     * @param projectId (optional) Project id
     * @param serviceId (optional) Service id
     * @param documentId (optional) Document id
     * @param defId (optional) Definition / rule id
     * @param parameterId (optional) Parameter id
     * @param verId (optional) Verification id
     * @param workitemId (optional) Workitem id
     * @param userId (optional) User id
     * @param x_Api_Version (optional) 
     */
    getAll(projectId: number | undefined, serviceId: number | null | undefined, documentId: number | null | undefined, defId: number | null | undefined, parameterId: number | null | undefined, verId: number | null | undefined, workitemId: number | null | undefined, userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<LogViewModel[]> {
        let url_ = this.baseUrl + "/api/Log/GetAll?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (serviceId !== undefined && serviceId !== null)
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&";
        if (documentId !== undefined && documentId !== null)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&";
        if (defId !== undefined && defId !== null)
            url_ += "defId=" + encodeURIComponent("" + defId) + "&";
        if (parameterId !== undefined && parameterId !== null)
            url_ += "parameterId=" + encodeURIComponent("" + parameterId) + "&";
        if (verId !== undefined && verId !== null)
            url_ += "verId=" + encodeURIComponent("" + verId) + "&";
        if (workitemId !== undefined && workitemId !== null)
            url_ += "workitemId=" + encodeURIComponent("" + workitemId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<LogViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LogViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogViewModel[]>(null as any);
    }
}

export interface IMarketPlaceClient {

    /**
     * Get marketplace items by using a filter
     * @param filter (optional) 
     * @param x_Api_Version (optional) 
     */
    get(filter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]>;

    /**
     * Get by user
     * @param userId (optional) The user id
     * @param groupId (optional) 
     * @param x_Api_Version (optional) 
     */
    getByUser(userId: string | null | undefined, groupId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]>;

    /**
     * Request access to market place
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param serviceId (optional) 
     * @param x_Api_Version (optional) 
     */
    requestAccess(userId: string | null | undefined, projectId: number | undefined, serviceId: number | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]>;

    /**
     * Approve a user request
     * @param reqId (optional) 
     * @param status (optional) 
     * @param x_Api_Version (optional) 
     */
    approveRequest(reqId: number | undefined, status: ProjectUserStatus | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel>;

    /**
     * Link / Shared users to project service group
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param serviceId (optional) 
     * @param groupId (optional) 
     * @param type (optional) 
     * @param otherUserIds (optional) 
     * @param role (optional) 
     * @param permission (optional) 
     * @param x_Api_Version (optional) 
     */
    linkUsers(userId: string | null | undefined, projectId: number | undefined, serviceId: number | undefined, groupId: number | null | undefined, type: LinkType | undefined, otherUserIds: string[] | null | undefined, role: string | null | undefined, permission: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]>;

    /**
     * Unlink users from a service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param serviceId (optional) 
     * @param linkIds (optional) 
     * @param x_Api_Version (optional) 
     */
    unLinkUsers(userId: string | null | undefined, projectId: number | undefined, serviceId: number | undefined, linkIds: number[] | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]>;

    /**
     * Get users of a marketplace service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param serviceId (optional) 
     * @param groupId (optional) 
     * @param x_Api_Version (optional) 
     */
    getUsers(userId: string | null | undefined, projectId: number | null | undefined, serviceId: number | null | undefined, groupId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]>;

    getProjectUsers(projectId: number | undefined, role: string | null | undefined, type: LinkType | null | undefined, groupId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]>;

    /**
     * Get service rating
     * @param stpdId (optional) Service id
     * @param x_Api_Version (optional) 
     */
    getRatings(stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<RatingViewModel[]>;

    /**
     * Get service rating
     * @param stpdId (optional) Service id
     * @param x_Api_Version (optional) 
     */
    getRating(stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<number | null>;

    /**
     * Rate a service
     * @param stpdId (optional) Service id
     * @param rating (optional) 
     * @param comment (optional) 
     * @param x_Api_Version (optional) 
     */
    rate(stpdId: number | undefined, rating: number | undefined, comment: string | null | undefined, x_Api_Version: string | null | undefined): Promise<RatingViewModel>;

    /**
     * Invite a user to a service
     * @param x_Api_Version (optional) 
     */
    invite(x_Api_Version: string | null | undefined, invite: UserInviteViewModel): Promise<boolean>;
}

export class MarketPlaceClient extends AIForgedBase implements IMarketPlaceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get marketplace items by using a filter
     * @param filter (optional) 
     * @param x_Api_Version (optional) 
     */
    get(filter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]> {
        let url_ = this.baseUrl + "/api/MarketPlace/Get?";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<ParameterDefViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParameterDefViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel[]>(null as any);
    }

    /**
     * Get by user
     * @param userId (optional) The user id
     * @param groupId (optional) 
     * @param x_Api_Version (optional) 
     */
    getByUser(userId: string | null | undefined, groupId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]> {
        let url_ = this.baseUrl + "/api/MarketPlace/GetByUser?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetByUser(_response));
        });
    }

    protected processGetByUser(response: Response): Promise<ProjectUserViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectUserViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserViewModel[]>(null as any);
    }

    /**
     * Request access to market place
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param serviceId (optional) 
     * @param x_Api_Version (optional) 
     */
    requestAccess(userId: string | null | undefined, projectId: number | undefined, serviceId: number | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]> {
        let url_ = this.baseUrl + "/api/MarketPlace/RequestAccess?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (serviceId === null)
            throw new Error("The parameter 'serviceId' cannot be null.");
        else if (serviceId !== undefined)
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRequestAccess(_response));
        });
    }

    protected processRequestAccess(response: Response): Promise<ProjectUserViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectUserViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserViewModel[]>(null as any);
    }

    /**
     * Approve a user request
     * @param reqId (optional) 
     * @param status (optional) 
     * @param x_Api_Version (optional) 
     */
    approveRequest(reqId: number | undefined, status: ProjectUserStatus | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel> {
        let url_ = this.baseUrl + "/api/MarketPlace/ApproveRequest?";
        if (reqId === null)
            throw new Error("The parameter 'reqId' cannot be null.");
        else if (reqId !== undefined)
            url_ += "reqId=" + encodeURIComponent("" + reqId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processApproveRequest(_response));
        });
    }

    protected processApproveRequest(response: Response): Promise<ProjectUserViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectUserViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserViewModel>(null as any);
    }

    /**
     * Link / Shared users to project service group
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param serviceId (optional) 
     * @param groupId (optional) 
     * @param type (optional) 
     * @param otherUserIds (optional) 
     * @param role (optional) 
     * @param permission (optional) 
     * @param x_Api_Version (optional) 
     */
    linkUsers(userId: string | null | undefined, projectId: number | undefined, serviceId: number | undefined, groupId: number | null | undefined, type: LinkType | undefined, otherUserIds: string[] | null | undefined, role: string | null | undefined, permission: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]> {
        let url_ = this.baseUrl + "/api/MarketPlace/LinkUsers?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (serviceId === null)
            throw new Error("The parameter 'serviceId' cannot be null.");
        else if (serviceId !== undefined)
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (otherUserIds !== undefined && otherUserIds !== null)
            otherUserIds && otherUserIds.forEach(item => { url_ += "otherUserIds=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        if (permission !== undefined && permission !== null)
            url_ += "permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processLinkUsers(_response));
        });
    }

    protected processLinkUsers(response: Response): Promise<ProjectUserViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectUserViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserViewModel[]>(null as any);
    }

    /**
     * Unlink users from a service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param serviceId (optional) 
     * @param linkIds (optional) 
     * @param x_Api_Version (optional) 
     */
    unLinkUsers(userId: string | null | undefined, projectId: number | undefined, serviceId: number | undefined, linkIds: number[] | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]> {
        let url_ = this.baseUrl + "/api/MarketPlace/UnLinkUsers?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (serviceId === null)
            throw new Error("The parameter 'serviceId' cannot be null.");
        else if (serviceId !== undefined)
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&";
        if (linkIds !== undefined && linkIds !== null)
            linkIds && linkIds.forEach(item => { url_ += "LinkIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUnLinkUsers(_response));
        });
    }

    protected processUnLinkUsers(response: Response): Promise<ProjectUserViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectUserViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserViewModel[]>(null as any);
    }

    /**
     * Get users of a marketplace service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param serviceId (optional) 
     * @param groupId (optional) 
     * @param x_Api_Version (optional) 
     */
    getUsers(userId: string | null | undefined, projectId: number | null | undefined, serviceId: number | null | undefined, groupId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]> {
        let url_ = this.baseUrl + "/api/MarketPlace/GetUsers?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (serviceId !== undefined && serviceId !== null)
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetUsers(_response));
        });
    }

    protected processGetUsers(response: Response): Promise<ProjectUserViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectUserViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserViewModel[]>(null as any);
    }

    getProjectUsers(projectId: number | undefined, role: string | null | undefined, type: LinkType | null | undefined, groupId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]> {
        let url_ = this.baseUrl + "/api/MarketPlace/GetProjectUsers?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetProjectUsers(_response));
        });
    }

    protected processGetProjectUsers(response: Response): Promise<ProjectUserViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectUserViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserViewModel[]>(null as any);
    }

    /**
     * Get service rating
     * @param stpdId (optional) Service id
     * @param x_Api_Version (optional) 
     */
    getRatings(stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<RatingViewModel[]> {
        let url_ = this.baseUrl + "/api/MarketPlace/GetRatings?";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetRatings(_response));
        });
    }

    protected processGetRatings(response: Response): Promise<RatingViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RatingViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RatingViewModel[]>(null as any);
    }

    /**
     * Get service rating
     * @param stpdId (optional) Service id
     * @param x_Api_Version (optional) 
     */
    getRating(stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<number | null> {
        let url_ = this.baseUrl + "/api/MarketPlace/GetRating?";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetRating(_response));
        });
    }

    protected processGetRating(response: Response): Promise<number | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number | null>(null as any);
    }

    /**
     * Rate a service
     * @param stpdId (optional) Service id
     * @param rating (optional) 
     * @param comment (optional) 
     * @param x_Api_Version (optional) 
     */
    rate(stpdId: number | undefined, rating: number | undefined, comment: string | null | undefined, x_Api_Version: string | null | undefined): Promise<RatingViewModel> {
        let url_ = this.baseUrl + "/api/MarketPlace/Rate?";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (rating === null)
            throw new Error("The parameter 'rating' cannot be null.");
        else if (rating !== undefined)
            url_ += "rating=" + encodeURIComponent("" + rating) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRate(_response));
        });
    }

    protected processRate(response: Response): Promise<RatingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RatingViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RatingViewModel>(null as any);
    }

    /**
     * Invite a user to a service
     * @param x_Api_Version (optional) 
     */
    invite(x_Api_Version: string | null | undefined, invite: UserInviteViewModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/MarketPlace/Invite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invite);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processInvite(_response));
        });
    }

    protected processInvite(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface INotificationClient {

    /**
     * Get the current user notification preferences
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    getPreferences(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<NotificationPreferences>;

    /**
     * Save the current user notification preferences
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     * @param preferences The preferences to save
     */
    savePreferences(userId: string | null | undefined, x_Api_Version: string | null | undefined, preferences: NotificationPreferences): Promise<NotificationPreferences>;

    /**
     * Get Notifications Count
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    getUnreadCount(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Get Notifications Count
     * @param userId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param includeAlreadyRead (optional) 
     * @param to (optional) 
     * @param subject (optional) 
     * @param body (optional) 
     * @param error (optional) 
     * @param type (optional) 
     * @param status (optional) 
     * @param area (optional) 
     * @param evnt (optional) 
     * @param x_Api_Version (optional) 
     */
    getCount(userId: string | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, includeAlreadyRead: boolean | undefined, to: string | null | undefined, subject: string | null | undefined, body: string | null | undefined, error: string | null | undefined, type: NotificationType | null | undefined, status: NotificationStatus | null | undefined, area: NotificationArea | null | undefined, evnt: NotificationEvent | null | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Get Notifications
     * @param userId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param includeAlreadyRead (optional) 
     * @param to (optional) 
     * @param subject (optional) 
     * @param body (optional) 
     * @param error (optional) 
     * @param type (optional) 
     * @param status (optional) 
     * @param area (optional) 
     * @param evnt (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param x_Api_Version (optional) 
     */
    get(userId: string | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, includeAlreadyRead: boolean | undefined, to: string | null | undefined, subject: string | null | undefined, body: string | null | undefined, error: string | null | undefined, type: NotificationType | null | undefined, status: NotificationStatus | null | undefined, area: NotificationArea | null | undefined, evnt: NotificationEvent | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, x_Api_Version: string | null | undefined): Promise<NotificationViewModel[]>;

    /**
     * Get Attachment
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    getAttachment(id: number | undefined, x_Api_Version: string | null | undefined): Promise<NotificationAttachmentViewModel>;

    /**
     * Create Email Notifications for Support and Other
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, notification: NotificationViewModel): Promise<NotificationViewModel>;

    /**
     * Flag multiple notifications as read
     * @param userId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param includeAlreadyRead (optional) 
     * @param to (optional) 
     * @param subject (optional) 
     * @param body (optional) 
     * @param error (optional) 
     * @param type (optional) 
     * @param status (optional) 
     * @param area (optional) 
     * @param evnt (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param x_Api_Version (optional) 
     */
    bulkFlagAsRead(userId: string | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, includeAlreadyRead: boolean | undefined, to: string | null | undefined, subject: string | null | undefined, body: string | null | undefined, error: string | null | undefined, type: NotificationType | null | undefined, status: NotificationStatus | null | undefined, area: NotificationArea | null | undefined, evnt: NotificationEvent | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Flag Notification as read
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    flagAsRead(id: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;

    /**
     * Delete
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<NotificationViewModel>;
}

export class NotificationClient extends AIForgedBase implements INotificationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get the current user notification preferences
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    getPreferences(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<NotificationPreferences> {
        let url_ = this.baseUrl + "/api/Notification/GetPreferences?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPreferences(_response));
        });
    }

    protected processGetPreferences(response: Response): Promise<NotificationPreferences> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationPreferences.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationPreferences>(null as any);
    }

    /**
     * Save the current user notification preferences
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     * @param preferences The preferences to save
     */
    savePreferences(userId: string | null | undefined, x_Api_Version: string | null | undefined, preferences: NotificationPreferences): Promise<NotificationPreferences> {
        let url_ = this.baseUrl + "/api/Notification/SavePreferences?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(preferences);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSavePreferences(_response));
        });
    }

    protected processSavePreferences(response: Response): Promise<NotificationPreferences> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationPreferences.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationPreferences>(null as any);
    }

    /**
     * Get Notifications Count
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    getUnreadCount(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Notification/GetUnreadCount?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetUnreadCount(_response));
        });
    }

    protected processGetUnreadCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get Notifications Count
     * @param userId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param includeAlreadyRead (optional) 
     * @param to (optional) 
     * @param subject (optional) 
     * @param body (optional) 
     * @param error (optional) 
     * @param type (optional) 
     * @param status (optional) 
     * @param area (optional) 
     * @param evnt (optional) 
     * @param x_Api_Version (optional) 
     */
    getCount(userId: string | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, includeAlreadyRead: boolean | undefined, to: string | null | undefined, subject: string | null | undefined, body: string | null | undefined, error: string | null | undefined, type: NotificationType | null | undefined, status: NotificationStatus | null | undefined, area: NotificationArea | null | undefined, evnt: NotificationEvent | null | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Notification/GetCount?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (includeAlreadyRead === null)
            throw new Error("The parameter 'includeAlreadyRead' cannot be null.");
        else if (includeAlreadyRead !== undefined)
            url_ += "includeAlreadyRead=" + encodeURIComponent("" + includeAlreadyRead) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (subject !== undefined && subject !== null)
            url_ += "subject=" + encodeURIComponent("" + subject) + "&";
        if (body !== undefined && body !== null)
            url_ += "body=" + encodeURIComponent("" + body) + "&";
        if (error !== undefined && error !== null)
            url_ += "error=" + encodeURIComponent("" + error) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (area !== undefined && area !== null)
            url_ += "area=" + encodeURIComponent("" + area) + "&";
        if (evnt !== undefined && evnt !== null)
            url_ += "evnt=" + encodeURIComponent("" + evnt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCount(_response));
        });
    }

    protected processGetCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get Notifications
     * @param userId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param includeAlreadyRead (optional) 
     * @param to (optional) 
     * @param subject (optional) 
     * @param body (optional) 
     * @param error (optional) 
     * @param type (optional) 
     * @param status (optional) 
     * @param area (optional) 
     * @param evnt (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param x_Api_Version (optional) 
     */
    get(userId: string | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, includeAlreadyRead: boolean | undefined, to: string | null | undefined, subject: string | null | undefined, body: string | null | undefined, error: string | null | undefined, type: NotificationType | null | undefined, status: NotificationStatus | null | undefined, area: NotificationArea | null | undefined, evnt: NotificationEvent | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, x_Api_Version: string | null | undefined): Promise<NotificationViewModel[]> {
        let url_ = this.baseUrl + "/api/Notification/Get?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (includeAlreadyRead === null)
            throw new Error("The parameter 'includeAlreadyRead' cannot be null.");
        else if (includeAlreadyRead !== undefined)
            url_ += "includeAlreadyRead=" + encodeURIComponent("" + includeAlreadyRead) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (subject !== undefined && subject !== null)
            url_ += "subject=" + encodeURIComponent("" + subject) + "&";
        if (body !== undefined && body !== null)
            url_ += "body=" + encodeURIComponent("" + body) + "&";
        if (error !== undefined && error !== null)
            url_ += "error=" + encodeURIComponent("" + error) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (area !== undefined && area !== null)
            url_ += "area=" + encodeURIComponent("" + area) + "&";
        if (evnt !== undefined && evnt !== null)
            url_ += "evnt=" + encodeURIComponent("" + evnt) + "&";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "pageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<NotificationViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationViewModel[]>(null as any);
    }

    /**
     * Get Attachment
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    getAttachment(id: number | undefined, x_Api_Version: string | null | undefined): Promise<NotificationAttachmentViewModel> {
        let url_ = this.baseUrl + "/api/Notification/GetAttachment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAttachment(_response));
        });
    }

    protected processGetAttachment(response: Response): Promise<NotificationAttachmentViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationAttachmentViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationAttachmentViewModel>(null as any);
    }

    /**
     * Create Email Notifications for Support and Other
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, notification: NotificationViewModel): Promise<NotificationViewModel> {
        let url_ = this.baseUrl + "/api/Notification/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notification);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<NotificationViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationViewModel>(null as any);
    }

    /**
     * Flag multiple notifications as read
     * @param userId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param includeAlreadyRead (optional) 
     * @param to (optional) 
     * @param subject (optional) 
     * @param body (optional) 
     * @param error (optional) 
     * @param type (optional) 
     * @param status (optional) 
     * @param area (optional) 
     * @param evnt (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param x_Api_Version (optional) 
     */
    bulkFlagAsRead(userId: string | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, includeAlreadyRead: boolean | undefined, to: string | null | undefined, subject: string | null | undefined, body: string | null | undefined, error: string | null | undefined, type: NotificationType | null | undefined, status: NotificationStatus | null | undefined, area: NotificationArea | null | undefined, evnt: NotificationEvent | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Notification/BulkFlagAsRead?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (includeAlreadyRead === null)
            throw new Error("The parameter 'includeAlreadyRead' cannot be null.");
        else if (includeAlreadyRead !== undefined)
            url_ += "includeAlreadyRead=" + encodeURIComponent("" + includeAlreadyRead) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (subject !== undefined && subject !== null)
            url_ += "subject=" + encodeURIComponent("" + subject) + "&";
        if (body !== undefined && body !== null)
            url_ += "body=" + encodeURIComponent("" + body) + "&";
        if (error !== undefined && error !== null)
            url_ += "error=" + encodeURIComponent("" + error) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (area !== undefined && area !== null)
            url_ += "area=" + encodeURIComponent("" + area) + "&";
        if (evnt !== undefined && evnt !== null)
            url_ += "evnt=" + encodeURIComponent("" + evnt) + "&";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "pageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processBulkFlagAsRead(_response));
        });
    }

    protected processBulkFlagAsRead(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Flag Notification as read
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    flagAsRead(id: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Notification/FlagAsRead?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processFlagAsRead(_response));
        });
    }

    protected processFlagAsRead(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Delete
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<NotificationViewModel> {
        let url_ = this.baseUrl + "/api/Notification/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<NotificationViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationViewModel>(null as any);
    }
}

export interface IParamDefClient {

    /**
     * Get definition by Id
     * @param id (optional) The definition id
     * @param x_Api_Version (optional) 
     * @return The definition parameter
     */
    get(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel>;

    /**
     * Get parent service for a parameter def by Id
     * @param id (optional) The parameter definition id
     * @param x_Api_Version (optional) 
     * @return The parent service
     */
    getParentService(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel>;

    /**
     * Get hierarchy of fields for a service
     * @param projectId (optional) The project id
     * @param stpdId (optional) The service id
     * @param includeCount (optional) Include counter stats
     * @param includeSettings (optional) Include settings
     * @param includeChildren (optional) Include child definiitions
     * @param x_Api_Version (optional) 
     * @return The definition hierarchy
     */
    getHierachy(projectId: number | undefined, stpdId: number | undefined, includeCount: boolean | undefined, includeSettings: boolean | undefined, includeChildren: boolean | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel>;

    /**
     * Get hierarchy of fields for a service
     * @param projectId (optional) The project id
     * @param stpdId (optional) The service id
     * @param pdId (optional) The def id
     * @param x_Api_Version (optional) 
     */
    getUsageCount(projectId: number | undefined, stpdId: number | undefined, pdId: number | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Create a new parameter definition
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, paramdef: ParameterDefViewModel): Promise<ParameterDefViewModel>;

    /**
     * Update a definition
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, paramdef: ParameterDefViewModel): Promise<ParameterDefViewModel>;

    /**
     * Delete a definition
     * @param paramdefid (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(paramdefid: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel>;

    /**
     * Delete multiple definitions
     * @param paramdefids (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteMulti(paramdefids: number[] | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]>;

    /**
     * Get setting for a definition by Id
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    getSetting(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefSettingViewModel>;

    /**
     * Get last setting for a definition
     * @param pdId (optional) 
     * @param type (optional) 
     * @param x_Api_Version (optional) 
     */
    getLastSetting(pdId: number | undefined, type: SettingType | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefSettingViewModel>;

    /**
     * Get settings for a definition
     * @param pdId (optional) 
     * @param type (optional) 
     * @param x_Api_Version (optional) 
     */
    getSettings(pdId: number | undefined, type: SettingType | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefSettingViewModel[]>;

    /**
     * Save setting for a definition
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    saveSetting(userId: string | null | undefined, x_Api_Version: string | null | undefined, setting: ParameterDefSettingViewModel): Promise<ParameterDefSettingViewModel>;

    /**
     * Create a new setting for a definition
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    createSetting(userId: string | null | undefined, x_Api_Version: string | null | undefined, setting: ParameterDefSettingViewModel): Promise<ParameterDefSettingViewModel>;

    /**
     * Elevate to parent level
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    elevate(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel>;
}

export class ParamDefClient extends AIForgedBase implements IParamDefClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get definition by Id
     * @param id (optional) The definition id
     * @param x_Api_Version (optional) 
     * @return The definition parameter
     */
    get(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel> {
        let url_ = this.baseUrl + "/api/ParamDef/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<ParameterDefViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel>(null as any);
    }

    /**
     * Get parent service for a parameter def by Id
     * @param id (optional) The parameter definition id
     * @param x_Api_Version (optional) 
     * @return The parent service
     */
    getParentService(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel> {
        let url_ = this.baseUrl + "/api/ParamDef/GetParentService?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetParentService(_response));
        });
    }

    protected processGetParentService(response: Response): Promise<ParameterDefViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel>(null as any);
    }

    /**
     * Get hierarchy of fields for a service
     * @param projectId (optional) The project id
     * @param stpdId (optional) The service id
     * @param includeCount (optional) Include counter stats
     * @param includeSettings (optional) Include settings
     * @param includeChildren (optional) Include child definiitions
     * @param x_Api_Version (optional) 
     * @return The definition hierarchy
     */
    getHierachy(projectId: number | undefined, stpdId: number | undefined, includeCount: boolean | undefined, includeSettings: boolean | undefined, includeChildren: boolean | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel> {
        let url_ = this.baseUrl + "/api/ParamDef/GetHierachy?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (includeCount === null)
            throw new Error("The parameter 'includeCount' cannot be null.");
        else if (includeCount !== undefined)
            url_ += "includeCount=" + encodeURIComponent("" + includeCount) + "&";
        if (includeSettings === null)
            throw new Error("The parameter 'includeSettings' cannot be null.");
        else if (includeSettings !== undefined)
            url_ += "includeSettings=" + encodeURIComponent("" + includeSettings) + "&";
        if (includeChildren === null)
            throw new Error("The parameter 'includeChildren' cannot be null.");
        else if (includeChildren !== undefined)
            url_ += "includeChildren=" + encodeURIComponent("" + includeChildren) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetHierachy(_response));
        });
    }

    protected processGetHierachy(response: Response): Promise<ParameterDefViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel>(null as any);
    }

    /**
     * Get hierarchy of fields for a service
     * @param projectId (optional) The project id
     * @param stpdId (optional) The service id
     * @param pdId (optional) The def id
     * @param x_Api_Version (optional) 
     */
    getUsageCount(projectId: number | undefined, stpdId: number | undefined, pdId: number | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/ParamDef/GetUsageCount?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (pdId === null)
            throw new Error("The parameter 'pdId' cannot be null.");
        else if (pdId !== undefined)
            url_ += "pdId=" + encodeURIComponent("" + pdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetUsageCount(_response));
        });
    }

    protected processGetUsageCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Create a new parameter definition
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, paramdef: ParameterDefViewModel): Promise<ParameterDefViewModel> {
        let url_ = this.baseUrl + "/api/ParamDef/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paramdef);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<ParameterDefViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel>(null as any);
    }

    /**
     * Update a definition
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, paramdef: ParameterDefViewModel): Promise<ParameterDefViewModel> {
        let url_ = this.baseUrl + "/api/ParamDef/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paramdef);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<ParameterDefViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel>(null as any);
    }

    /**
     * Delete a definition
     * @param paramdefid (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(paramdefid: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel> {
        let url_ = this.baseUrl + "/api/ParamDef/Delete?";
        if (paramdefid === null)
            throw new Error("The parameter 'paramdefid' cannot be null.");
        else if (paramdefid !== undefined)
            url_ += "paramdefid=" + encodeURIComponent("" + paramdefid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<ParameterDefViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel>(null as any);
    }

    /**
     * Delete multiple definitions
     * @param paramdefids (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteMulti(paramdefids: number[] | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]> {
        let url_ = this.baseUrl + "/api/ParamDef/DeleteMulti?";
        if (paramdefids !== undefined && paramdefids !== null)
            paramdefids && paramdefids.forEach(item => { url_ += "paramdefids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteMulti(_response));
        });
    }

    protected processDeleteMulti(response: Response): Promise<ParameterDefViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParameterDefViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel[]>(null as any);
    }

    /**
     * Get setting for a definition by Id
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    getSetting(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefSettingViewModel> {
        let url_ = this.baseUrl + "/api/ParamDef/GetSetting?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetSetting(_response));
        });
    }

    protected processGetSetting(response: Response): Promise<ParameterDefSettingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefSettingViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefSettingViewModel>(null as any);
    }

    /**
     * Get last setting for a definition
     * @param pdId (optional) 
     * @param type (optional) 
     * @param x_Api_Version (optional) 
     */
    getLastSetting(pdId: number | undefined, type: SettingType | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefSettingViewModel> {
        let url_ = this.baseUrl + "/api/ParamDef/GetLastSetting?";
        if (pdId === null)
            throw new Error("The parameter 'pdId' cannot be null.");
        else if (pdId !== undefined)
            url_ += "pdId=" + encodeURIComponent("" + pdId) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetLastSetting(_response));
        });
    }

    protected processGetLastSetting(response: Response): Promise<ParameterDefSettingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefSettingViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefSettingViewModel>(null as any);
    }

    /**
     * Get settings for a definition
     * @param pdId (optional) 
     * @param type (optional) 
     * @param x_Api_Version (optional) 
     */
    getSettings(pdId: number | undefined, type: SettingType | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefSettingViewModel[]> {
        let url_ = this.baseUrl + "/api/ParamDef/GetSettings?";
        if (pdId === null)
            throw new Error("The parameter 'pdId' cannot be null.");
        else if (pdId !== undefined)
            url_ += "pdId=" + encodeURIComponent("" + pdId) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetSettings(_response));
        });
    }

    protected processGetSettings(response: Response): Promise<ParameterDefSettingViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParameterDefSettingViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefSettingViewModel[]>(null as any);
    }

    /**
     * Save setting for a definition
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    saveSetting(userId: string | null | undefined, x_Api_Version: string | null | undefined, setting: ParameterDefSettingViewModel): Promise<ParameterDefSettingViewModel> {
        let url_ = this.baseUrl + "/api/ParamDef/SaveSetting?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setting);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSaveSetting(_response));
        });
    }

    protected processSaveSetting(response: Response): Promise<ParameterDefSettingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefSettingViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefSettingViewModel>(null as any);
    }

    /**
     * Create a new setting for a definition
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    createSetting(userId: string | null | undefined, x_Api_Version: string | null | undefined, setting: ParameterDefSettingViewModel): Promise<ParameterDefSettingViewModel> {
        let url_ = this.baseUrl + "/api/ParamDef/CreateSetting?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setting);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateSetting(_response));
        });
    }

    protected processCreateSetting(response: Response): Promise<ParameterDefSettingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefSettingViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefSettingViewModel>(null as any);
    }

    /**
     * Elevate to parent level
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    elevate(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel> {
        let url_ = this.baseUrl + "/api/ParamDef/Elevate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processElevate(_response));
        });
    }

    protected processElevate(response: Response): Promise<ParameterDefViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel>(null as any);
    }
}

export interface IParametersClient {

    /**
     * Get parameter value
     * @param docId (optional) The document id
     * @param stpdId (optional) The service id
     * @param category (optional) Parameter category
     * @param grouping (optional) Parameter grouping
     * @param includeverification (optional) Include verification data
     * @param x_Api_Version (optional) 
     * @return The parameters
     */
    get(docId: number | undefined, stpdId: number | undefined, category: ParameterDefinitionCategory | null | undefined, grouping: GroupingType | null | undefined, includeverification: boolean | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel[]>;

    /**
     * Get parameter hierarchy
     * @param docId (optional) The document id
     * @param stpdId (optional) The service id
     * @param includeverification (optional) Include verification data
     * @param pageIndex (optional) 
     * @param x_Api_Version (optional) 
     * @return Parameter hierarchy
     */
    getHierarchy(docId: number | undefined, stpdId: number | undefined, includeverification: boolean | undefined, pageIndex: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel[]>;

    /**
     * Create a new parameter on a document
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, param: DocumentParameterViewModel): Promise<DocumentParameterViewModel>;

    /**
     * Delete a parameter
     * @param paramid (optional) The parameter id
     * @param x_Api_Version (optional) 
     * @return Delete a parameter
     */
    delete(paramid: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel>;

    /**
     * Update a parameter
     * @param x_Api_Version (optional) 
     * @param param The parameter
     * @return Updated parameter
     */
    update(x_Api_Version: string | null | undefined, param: DocumentParameterViewModel): Promise<DocumentParameterViewModel>;

    /**
     * Update multiple parameter values
     * @param x_Api_Version (optional) 
     */
    updateMulti(x_Api_Version: string | null | undefined, parameters: DocumentParameterViewModel[]): Promise<DocumentParameterViewModel[]>;

    /**
     * Bulk change parameter definitions for parameters in all documents in a project
     * @param projectId (optional) The project Id
     * @param pdIdFrom (optional) From definition Id
     * @param pdIdTo (optional) To definition Id
     * @param x_Api_Version (optional) 
     */
    bulkChangeParamDef(projectId: number | undefined, pdIdFrom: number | undefined, pdIdTo: number | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Get a parameter by verification id
     * @param verificationId (optional) The verification id
     * @param x_Api_Version (optional) 
     * @return The document parameters
     */
    getByVerification(verificationId: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel>;

    /**
     * Get a summary of verifications
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     * @return A summary of parameter data
     */
    getSummary(projectId: number | undefined, x_Api_Version: string | null | undefined): Promise<DocParamSummary[]>;

    /**
     * Extract document parameters
     * @param docid (optional) The document id
     * @param x_Api_Version (optional) 
     * @return Flat structure of document parameters
     */
    extract(docid: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentExtraction[]>;

    /**
     * Export results to excel
     * @param projectId (optional) The project id
     * @param serviceId (optional) Service id
     * @param fromDate (optional) From date
     * @param toDate (optional) To date
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param x_Api_Version (optional) 
     * @return Flat structure of document parameters
     */
    exportToExcel(projectId: number | undefined, serviceId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;
}

export class ParametersClient extends AIForgedBase implements IParametersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get parameter value
     * @param docId (optional) The document id
     * @param stpdId (optional) The service id
     * @param category (optional) Parameter category
     * @param grouping (optional) Parameter grouping
     * @param includeverification (optional) Include verification data
     * @param x_Api_Version (optional) 
     * @return The parameters
     */
    get(docId: number | undefined, stpdId: number | undefined, category: ParameterDefinitionCategory | null | undefined, grouping: GroupingType | null | undefined, includeverification: boolean | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel[]> {
        let url_ = this.baseUrl + "/api/Parameters/Get?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (category !== undefined && category !== null)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (grouping !== undefined && grouping !== null)
            url_ += "grouping=" + encodeURIComponent("" + grouping) + "&";
        if (includeverification === null)
            throw new Error("The parameter 'includeverification' cannot be null.");
        else if (includeverification !== undefined)
            url_ += "includeverification=" + encodeURIComponent("" + includeverification) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<DocumentParameterViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentParameterViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentParameterViewModel[]>(null as any);
    }

    /**
     * Get parameter hierarchy
     * @param docId (optional) The document id
     * @param stpdId (optional) The service id
     * @param includeverification (optional) Include verification data
     * @param pageIndex (optional) 
     * @param x_Api_Version (optional) 
     * @return Parameter hierarchy
     */
    getHierarchy(docId: number | undefined, stpdId: number | undefined, includeverification: boolean | undefined, pageIndex: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel[]> {
        let url_ = this.baseUrl + "/api/Parameters/GetHierarchy?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (includeverification === null)
            throw new Error("The parameter 'includeverification' cannot be null.");
        else if (includeverification !== undefined)
            url_ += "includeverification=" + encodeURIComponent("" + includeverification) + "&";
        if (pageIndex !== undefined && pageIndex !== null)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetHierarchy(_response));
        });
    }

    protected processGetHierarchy(response: Response): Promise<DocumentParameterViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentParameterViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentParameterViewModel[]>(null as any);
    }

    /**
     * Create a new parameter on a document
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, param: DocumentParameterViewModel): Promise<DocumentParameterViewModel> {
        let url_ = this.baseUrl + "/api/Parameters/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(param);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<DocumentParameterViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentParameterViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentParameterViewModel>(null as any);
    }

    /**
     * Delete a parameter
     * @param paramid (optional) The parameter id
     * @param x_Api_Version (optional) 
     * @return Delete a parameter
     */
    delete(paramid: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel> {
        let url_ = this.baseUrl + "/api/Parameters/Delete?";
        if (paramid === null)
            throw new Error("The parameter 'paramid' cannot be null.");
        else if (paramid !== undefined)
            url_ += "paramid=" + encodeURIComponent("" + paramid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<DocumentParameterViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentParameterViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentParameterViewModel>(null as any);
    }

    /**
     * Update a parameter
     * @param x_Api_Version (optional) 
     * @param param The parameter
     * @return Updated parameter
     */
    update(x_Api_Version: string | null | undefined, param: DocumentParameterViewModel): Promise<DocumentParameterViewModel> {
        let url_ = this.baseUrl + "/api/Parameters/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(param);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<DocumentParameterViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentParameterViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentParameterViewModel>(null as any);
    }

    /**
     * Update multiple parameter values
     * @param x_Api_Version (optional) 
     */
    updateMulti(x_Api_Version: string | null | undefined, parameters: DocumentParameterViewModel[]): Promise<DocumentParameterViewModel[]> {
        let url_ = this.baseUrl + "/api/Parameters/UpdateMulti";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(parameters);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateMulti(_response));
        });
    }

    protected processUpdateMulti(response: Response): Promise<DocumentParameterViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentParameterViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentParameterViewModel[]>(null as any);
    }

    /**
     * Bulk change parameter definitions for parameters in all documents in a project
     * @param projectId (optional) The project Id
     * @param pdIdFrom (optional) From definition Id
     * @param pdIdTo (optional) To definition Id
     * @param x_Api_Version (optional) 
     */
    bulkChangeParamDef(projectId: number | undefined, pdIdFrom: number | undefined, pdIdTo: number | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Parameters/BulkChangeParamDef?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (pdIdFrom === null)
            throw new Error("The parameter 'pdIdFrom' cannot be null.");
        else if (pdIdFrom !== undefined)
            url_ += "pdIdFrom=" + encodeURIComponent("" + pdIdFrom) + "&";
        if (pdIdTo === null)
            throw new Error("The parameter 'pdIdTo' cannot be null.");
        else if (pdIdTo !== undefined)
            url_ += "pdIdTo=" + encodeURIComponent("" + pdIdTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processBulkChangeParamDef(_response));
        });
    }

    protected processBulkChangeParamDef(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get a parameter by verification id
     * @param verificationId (optional) The verification id
     * @param x_Api_Version (optional) 
     * @return The document parameters
     */
    getByVerification(verificationId: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel> {
        let url_ = this.baseUrl + "/api/Parameters/GetByVerification?";
        if (verificationId === null)
            throw new Error("The parameter 'verificationId' cannot be null.");
        else if (verificationId !== undefined)
            url_ += "verificationId=" + encodeURIComponent("" + verificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetByVerification(_response));
        });
    }

    protected processGetByVerification(response: Response): Promise<DocumentParameterViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentParameterViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentParameterViewModel>(null as any);
    }

    /**
     * Get a summary of verifications
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     * @return A summary of parameter data
     */
    getSummary(projectId: number | undefined, x_Api_Version: string | null | undefined): Promise<DocParamSummary[]> {
        let url_ = this.baseUrl + "/api/Parameters/GetSummary?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetSummary(_response));
        });
    }

    protected processGetSummary(response: Response): Promise<DocParamSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocParamSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocParamSummary[]>(null as any);
    }

    /**
     * Extract document parameters
     * @param docid (optional) The document id
     * @param x_Api_Version (optional) 
     * @return Flat structure of document parameters
     */
    extract(docid: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentExtraction[]> {
        let url_ = this.baseUrl + "/api/Parameters/Extract?";
        if (docid === null)
            throw new Error("The parameter 'docid' cannot be null.");
        else if (docid !== undefined)
            url_ += "docid=" + encodeURIComponent("" + docid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processExtract(_response));
        });
    }

    protected processExtract(response: Response): Promise<DocumentExtraction[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentExtraction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentExtraction[]>(null as any);
    }

    /**
     * Export results to excel
     * @param projectId (optional) The project id
     * @param serviceId (optional) Service id
     * @param fromDate (optional) From date
     * @param toDate (optional) To date
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param x_Api_Version (optional) 
     * @return Flat structure of document parameters
     */
    exportToExcel(projectId: number | undefined, serviceId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Parameters/ExportToExcel?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (serviceId === null)
            throw new Error("The parameter 'serviceId' cannot be null.");
        else if (serviceId !== undefined)
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "pageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processExportToExcel(_response));
        });
    }

    protected processExportToExcel(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IPaymentClient {

    /**
     * Get paymetnhtml for credit card processing
     * @param uId (optional) 
     * @param pId (optional) 
     * @param bId (optional) 
     * @param intent (optional) 
     * @param x_Api_Version (optional) 
     */
    getPaymentHtml(uId: string | null | undefined, pId: number | undefined, bId: number | undefined, intent: string | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;

    /**
     * Create an order
     * @param uId (optional) 
     * @param pId (optional) 
     * @param bId (optional) 
     * @param intent (optional) 
     * @param x_Api_Version (optional) 
     */
    createOrder(uId: string | null | undefined, pId: number | undefined, bId: number | undefined, intent: string | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;

    /**
     * Process the order
     * @param action (optional) 
     * @param x_Api_Version (optional) 
     */
    orderProcess(action: string | null | undefined, x_Api_Version: string | null | undefined, order: OrderViewModel): Promise<FileResponse>;

    /**
     * Get info on an order
     * @param x_Api_Version (optional) 
     */
    getOrder(x_Api_Version: string | null | undefined, orderId: string): Promise<FileResponse>;

    /**
     * Get payments made by a user
     * @param userId (optional) The user id
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param x_Api_Version (optional) 
     */
    getPayments(userId: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, x_Api_Version: string | null | undefined): Promise<PaymentViewModel[]>;

    /**
     * Process a payment and update status from payment provider
     * @param paymentId (optional) 
     * @param x_Api_Version (optional) 
     */
    processPayment(paymentId: number | undefined, x_Api_Version: string | null | undefined): Promise<PaymentViewModel>;
}

export class PaymentClient extends AIForgedBase implements IPaymentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get paymetnhtml for credit card processing
     * @param uId (optional) 
     * @param pId (optional) 
     * @param bId (optional) 
     * @param intent (optional) 
     * @param x_Api_Version (optional) 
     */
    getPaymentHtml(uId: string | null | undefined, pId: number | undefined, bId: number | undefined, intent: string | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Payment/GetPaymentHtml?";
        if (uId !== undefined && uId !== null)
            url_ += "uId=" + encodeURIComponent("" + uId) + "&";
        if (pId === null)
            throw new Error("The parameter 'pId' cannot be null.");
        else if (pId !== undefined)
            url_ += "pId=" + encodeURIComponent("" + pId) + "&";
        if (bId === null)
            throw new Error("The parameter 'bId' cannot be null.");
        else if (bId !== undefined)
            url_ += "bId=" + encodeURIComponent("" + bId) + "&";
        if (intent !== undefined && intent !== null)
            url_ += "intent=" + encodeURIComponent("" + intent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPaymentHtml(_response));
        });
    }

    protected processGetPaymentHtml(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Create an order
     * @param uId (optional) 
     * @param pId (optional) 
     * @param bId (optional) 
     * @param intent (optional) 
     * @param x_Api_Version (optional) 
     */
    createOrder(uId: string | null | undefined, pId: number | undefined, bId: number | undefined, intent: string | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Payment/CreateOrder?";
        if (uId !== undefined && uId !== null)
            url_ += "uId=" + encodeURIComponent("" + uId) + "&";
        if (pId === null)
            throw new Error("The parameter 'pId' cannot be null.");
        else if (pId !== undefined)
            url_ += "pId=" + encodeURIComponent("" + pId) + "&";
        if (bId === null)
            throw new Error("The parameter 'bId' cannot be null.");
        else if (bId !== undefined)
            url_ += "bId=" + encodeURIComponent("" + bId) + "&";
        if (intent !== undefined && intent !== null)
            url_ += "intent=" + encodeURIComponent("" + intent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateOrder(_response));
        });
    }

    protected processCreateOrder(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Process the order
     * @param action (optional) 
     * @param x_Api_Version (optional) 
     */
    orderProcess(action: string | null | undefined, x_Api_Version: string | null | undefined, order: OrderViewModel): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Payment/OrderProcess?";
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(order);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processOrderProcess(_response));
        });
    }

    protected processOrderProcess(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get info on an order
     * @param x_Api_Version (optional) 
     */
    getOrder(x_Api_Version: string | null | undefined, orderId: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Payment/GetOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(orderId);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetOrder(_response));
        });
    }

    protected processGetOrder(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get payments made by a user
     * @param userId (optional) The user id
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param x_Api_Version (optional) 
     */
    getPayments(userId: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, x_Api_Version: string | null | undefined): Promise<PaymentViewModel[]> {
        let url_ = this.baseUrl + "/api/Payment/GetPayments?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPayments(_response));
        });
    }

    protected processGetPayments(response: Response): Promise<PaymentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentViewModel[]>(null as any);
    }

    /**
     * Process a payment and update status from payment provider
     * @param paymentId (optional) 
     * @param x_Api_Version (optional) 
     */
    processPayment(paymentId: number | undefined, x_Api_Version: string | null | undefined): Promise<PaymentViewModel> {
        let url_ = this.baseUrl + "/api/Payment/ProcessPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processProcessPayment(_response));
        });
    }

    protected processProcessPayment(response: Response): Promise<PaymentViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentViewModel>(null as any);
    }
}

export interface IProjectClient {

    /**
     * Get projects and services linked to a user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     * @return List of projects
     */
    getByUser(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectViewModel[]>;

    /**
     * Get a specific project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     * @return The project
     */
    getUserProject(userId: string | null | undefined, projectId: number | undefined, x_Api_Version: string | null | undefined): Promise<ProjectViewModel>;

    /**
     * Get hierarchy of fields for all services in a project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) The service id
     * @param groupId (optional) The group id
     * @param includeCount (optional) Include counter stats
     * @param onlyServices (optional) Only include services
     * @param includeSettings (optional) Include settings
     * @param includeChildren (optional) Include children
     * @param x_Api_Version (optional) 
     * @return The parameters definitions linked to the service
     */
    getHierachies(userId: string | null | undefined, projectId: number | undefined, stpdId: number | null | undefined, groupId: number | null | undefined, includeCount: boolean | undefined, onlyServices: boolean | undefined, includeSettings: boolean | undefined, includeChildren: boolean | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]>;

    /**
     * Create a new project
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, project: ProjectViewModel): Promise<ProjectViewModel>;

    /**
     * Update a project
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    update(userId: string | null | undefined, x_Api_Version: string | null | undefined, project: ProjectViewModel): Promise<ProjectViewModel>;

    /**
     * Delete a project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     */
    delete(userId: string | null | undefined, projectId: number | undefined, x_Api_Version: string | null | undefined): Promise<ProjectViewModel>;

    /**
     * Find a project by name
     * @param userId (optional) The user id
     * @param projectName (optional) Project name
     * @param x_Api_Version (optional) 
     * @return The project
     */
    getByName(userId: string | null | undefined, projectName: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectViewModel>;

    /**
     * Get services related to a project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stlfilter (optional) Service type filter
     * @param enginefilter (optional) Filter by engine
     * @param x_Api_Version (optional) 
     * @return List of Services
     */
    getServices(userId: string | null | undefined, projectId: number | undefined, stlfilter: number | null | undefined, enginefilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]>;

    /**
     * Change the owner of a project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param toUserId (optional) 
     * @param x_Api_Version (optional) 
     */
    changeOwner(userId: string | null | undefined, projectId: number | undefined, toUserId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;

    /**
     * Create a manual credit and link it to a project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param bundleId (optional) 
     * @param x_Api_Version (optional) 
     */
    createCredit(userId: string | null | undefined, projectId: number | undefined, bundleId: number | undefined, x_Api_Version: string | null | undefined): Promise<TransactionsAuditViewModel>;
}

export class ProjectClient extends AIForgedBase implements IProjectClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get projects and services linked to a user
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     * @return List of projects
     */
    getByUser(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectViewModel[]> {
        let url_ = this.baseUrl + "/api/Project/GetByUser?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetByUser(_response));
        });
    }

    protected processGetByUser(response: Response): Promise<ProjectViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectViewModel[]>(null as any);
    }

    /**
     * Get a specific project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     * @return The project
     */
    getUserProject(userId: string | null | undefined, projectId: number | undefined, x_Api_Version: string | null | undefined): Promise<ProjectViewModel> {
        let url_ = this.baseUrl + "/api/Project/GetUserProject?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetUserProject(_response));
        });
    }

    protected processGetUserProject(response: Response): Promise<ProjectViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectViewModel>(null as any);
    }

    /**
     * Get hierarchy of fields for all services in a project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) The service id
     * @param groupId (optional) The group id
     * @param includeCount (optional) Include counter stats
     * @param onlyServices (optional) Only include services
     * @param includeSettings (optional) Include settings
     * @param includeChildren (optional) Include children
     * @param x_Api_Version (optional) 
     * @return The parameters definitions linked to the service
     */
    getHierachies(userId: string | null | undefined, projectId: number | undefined, stpdId: number | null | undefined, groupId: number | null | undefined, includeCount: boolean | undefined, onlyServices: boolean | undefined, includeSettings: boolean | undefined, includeChildren: boolean | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]> {
        let url_ = this.baseUrl + "/api/Project/GetHierachies?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId !== undefined && stpdId !== null)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (includeCount === null)
            throw new Error("The parameter 'includeCount' cannot be null.");
        else if (includeCount !== undefined)
            url_ += "includeCount=" + encodeURIComponent("" + includeCount) + "&";
        if (onlyServices === null)
            throw new Error("The parameter 'onlyServices' cannot be null.");
        else if (onlyServices !== undefined)
            url_ += "onlyServices=" + encodeURIComponent("" + onlyServices) + "&";
        if (includeSettings === null)
            throw new Error("The parameter 'includeSettings' cannot be null.");
        else if (includeSettings !== undefined)
            url_ += "includeSettings=" + encodeURIComponent("" + includeSettings) + "&";
        if (includeChildren === null)
            throw new Error("The parameter 'includeChildren' cannot be null.");
        else if (includeChildren !== undefined)
            url_ += "includeChildren=" + encodeURIComponent("" + includeChildren) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetHierachies(_response));
        });
    }

    protected processGetHierachies(response: Response): Promise<ParameterDefViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParameterDefViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel[]>(null as any);
    }

    /**
     * Create a new project
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, project: ProjectViewModel): Promise<ProjectViewModel> {
        let url_ = this.baseUrl + "/api/Project/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(project);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<ProjectViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectViewModel>(null as any);
    }

    /**
     * Update a project
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    update(userId: string | null | undefined, x_Api_Version: string | null | undefined, project: ProjectViewModel): Promise<ProjectViewModel> {
        let url_ = this.baseUrl + "/api/Project/Update?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(project);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<ProjectViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectViewModel>(null as any);
    }

    /**
     * Delete a project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     */
    delete(userId: string | null | undefined, projectId: number | undefined, x_Api_Version: string | null | undefined): Promise<ProjectViewModel> {
        let url_ = this.baseUrl + "/api/Project/Delete?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<ProjectViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectViewModel>(null as any);
    }

    /**
     * Find a project by name
     * @param userId (optional) The user id
     * @param projectName (optional) Project name
     * @param x_Api_Version (optional) 
     * @return The project
     */
    getByName(userId: string | null | undefined, projectName: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectViewModel> {
        let url_ = this.baseUrl + "/api/Project/GetByName?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectName !== undefined && projectName !== null)
            url_ += "projectName=" + encodeURIComponent("" + projectName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetByName(_response));
        });
    }

    protected processGetByName(response: Response): Promise<ProjectViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectViewModel>(null as any);
    }

    /**
     * Get services related to a project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stlfilter (optional) Service type filter
     * @param enginefilter (optional) Filter by engine
     * @param x_Api_Version (optional) 
     * @return List of Services
     */
    getServices(userId: string | null | undefined, projectId: number | undefined, stlfilter: number | null | undefined, enginefilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]> {
        let url_ = this.baseUrl + "/api/Project/GetServices?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stlfilter !== undefined && stlfilter !== null)
            url_ += "stlfilter=" + encodeURIComponent("" + stlfilter) + "&";
        if (enginefilter !== undefined && enginefilter !== null)
            url_ += "enginefilter=" + encodeURIComponent("" + enginefilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetServices(_response));
        });
    }

    protected processGetServices(response: Response): Promise<ParameterDefViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParameterDefViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel[]>(null as any);
    }

    /**
     * Change the owner of a project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param toUserId (optional) 
     * @param x_Api_Version (optional) 
     */
    changeOwner(userId: string | null | undefined, projectId: number | undefined, toUserId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Project/ChangeOwner?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (toUserId !== undefined && toUserId !== null)
            url_ += "toUserId=" + encodeURIComponent("" + toUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processChangeOwner(_response));
        });
    }

    protected processChangeOwner(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Create a manual credit and link it to a project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param bundleId (optional) 
     * @param x_Api_Version (optional) 
     */
    createCredit(userId: string | null | undefined, projectId: number | undefined, bundleId: number | undefined, x_Api_Version: string | null | undefined): Promise<TransactionsAuditViewModel> {
        let url_ = this.baseUrl + "/api/Project/CreateCredit?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (bundleId === null)
            throw new Error("The parameter 'bundleId' cannot be null.");
        else if (bundleId !== undefined)
            url_ += "bundleId=" + encodeURIComponent("" + bundleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateCredit(_response));
        });
    }

    protected processCreateCredit(response: Response): Promise<TransactionsAuditViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionsAuditViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionsAuditViewModel>(null as any);
    }
}

export interface IReportsClient {

    /**
     * Get groups
     * @param x_Api_Version (optional) 
     */
    getGroups(x_Api_Version: string | null | undefined): Promise<Group[]>;

    /**
     * Get goup users
     * @param groupid (optional) 
     * @param x_Api_Version (optional) 
     */
    getGroupUsers(groupid: string | undefined, x_Api_Version: string | null | undefined): Promise<GroupUser[]>;

    /**
     * Get reports
     * @param groupid (optional) 
     * @param x_Api_Version (optional) 
     */
    getReports(groupid: string | undefined, x_Api_Version: string | null | undefined): Promise<Report[]>;

    /**
     * Get report by Id
     * @param groupid (optional) 
     * @param reportid (optional) 
     * @param x_Api_Version (optional) 
     */
    getReport(groupid: string | undefined, reportid: string | undefined, x_Api_Version: string | null | undefined): Promise<Report>;

    /**
     * Get pages by report id
     * @param groupid (optional) 
     * @param reportid (optional) 
     * @param x_Api_Version (optional) 
     */
    getPages(groupid: string | undefined, reportid: string | undefined, x_Api_Version: string | null | undefined): Promise<Page[]>;
}

export class ReportsClient extends AIForgedBase implements IReportsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get groups
     * @param x_Api_Version (optional) 
     */
    getGroups(x_Api_Version: string | null | undefined): Promise<Group[]> {
        let url_ = this.baseUrl + "/api/Reports/GetGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetGroups(_response));
        });
    }

    protected processGetGroups(response: Response): Promise<Group[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Group.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Group[]>(null as any);
    }

    /**
     * Get goup users
     * @param groupid (optional) 
     * @param x_Api_Version (optional) 
     */
    getGroupUsers(groupid: string | undefined, x_Api_Version: string | null | undefined): Promise<GroupUser[]> {
        let url_ = this.baseUrl + "/api/Reports/GetGroupUsers?";
        if (groupid === null)
            throw new Error("The parameter 'groupid' cannot be null.");
        else if (groupid !== undefined)
            url_ += "groupid=" + encodeURIComponent("" + groupid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetGroupUsers(_response));
        });
    }

    protected processGetGroupUsers(response: Response): Promise<GroupUser[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupUser.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupUser[]>(null as any);
    }

    /**
     * Get reports
     * @param groupid (optional) 
     * @param x_Api_Version (optional) 
     */
    getReports(groupid: string | undefined, x_Api_Version: string | null | undefined): Promise<Report[]> {
        let url_ = this.baseUrl + "/api/Reports/GetReports?";
        if (groupid === null)
            throw new Error("The parameter 'groupid' cannot be null.");
        else if (groupid !== undefined)
            url_ += "groupid=" + encodeURIComponent("" + groupid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetReports(_response));
        });
    }

    protected processGetReports(response: Response): Promise<Report[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Report.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Report[]>(null as any);
    }

    /**
     * Get report by Id
     * @param groupid (optional) 
     * @param reportid (optional) 
     * @param x_Api_Version (optional) 
     */
    getReport(groupid: string | undefined, reportid: string | undefined, x_Api_Version: string | null | undefined): Promise<Report> {
        let url_ = this.baseUrl + "/api/Reports/GetReport?";
        if (groupid === null)
            throw new Error("The parameter 'groupid' cannot be null.");
        else if (groupid !== undefined)
            url_ += "groupid=" + encodeURIComponent("" + groupid) + "&";
        if (reportid === null)
            throw new Error("The parameter 'reportid' cannot be null.");
        else if (reportid !== undefined)
            url_ += "reportid=" + encodeURIComponent("" + reportid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetReport(_response));
        });
    }

    protected processGetReport(response: Response): Promise<Report> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Report.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Report>(null as any);
    }

    /**
     * Get pages by report id
     * @param groupid (optional) 
     * @param reportid (optional) 
     * @param x_Api_Version (optional) 
     */
    getPages(groupid: string | undefined, reportid: string | undefined, x_Api_Version: string | null | undefined): Promise<Page[]> {
        let url_ = this.baseUrl + "/api/Reports/GetPages?";
        if (groupid === null)
            throw new Error("The parameter 'groupid' cannot be null.");
        else if (groupid !== undefined)
            url_ += "groupid=" + encodeURIComponent("" + groupid) + "&";
        if (reportid === null)
            throw new Error("The parameter 'reportid' cannot be null.");
        else if (reportid !== undefined)
            url_ += "reportid=" + encodeURIComponent("" + reportid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPages(_response));
        });
    }

    protected processGetPages(response: Response): Promise<Page[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Page.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Page[]>(null as any);
    }
}

export interface IRolesClient {

    /**
     * Get role info by id.
     * @param id (optional) The role id.
     * @param x_Api_Version (optional) 
     * @return The role
     */
    get(id: string | null | undefined, x_Api_Version: string | null | undefined): Promise<RoleViewModel>;

    /**
     * Get role info by name.
     * @param name (optional) The name of the role.
     * @param x_Api_Version (optional) 
     * @return The role
     */
    getByName(name: string | null | undefined, x_Api_Version: string | null | undefined): Promise<RoleViewModel>;

    /**
     * Get all roles.
     * @param x_Api_Version (optional) 
     * @return List of roles
     */
    getAll(x_Api_Version: string | null | undefined): Promise<RoleViewModel[]>;

    /**
     * Get roles by pages
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param x_Api_Version (optional) 
     */
    getPaged(page: number | undefined, pageSize: number | undefined, x_Api_Version: string | null | undefined): Promise<RoleViewModel[]>;

    /**
     * Update a role
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    update(id: string | null | undefined, x_Api_Version: string | null | undefined, role: RoleViewModel): Promise<boolean>;

    /**
     * Create a role
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, role: RoleViewModel): Promise<RoleViewModel>;

    /**
     * Delete a role
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: string | null | undefined, x_Api_Version: string | null | undefined): Promise<RoleViewModel>;

    /**
     * Get permissions claims on the system
     * @param x_Api_Version (optional) 
     */
    getAllPermissions(x_Api_Version: string | null | undefined): Promise<PermissionViewModel[]>;
}

export class RolesClient extends AIForgedBase implements IRolesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get role info by id.
     * @param id (optional) The role id.
     * @param x_Api_Version (optional) 
     * @return The role
     */
    get(id: string | null | undefined, x_Api_Version: string | null | undefined): Promise<RoleViewModel> {
        let url_ = this.baseUrl + "/api/Roles/Get?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<RoleViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleViewModel>(null as any);
    }

    /**
     * Get role info by name.
     * @param name (optional) The name of the role.
     * @param x_Api_Version (optional) 
     * @return The role
     */
    getByName(name: string | null | undefined, x_Api_Version: string | null | undefined): Promise<RoleViewModel> {
        let url_ = this.baseUrl + "/api/Roles/GetByName?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetByName(_response));
        });
    }

    protected processGetByName(response: Response): Promise<RoleViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleViewModel>(null as any);
    }

    /**
     * Get all roles.
     * @param x_Api_Version (optional) 
     * @return List of roles
     */
    getAll(x_Api_Version: string | null | undefined): Promise<RoleViewModel[]> {
        let url_ = this.baseUrl + "/api/Roles/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<RoleViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleViewModel[]>(null as any);
    }

    /**
     * Get roles by pages
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param x_Api_Version (optional) 
     */
    getPaged(page: number | undefined, pageSize: number | undefined, x_Api_Version: string | null | undefined): Promise<RoleViewModel[]> {
        let url_ = this.baseUrl + "/api/Roles/GetPaged?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPaged(_response));
        });
    }

    protected processGetPaged(response: Response): Promise<RoleViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleViewModel[]>(null as any);
    }

    /**
     * Update a role
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    update(id: string | null | undefined, x_Api_Version: string | null | undefined, role: RoleViewModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Roles/Update?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Create a role
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, role: RoleViewModel): Promise<RoleViewModel> {
        let url_ = this.baseUrl + "/api/Roles/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<RoleViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleViewModel>(null as any);
    }

    /**
     * Delete a role
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: string | null | undefined, x_Api_Version: string | null | undefined): Promise<RoleViewModel> {
        let url_ = this.baseUrl + "/api/Roles/Delete?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<RoleViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleViewModel>(null as any);
    }

    /**
     * Get permissions claims on the system
     * @param x_Api_Version (optional) 
     */
    getAllPermissions(x_Api_Version: string | null | undefined): Promise<PermissionViewModel[]> {
        let url_ = this.baseUrl + "/api/Roles/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllPermissions(_response));
        });
    }

    protected processGetAllPermissions(response: Response): Promise<PermissionViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionViewModel[]>(null as any);
    }
}

export interface IServicesClient {

    /**
     * Get a service by id
     * @param stpdId (optional) The service id
     * @param x_Api_Version (optional) 
     * @return The service
     */
    get(stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel>;

    /**
     * Create a new service
     * @param userId (optional) The user id
     * @param projectId (optional) Project id
     * @param x_Api_Version (optional) 
     * @param stpd Service id
     * @return The service
     */
    create(userId: string | null | undefined, projectId: number | undefined, x_Api_Version: string | null | undefined, stpd: ParameterDefViewModel): Promise<ParameterDefViewModel>;

    /**
     * Initialize a service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param classId (optional) The class id
     * @param x_Api_Version (optional) 
     */
    initialize(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, classId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel>;

    /**
     * Change a service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param newstdpId (optional) New service Id
     * @param x_Api_Version (optional) 
     */
    change(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, newstdpId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;

    /**
     * Move a service to another project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param toProjectId (optional) 
     * @param x_Api_Version (optional) 
     */
    move(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, toProjectId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;

    /**
     * Build definition keys after training
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param x_Api_Version (optional) 
     */
    createDefinitionResults(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceEventViewModel[]>;

    /**
     * Train service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param forceRetraining (optional) 
     * @param x_Api_Version (optional) 
     */
    train(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, forceRetraining: boolean | undefined, x_Api_Version: string | null | undefined): Promise<ServiceEventViewModel[]>;

    /**
     * Save custom training
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param stpdId (optional) 
     * @param docId (optional) 
     * @param x_Api_Version (optional) 
     */
    saveCustomTraining(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, docId: number | undefined, x_Api_Version: string | null | undefined, parameters: DocumentParameterViewModel[]): Promise<DocumentParameterViewModel[]>;

    /**
     * Get custom training parameters
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param stpdId (optional) 
     * @param docId (optional) 
     * @param x_Api_Version (optional) 
     */
    getCustomTraining(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, docId: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel[]>;

    /**
     * Get custom training fields
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param stpdId (optional) 
     * @param classId (optional) 
     * @param x_Api_Version (optional) 
     */
    getCustomTrainingFields(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, classId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]>;

    /**
     * Delete custom training parameters
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param stpdId (optional) 
     * @param docId (optional) 
     * @param parId (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteCustomTraining(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, docId: number | undefined, parId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel[]>;

    /**
     * Get training report
     * @param projectId (optional) The project id
     * @param stpdId (optional) The service id
     * @param classId (optional) Optional class id
     * @param x_Api_Version (optional) 
     * @return The result
     */
    getTrainingReport(projectId: number | undefined, stpdId: number | undefined, classId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]>;

    /**
     * Process service documents
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param documentIds (optional) 
     * @param force (optional) 
     * @param deleteChildDocs (optional) 
     * @param deleteChildDocsRecursive (optional) 
     * @param deletePreviousOutputDocs (optional) 
     * @param resetResults (optional) 
     * @param resetComments (optional) 
     * @param resumeIdentifier (optional) 
     * @param queueProcessing (optional) 
     * @param x_Api_Version (optional) 
     */
    process(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, documentIds: number[] | null | undefined, force: boolean | undefined, deleteChildDocs: boolean | undefined, deleteChildDocsRecursive: boolean | undefined, deletePreviousOutputDocs: boolean | undefined, resetResults: boolean | undefined, resetComments: boolean | undefined, resumeIdentifier: string | null | undefined, queueProcessing: boolean | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]>;

    /**
     * Get related users
     * @param userId (optional) The user id
     * @param includeBalances (optional) 
     * @param projectId (optional) 
     * @param serviceId (optional) 
     * @param x_Api_Version (optional) 
     */
    getRelatedUsers(userId: string | null | undefined, includeBalances: boolean | undefined, projectId: number | null | undefined, serviceId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]>;

    /**
     * Get all service types.  You can use a serice interface filter
     * @param puId (optional) 
     * @param x_Api_Version (optional) 
     */
    getConstraints(puId: number | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserConstraintViewModel[]>;

    createConstraints(x_Api_Version: string | null | undefined, constraint: ProjectUserConstraintViewModel): Promise<ProjectUserConstraintViewModel>;

    /**
     * Update service type charge.
     * @param x_Api_Version (optional) 
     */
    updateConstraints(x_Api_Version: string | null | undefined, constraint: ProjectUserConstraintViewModel): Promise<ProjectUserConstraintViewModel>;

    /**
     * Delete service type charge.
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteConstraints(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserConstraintViewModel>;

    /**
     * Get service balances
     * @param userId (optional) The user id
     * @param stl (optional) 
     * @param stpdId (optional) Service id
     * @param projectId (optional) The project id
     * @param allRelated (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param x_Api_Version (optional) 
     */
    getBalances(userId: string | null | undefined, stl: number | null | undefined, stpdId: number | null | undefined, projectId: number | null | undefined, allRelated: boolean | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, x_Api_Version: string | null | undefined): Promise<AccountBalanceItem[]>;

    /**
     * Get the balance for a service
     * @param userId (optional) The user id
     * @param stl (optional) 
     * @param stpdId (optional) Service id
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     */
    getBalance(userId: string | null | undefined, stl: number | null | undefined, stpdId: number | null | undefined, projectId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<number | null>;

    /**
     * Get audit transaction for service usage
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param interval (optional) 
     * @param x_Api_Version (optional) 
     */
    getAudit(userId: string | null | undefined, projectId: number | null | undefined, stpdId: number | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, interval: string | null | undefined, x_Api_Version: string | null | undefined): Promise<TransactionsAuditViewModel[]>;

    /**
     * Get events for a service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param x_Api_Version (optional) 
     */
    getEvents(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, x_Api_Version: string | null | undefined): Promise<ServiceEventViewModel[]>;

    /**
     * Get all service types.  You can use a serice interface filter
     * @param stpdId (optional) 
     * @param x_Api_Version (optional) 
     */
    getCharges(stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceChargeViewModel[]>;

    createCharge(x_Api_Version: string | null | undefined, charge: ServiceChargeViewModel): Promise<ServiceChargeViewModel>;

    /**
     * Update service type charge.
     * @param x_Api_Version (optional) 
     */
    updateCharge(x_Api_Version: string | null | undefined, charge: ServiceChargeViewModel): Promise<ServiceChargeViewModel>;

    /**
     * Delete service type charge.
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteCharge(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceChargeViewModel>;

    /**
     * Find References to a Service
     * @param stpdId (optional) Service id
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    findServiceReferences(stpdId: number | undefined, id: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]>;

    /**
     * Clone a service to new project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param toProjectId (optional) 
     * @param x_Api_Version (optional) 
     */
    clone(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, toProjectId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;

    /**
     * Clone a service to new project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param stId (optional) 
     * @param x_Api_Version (optional) 
     */
    changeServiceType(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, stId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;
}

export class ServicesClient extends AIForgedBase implements IServicesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get a service by id
     * @param stpdId (optional) The service id
     * @param x_Api_Version (optional) 
     * @return The service
     */
    get(stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel> {
        let url_ = this.baseUrl + "/api/Services/Get?";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<ParameterDefViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel>(null as any);
    }

    /**
     * Create a new service
     * @param userId (optional) The user id
     * @param projectId (optional) Project id
     * @param x_Api_Version (optional) 
     * @param stpd Service id
     * @return The service
     */
    create(userId: string | null | undefined, projectId: number | undefined, x_Api_Version: string | null | undefined, stpd: ParameterDefViewModel): Promise<ParameterDefViewModel> {
        let url_ = this.baseUrl + "/api/Services/Create?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stpd);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<ParameterDefViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel>(null as any);
    }

    /**
     * Initialize a service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param classId (optional) The class id
     * @param x_Api_Version (optional) 
     */
    initialize(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, classId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel> {
        let url_ = this.baseUrl + "/api/Services/Initialize?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (classId !== undefined && classId !== null)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processInitialize(_response));
        });
    }

    protected processInitialize(response: Response): Promise<ParameterDefViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterDefViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel>(null as any);
    }

    /**
     * Change a service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param newstdpId (optional) New service Id
     * @param x_Api_Version (optional) 
     */
    change(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, newstdpId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Services/Change?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (newstdpId === null)
            throw new Error("The parameter 'newstdpId' cannot be null.");
        else if (newstdpId !== undefined)
            url_ += "newstdpId=" + encodeURIComponent("" + newstdpId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processChange(_response));
        });
    }

    protected processChange(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Move a service to another project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param toProjectId (optional) 
     * @param x_Api_Version (optional) 
     */
    move(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, toProjectId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Services/Move?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (toProjectId === null)
            throw new Error("The parameter 'toProjectId' cannot be null.");
        else if (toProjectId !== undefined)
            url_ += "toProjectId=" + encodeURIComponent("" + toProjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMove(_response));
        });
    }

    protected processMove(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Build definition keys after training
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param x_Api_Version (optional) 
     */
    createDefinitionResults(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceEventViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/CreateDefinitionResults?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateDefinitionResults(_response));
        });
    }

    protected processCreateDefinitionResults(response: Response): Promise<ServiceEventViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceEventViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceEventViewModel[]>(null as any);
    }

    /**
     * Train service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param forceRetraining (optional) 
     * @param x_Api_Version (optional) 
     */
    train(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, forceRetraining: boolean | undefined, x_Api_Version: string | null | undefined): Promise<ServiceEventViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/Train?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (forceRetraining === null)
            throw new Error("The parameter 'forceRetraining' cannot be null.");
        else if (forceRetraining !== undefined)
            url_ += "forceRetraining=" + encodeURIComponent("" + forceRetraining) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTrain(_response));
        });
    }

    protected processTrain(response: Response): Promise<ServiceEventViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceEventViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceEventViewModel[]>(null as any);
    }

    /**
     * Save custom training
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param stpdId (optional) 
     * @param docId (optional) 
     * @param x_Api_Version (optional) 
     */
    saveCustomTraining(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, docId: number | undefined, x_Api_Version: string | null | undefined, parameters: DocumentParameterViewModel[]): Promise<DocumentParameterViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/SaveCustomTraining?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(parameters);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSaveCustomTraining(_response));
        });
    }

    protected processSaveCustomTraining(response: Response): Promise<DocumentParameterViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentParameterViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentParameterViewModel[]>(null as any);
    }

    /**
     * Get custom training parameters
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param stpdId (optional) 
     * @param docId (optional) 
     * @param x_Api_Version (optional) 
     */
    getCustomTraining(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, docId: number | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/GetCustomTraining?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCustomTraining(_response));
        });
    }

    protected processGetCustomTraining(response: Response): Promise<DocumentParameterViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentParameterViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentParameterViewModel[]>(null as any);
    }

    /**
     * Get custom training fields
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param stpdId (optional) 
     * @param classId (optional) 
     * @param x_Api_Version (optional) 
     */
    getCustomTrainingFields(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, classId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/GetCustomTrainingFields?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (classId !== undefined && classId !== null)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCustomTrainingFields(_response));
        });
    }

    protected processGetCustomTrainingFields(response: Response): Promise<ParameterDefViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParameterDefViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel[]>(null as any);
    }

    /**
     * Delete custom training parameters
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param stpdId (optional) 
     * @param docId (optional) 
     * @param parId (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteCustomTraining(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, docId: number | undefined, parId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentParameterViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/DeleteCustomTraining?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (parId !== undefined && parId !== null)
            url_ += "parId=" + encodeURIComponent("" + parId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteCustomTraining(_response));
        });
    }

    protected processDeleteCustomTraining(response: Response): Promise<DocumentParameterViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentParameterViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentParameterViewModel[]>(null as any);
    }

    /**
     * Get training report
     * @param projectId (optional) The project id
     * @param stpdId (optional) The service id
     * @param classId (optional) Optional class id
     * @param x_Api_Version (optional) 
     * @return The result
     */
    getTrainingReport(projectId: number | undefined, stpdId: number | undefined, classId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/GetTrainingReport?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (classId !== undefined && classId !== null)
            url_ += "classId=" + encodeURIComponent("" + classId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetTrainingReport(_response));
        });
    }

    protected processGetTrainingReport(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * Process service documents
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param documentIds (optional) 
     * @param force (optional) 
     * @param deleteChildDocs (optional) 
     * @param deleteChildDocsRecursive (optional) 
     * @param deletePreviousOutputDocs (optional) 
     * @param resetResults (optional) 
     * @param resetComments (optional) 
     * @param resumeIdentifier (optional) 
     * @param queueProcessing (optional) 
     * @param x_Api_Version (optional) 
     */
    process(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, documentIds: number[] | null | undefined, force: boolean | undefined, deleteChildDocs: boolean | undefined, deleteChildDocsRecursive: boolean | undefined, deletePreviousOutputDocs: boolean | undefined, resetResults: boolean | undefined, resetComments: boolean | undefined, resumeIdentifier: string | null | undefined, queueProcessing: boolean | undefined, x_Api_Version: string | null | undefined): Promise<DocumentViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/Process?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (documentIds !== undefined && documentIds !== null)
            documentIds && documentIds.forEach(item => { url_ += "documentIds=" + encodeURIComponent("" + item) + "&"; });
        if (force === null)
            throw new Error("The parameter 'force' cannot be null.");
        else if (force !== undefined)
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        if (deleteChildDocs === null)
            throw new Error("The parameter 'deleteChildDocs' cannot be null.");
        else if (deleteChildDocs !== undefined)
            url_ += "deleteChildDocs=" + encodeURIComponent("" + deleteChildDocs) + "&";
        if (deleteChildDocsRecursive === null)
            throw new Error("The parameter 'deleteChildDocsRecursive' cannot be null.");
        else if (deleteChildDocsRecursive !== undefined)
            url_ += "deleteChildDocsRecursive=" + encodeURIComponent("" + deleteChildDocsRecursive) + "&";
        if (deletePreviousOutputDocs === null)
            throw new Error("The parameter 'deletePreviousOutputDocs' cannot be null.");
        else if (deletePreviousOutputDocs !== undefined)
            url_ += "deletePreviousOutputDocs=" + encodeURIComponent("" + deletePreviousOutputDocs) + "&";
        if (resetResults === null)
            throw new Error("The parameter 'resetResults' cannot be null.");
        else if (resetResults !== undefined)
            url_ += "resetResults=" + encodeURIComponent("" + resetResults) + "&";
        if (resetComments === null)
            throw new Error("The parameter 'resetComments' cannot be null.");
        else if (resetComments !== undefined)
            url_ += "resetComments=" + encodeURIComponent("" + resetComments) + "&";
        if (resumeIdentifier !== undefined && resumeIdentifier !== null)
            url_ += "resumeIdentifier=" + encodeURIComponent("" + resumeIdentifier) + "&";
        if (queueProcessing === null)
            throw new Error("The parameter 'queueProcessing' cannot be null.");
        else if (queueProcessing !== undefined)
            url_ += "queueProcessing=" + encodeURIComponent("" + queueProcessing) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processProcess(_response));
        });
    }

    protected processProcess(response: Response): Promise<DocumentViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentViewModel[]>(null as any);
    }

    /**
     * Get related users
     * @param userId (optional) The user id
     * @param includeBalances (optional) 
     * @param projectId (optional) 
     * @param serviceId (optional) 
     * @param x_Api_Version (optional) 
     */
    getRelatedUsers(userId: string | null | undefined, includeBalances: boolean | undefined, projectId: number | null | undefined, serviceId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/GetRelatedUsers?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (includeBalances === null)
            throw new Error("The parameter 'includeBalances' cannot be null.");
        else if (includeBalances !== undefined)
            url_ += "includeBalances=" + encodeURIComponent("" + includeBalances) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (serviceId !== undefined && serviceId !== null)
            url_ += "serviceId=" + encodeURIComponent("" + serviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetRelatedUsers(_response));
        });
    }

    protected processGetRelatedUsers(response: Response): Promise<ProjectUserViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectUserViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserViewModel[]>(null as any);
    }

    /**
     * Get all service types.  You can use a serice interface filter
     * @param puId (optional) 
     * @param x_Api_Version (optional) 
     */
    getConstraints(puId: number | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserConstraintViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/GetConstraints?";
        if (puId === null)
            throw new Error("The parameter 'puId' cannot be null.");
        else if (puId !== undefined)
            url_ += "puId=" + encodeURIComponent("" + puId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetConstraints(_response));
        });
    }

    protected processGetConstraints(response: Response): Promise<ProjectUserConstraintViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectUserConstraintViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserConstraintViewModel[]>(null as any);
    }

    createConstraints(x_Api_Version: string | null | undefined, constraint: ProjectUserConstraintViewModel): Promise<ProjectUserConstraintViewModel> {
        let url_ = this.baseUrl + "/api/Services/CreateConstraint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(constraint);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateConstraints(_response));
        });
    }

    protected processCreateConstraints(response: Response): Promise<ProjectUserConstraintViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectUserConstraintViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserConstraintViewModel>(null as any);
    }

    /**
     * Update service type charge.
     * @param x_Api_Version (optional) 
     */
    updateConstraints(x_Api_Version: string | null | undefined, constraint: ProjectUserConstraintViewModel): Promise<ProjectUserConstraintViewModel> {
        let url_ = this.baseUrl + "/api/Services/UpdateConstraint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(constraint);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateConstraints(_response));
        });
    }

    protected processUpdateConstraints(response: Response): Promise<ProjectUserConstraintViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectUserConstraintViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserConstraintViewModel>(null as any);
    }

    /**
     * Delete service type charge.
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteConstraints(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ProjectUserConstraintViewModel> {
        let url_ = this.baseUrl + "/api/Services/DeleteConstraint?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteConstraints(_response));
        });
    }

    protected processDeleteConstraints(response: Response): Promise<ProjectUserConstraintViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectUserConstraintViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectUserConstraintViewModel>(null as any);
    }

    /**
     * Get service balances
     * @param userId (optional) The user id
     * @param stl (optional) 
     * @param stpdId (optional) Service id
     * @param projectId (optional) The project id
     * @param allRelated (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param x_Api_Version (optional) 
     */
    getBalances(userId: string | null | undefined, stl: number | null | undefined, stpdId: number | null | undefined, projectId: number | null | undefined, allRelated: boolean | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, x_Api_Version: string | null | undefined): Promise<AccountBalanceItem[]> {
        let url_ = this.baseUrl + "/api/Services/GetBalances?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (stl !== undefined && stl !== null)
            url_ += "stl=" + encodeURIComponent("" + stl) + "&";
        if (stpdId !== undefined && stpdId !== null)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (allRelated !== undefined && allRelated !== null)
            url_ += "allRelated=" + encodeURIComponent("" + allRelated) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetBalances(_response));
        });
    }

    protected processGetBalances(response: Response): Promise<AccountBalanceItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AccountBalanceItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccountBalanceItem[]>(null as any);
    }

    /**
     * Get the balance for a service
     * @param userId (optional) The user id
     * @param stl (optional) 
     * @param stpdId (optional) Service id
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     */
    getBalance(userId: string | null | undefined, stl: number | null | undefined, stpdId: number | null | undefined, projectId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<number | null> {
        let url_ = this.baseUrl + "/api/Services/GetBalance?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (stl !== undefined && stl !== null)
            url_ += "stl=" + encodeURIComponent("" + stl) + "&";
        if (stpdId !== undefined && stpdId !== null)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetBalance(_response));
        });
    }

    protected processGetBalance(response: Response): Promise<number | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number | null>(null as any);
    }

    /**
     * Get audit transaction for service usage
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param interval (optional) 
     * @param x_Api_Version (optional) 
     */
    getAudit(userId: string | null | undefined, projectId: number | null | undefined, stpdId: number | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, interval: string | null | undefined, x_Api_Version: string | null | undefined): Promise<TransactionsAuditViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/GetAudit?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId !== undefined && stpdId !== null)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (interval !== undefined && interval !== null)
            url_ += "interval=" + encodeURIComponent("" + interval) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAudit(_response));
        });
    }

    protected processGetAudit(response: Response): Promise<TransactionsAuditViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionsAuditViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionsAuditViewModel[]>(null as any);
    }

    /**
     * Get events for a service
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param x_Api_Version (optional) 
     */
    getEvents(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, x_Api_Version: string | null | undefined): Promise<ServiceEventViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/GetEvents?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetEvents(_response));
        });
    }

    protected processGetEvents(response: Response): Promise<ServiceEventViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceEventViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceEventViewModel[]>(null as any);
    }

    /**
     * Get all service types.  You can use a serice interface filter
     * @param stpdId (optional) 
     * @param x_Api_Version (optional) 
     */
    getCharges(stpdId: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceChargeViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/GetCharges?";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCharges(_response));
        });
    }

    protected processGetCharges(response: Response): Promise<ServiceChargeViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceChargeViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceChargeViewModel[]>(null as any);
    }

    createCharge(x_Api_Version: string | null | undefined, charge: ServiceChargeViewModel): Promise<ServiceChargeViewModel> {
        let url_ = this.baseUrl + "/api/Services/CreateCharge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(charge);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateCharge(_response));
        });
    }

    protected processCreateCharge(response: Response): Promise<ServiceChargeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceChargeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceChargeViewModel>(null as any);
    }

    /**
     * Update service type charge.
     * @param x_Api_Version (optional) 
     */
    updateCharge(x_Api_Version: string | null | undefined, charge: ServiceChargeViewModel): Promise<ServiceChargeViewModel> {
        let url_ = this.baseUrl + "/api/Services/UpdateCharge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(charge);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateCharge(_response));
        });
    }

    protected processUpdateCharge(response: Response): Promise<ServiceChargeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceChargeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceChargeViewModel>(null as any);
    }

    /**
     * Delete service type charge.
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteCharge(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceChargeViewModel> {
        let url_ = this.baseUrl + "/api/Services/DeleteCharge?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteCharge(_response));
        });
    }

    protected processDeleteCharge(response: Response): Promise<ServiceChargeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceChargeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceChargeViewModel>(null as any);
    }

    /**
     * Find References to a Service
     * @param stpdId (optional) Service id
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    findServiceReferences(stpdId: number | undefined, id: number | undefined, x_Api_Version: string | null | undefined): Promise<ParameterDefViewModel[]> {
        let url_ = this.baseUrl + "/api/Services/FindServiceReferences?";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processFindServiceReferences(_response));
        });
    }

    protected processFindServiceReferences(response: Response): Promise<ParameterDefViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParameterDefViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParameterDefViewModel[]>(null as any);
    }

    /**
     * Clone a service to new project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param toProjectId (optional) 
     * @param x_Api_Version (optional) 
     */
    clone(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, toProjectId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Services/Clone?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (toProjectId === null)
            throw new Error("The parameter 'toProjectId' cannot be null.");
        else if (toProjectId !== undefined)
            url_ += "toProjectId=" + encodeURIComponent("" + toProjectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processClone(_response));
        });
    }

    protected processClone(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Clone a service to new project
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param stId (optional) 
     * @param x_Api_Version (optional) 
     */
    changeServiceType(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, stId: number | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Services/ChangeServiceType?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (stId === null)
            throw new Error("The parameter 'stId' cannot be null.");
        else if (stId !== undefined)
            url_ += "stId=" + encodeURIComponent("" + stId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processChangeServiceType(_response));
        });
    }

    protected processChangeServiceType(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface IServiceTypeClient {

    /**
     * Get all service types.  You can use a serice interface filter
     * @param enginefilter (optional) 
     * @param x_Api_Version (optional) 
     */
    getAll(enginefilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ServiceTypeViewModel[]>;

    /**
     * Create a new service type
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, service: ServiceTypeViewModel): Promise<ServiceTypeViewModel>;

    /**
     * Update a service type
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, service: ServiceTypeViewModel): Promise<ServiceTypeViewModel>;

    /**
     * Delete a service type
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceTypeViewModel>;

    /**
     * Get all service types and charges.
     * @param x_Api_Version (optional) 
     */
    getAllCharges(x_Api_Version: string | null | undefined): Promise<ServiceTypeChargeViewModel[]>;

    /**
     * Get all service types.  You can use a serice interface filter
     * @param serviceTypeId (optional) 
     * @param x_Api_Version (optional) 
     */
    getCharges(serviceTypeId: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceTypeChargeViewModel[]>;

    createCharge(x_Api_Version: string | null | undefined, charge: ServiceTypeChargeViewModel): Promise<ServiceTypeChargeViewModel>;

    /**
     * Update service type charge.
     * @param x_Api_Version (optional) 
     */
    updateCharge(x_Api_Version: string | null | undefined, charge: ServiceTypeChargeViewModel): Promise<ServiceTypeChargeViewModel>;

    /**
     * Delete service type charge.
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteCharge(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceTypeChargeViewModel>;
}

export class ServiceTypeClient extends AIForgedBase implements IServiceTypeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get all service types.  You can use a serice interface filter
     * @param enginefilter (optional) 
     * @param x_Api_Version (optional) 
     */
    getAll(enginefilter: string | null | undefined, x_Api_Version: string | null | undefined): Promise<ServiceTypeViewModel[]> {
        let url_ = this.baseUrl + "/api/ServiceType/GetAll?";
        if (enginefilter !== undefined && enginefilter !== null)
            url_ += "enginefilter=" + encodeURIComponent("" + enginefilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<ServiceTypeViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceTypeViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceTypeViewModel[]>(null as any);
    }

    /**
     * Create a new service type
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, service: ServiceTypeViewModel): Promise<ServiceTypeViewModel> {
        let url_ = this.baseUrl + "/api/ServiceType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(service);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<ServiceTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceTypeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceTypeViewModel>(null as any);
    }

    /**
     * Update a service type
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, service: ServiceTypeViewModel): Promise<ServiceTypeViewModel> {
        let url_ = this.baseUrl + "/api/ServiceType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(service);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<ServiceTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceTypeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceTypeViewModel>(null as any);
    }

    /**
     * Delete a service type
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceTypeViewModel> {
        let url_ = this.baseUrl + "/api/ServiceType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<ServiceTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceTypeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceTypeViewModel>(null as any);
    }

    /**
     * Get all service types and charges.
     * @param x_Api_Version (optional) 
     */
    getAllCharges(x_Api_Version: string | null | undefined): Promise<ServiceTypeChargeViewModel[]> {
        let url_ = this.baseUrl + "/api/ServiceType/GetAllCharges";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllCharges(_response));
        });
    }

    protected processGetAllCharges(response: Response): Promise<ServiceTypeChargeViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceTypeChargeViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceTypeChargeViewModel[]>(null as any);
    }

    /**
     * Get all service types.  You can use a serice interface filter
     * @param serviceTypeId (optional) 
     * @param x_Api_Version (optional) 
     */
    getCharges(serviceTypeId: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceTypeChargeViewModel[]> {
        let url_ = this.baseUrl + "/api/ServiceType/GetCharges?";
        if (serviceTypeId === null)
            throw new Error("The parameter 'serviceTypeId' cannot be null.");
        else if (serviceTypeId !== undefined)
            url_ += "serviceTypeId=" + encodeURIComponent("" + serviceTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCharges(_response));
        });
    }

    protected processGetCharges(response: Response): Promise<ServiceTypeChargeViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceTypeChargeViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceTypeChargeViewModel[]>(null as any);
    }

    createCharge(x_Api_Version: string | null | undefined, charge: ServiceTypeChargeViewModel): Promise<ServiceTypeChargeViewModel> {
        let url_ = this.baseUrl + "/api/ServiceType/CreateCharge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(charge);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateCharge(_response));
        });
    }

    protected processCreateCharge(response: Response): Promise<ServiceTypeChargeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceTypeChargeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceTypeChargeViewModel>(null as any);
    }

    /**
     * Update service type charge.
     * @param x_Api_Version (optional) 
     */
    updateCharge(x_Api_Version: string | null | undefined, charge: ServiceTypeChargeViewModel): Promise<ServiceTypeChargeViewModel> {
        let url_ = this.baseUrl + "/api/ServiceType/UpdateCharge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(charge);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateCharge(_response));
        });
    }

    protected processUpdateCharge(response: Response): Promise<ServiceTypeChargeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceTypeChargeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceTypeChargeViewModel>(null as any);
    }

    /**
     * Delete service type charge.
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteCharge(id: number | undefined, x_Api_Version: string | null | undefined): Promise<ServiceTypeChargeViewModel> {
        let url_ = this.baseUrl + "/api/ServiceType/DeleteCharge?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteCharge(_response));
        });
    }

    protected processDeleteCharge(response: Response): Promise<ServiceTypeChargeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceTypeChargeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceTypeChargeViewModel>(null as any);
    }
}

export interface ISystemClient {

    /**
     * Get the current service Data and Time
     * @param x_Api_Version (optional) 
     * @return The system date
     */
    getSystemDate(x_Api_Version: string | null | undefined): Promise<Date>;

    /**
     * Get system and application information
     * @param x_Api_Version (optional) 
     * @return Application info
     */
    getSystemInfo(x_Api_Version: string | null | undefined): Promise<{ [key: string]: string; }>;

    /**
     * Get data types
     * @param x_Api_Version (optional) 
     * @return List of data typs
     */
    getDataTypes(x_Api_Version: string | null | undefined): Promise<DataTypeViewModel[]>;

    /**
     * Get value types
     * @param vt (optional) 
     * @param vtname (optional) 
     * @param x_Api_Version (optional) 
     */
    getDataTypeInfo(vt: ValueType | undefined, vtname: string | null | undefined, x_Api_Version: string | null | undefined): Promise<DataTypeViewModel>;

    /**
     * Create a new data type
     * @param x_Api_Version (optional) 
     */
    createDataType(x_Api_Version: string | null | undefined, data: DataTypeViewModel): Promise<DataTypeViewModel>;

    /**
     * Update a datatype
     * @param x_Api_Version (optional) 
     */
    updateDataType(x_Api_Version: string | null | undefined, data: DataTypeViewModel): Promise<DataTypeViewModel>;

    /**
     * Delete a datatype
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteDataType(id: ValueType | undefined, x_Api_Version: string | null | undefined): Promise<DataTypeViewModel>;

    /**
     * Get system enum values
     * @param x_Api_Version (optional) 
     * @return List of system enums
     */
    getEnumData(x_Api_Version: string | null | undefined): Promise<EnumDataViewModel[]>;

    /**
     * create a new system enum
     * @param x_Api_Version (optional) 
     */
    createEnumData(x_Api_Version: string | null | undefined, data: EnumDataViewModel): Promise<EnumDataViewModel>;

    /**
     * Update system enum
     * @param x_Api_Version (optional) 
     */
    updateEnumData(x_Api_Version: string | null | undefined, data: EnumDataViewModel): Promise<EnumDataViewModel>;

    /**
     * Delete a system enum
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteEnumData(id: number | undefined, x_Api_Version: string | null | undefined): Promise<EnumDataViewModel>;

    getEnumOptions(name: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string[]>;

    /**
     * API to expose background worker items
     * @param x_Api_Version (optional) 
     */
    getBackgroundWorkerItem(x_Api_Version: string | null | undefined): Promise<BackgoundWorkItem>;

    /**
     * Dummy to expose event logs
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    getLogs(id: string | undefined, x_Api_Version: string | null | undefined): Promise<LogEvent[]>;

    /**
     * Dummy to expose event logs
     * @param x_Api_Version (optional) 
     */
    checkServices(x_Api_Version: string | null | undefined): Promise<string>;
}

export class SystemClient extends AIForgedBase implements ISystemClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get the current service Data and Time
     * @param x_Api_Version (optional) 
     * @return The system date
     */
    getSystemDate(x_Api_Version: string | null | undefined): Promise<Date> {
        let url_ = this.baseUrl + "/api/System/GetSystemDate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetSystemDate(_response));
        });
    }

    protected processGetSystemDate(response: Response): Promise<Date> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? new Date(resultData200.toString()) : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Date>(null as any);
    }

    /**
     * Get system and application information
     * @param x_Api_Version (optional) 
     * @return Application info
     */
    getSystemInfo(x_Api_Version: string | null | undefined): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/System/GetSystemInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetSystemInfo(_response));
        });
    }

    protected processGetSystemInfo(response: Response): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string; }>(null as any);
    }

    /**
     * Get data types
     * @param x_Api_Version (optional) 
     * @return List of data typs
     */
    getDataTypes(x_Api_Version: string | null | undefined): Promise<DataTypeViewModel[]> {
        let url_ = this.baseUrl + "/api/System/GetDataTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetDataTypes(_response));
        });
    }

    protected processGetDataTypes(response: Response): Promise<DataTypeViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataTypeViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataTypeViewModel[]>(null as any);
    }

    /**
     * Get value types
     * @param vt (optional) 
     * @param vtname (optional) 
     * @param x_Api_Version (optional) 
     */
    getDataTypeInfo(vt: ValueType | undefined, vtname: string | null | undefined, x_Api_Version: string | null | undefined): Promise<DataTypeViewModel> {
        let url_ = this.baseUrl + "/api/System/GetDataTypeInfo?";
        if (vt === null)
            throw new Error("The parameter 'vt' cannot be null.");
        else if (vt !== undefined)
            url_ += "vt=" + encodeURIComponent("" + vt) + "&";
        if (vtname !== undefined && vtname !== null)
            url_ += "vtname=" + encodeURIComponent("" + vtname) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetDataTypeInfo(_response));
        });
    }

    protected processGetDataTypeInfo(response: Response): Promise<DataTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataTypeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataTypeViewModel>(null as any);
    }

    /**
     * Create a new data type
     * @param x_Api_Version (optional) 
     */
    createDataType(x_Api_Version: string | null | undefined, data: DataTypeViewModel): Promise<DataTypeViewModel> {
        let url_ = this.baseUrl + "/api/System/CreateDataType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateDataType(_response));
        });
    }

    protected processCreateDataType(response: Response): Promise<DataTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataTypeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataTypeViewModel>(null as any);
    }

    /**
     * Update a datatype
     * @param x_Api_Version (optional) 
     */
    updateDataType(x_Api_Version: string | null | undefined, data: DataTypeViewModel): Promise<DataTypeViewModel> {
        let url_ = this.baseUrl + "/api/System/UpdateDataType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateDataType(_response));
        });
    }

    protected processUpdateDataType(response: Response): Promise<DataTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataTypeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataTypeViewModel>(null as any);
    }

    /**
     * Delete a datatype
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteDataType(id: ValueType | undefined, x_Api_Version: string | null | undefined): Promise<DataTypeViewModel> {
        let url_ = this.baseUrl + "/api/System/DeleteDataType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteDataType(_response));
        });
    }

    protected processDeleteDataType(response: Response): Promise<DataTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataTypeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataTypeViewModel>(null as any);
    }

    /**
     * Get system enum values
     * @param x_Api_Version (optional) 
     * @return List of system enums
     */
    getEnumData(x_Api_Version: string | null | undefined): Promise<EnumDataViewModel[]> {
        let url_ = this.baseUrl + "/api/System/GetEnumData";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetEnumData(_response));
        });
    }

    protected processGetEnumData(response: Response): Promise<EnumDataViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnumDataViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnumDataViewModel[]>(null as any);
    }

    /**
     * create a new system enum
     * @param x_Api_Version (optional) 
     */
    createEnumData(x_Api_Version: string | null | undefined, data: EnumDataViewModel): Promise<EnumDataViewModel> {
        let url_ = this.baseUrl + "/api/System/CreateEnumData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateEnumData(_response));
        });
    }

    protected processCreateEnumData(response: Response): Promise<EnumDataViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnumDataViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnumDataViewModel>(null as any);
    }

    /**
     * Update system enum
     * @param x_Api_Version (optional) 
     */
    updateEnumData(x_Api_Version: string | null | undefined, data: EnumDataViewModel): Promise<EnumDataViewModel> {
        let url_ = this.baseUrl + "/api/System/UpdateEnumData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateEnumData(_response));
        });
    }

    protected processUpdateEnumData(response: Response): Promise<EnumDataViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnumDataViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnumDataViewModel>(null as any);
    }

    /**
     * Delete a system enum
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    deleteEnumData(id: number | undefined, x_Api_Version: string | null | undefined): Promise<EnumDataViewModel> {
        let url_ = this.baseUrl + "/api/System/DeleteEnumData?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteEnumData(_response));
        });
    }

    protected processDeleteEnumData(response: Response): Promise<EnumDataViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnumDataViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnumDataViewModel>(null as any);
    }

    getEnumOptions(name: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/System/GetEnumOptions?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetEnumOptions(_response));
        });
    }

    protected processGetEnumOptions(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * API to expose background worker items
     * @param x_Api_Version (optional) 
     */
    getBackgroundWorkerItem(x_Api_Version: string | null | undefined): Promise<BackgoundWorkItem> {
        let url_ = this.baseUrl + "/api/System/GetBackgroundWorkerItem";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetBackgroundWorkerItem(_response));
        });
    }

    protected processGetBackgroundWorkerItem(response: Response): Promise<BackgoundWorkItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BackgoundWorkItem.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BackgoundWorkItem>(null as any);
    }

    /**
     * Dummy to expose event logs
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    getLogs(id: string | undefined, x_Api_Version: string | null | undefined): Promise<LogEvent[]> {
        let url_ = this.baseUrl + "/api/System/GetLogs?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetLogs(_response));
        });
    }

    protected processGetLogs(response: Response): Promise<LogEvent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LogEvent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogEvent[]>(null as any);
    }

    /**
     * Dummy to expose event logs
     * @param x_Api_Version (optional) 
     */
    checkServices(x_Api_Version: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/System/CheckServices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCheckServices(_response));
        });
    }

    protected processCheckServices(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export interface IUserGroupClient {

    /**
     * Get by id
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    get(id: number | undefined, x_Api_Version: string | null | undefined): Promise<UserGroupViewModel>;

    /**
     * Get by users
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    getByUser(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserGroupViewModel[]>;

    /**
     * Create usergroup
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, group: UserGroupViewModel): Promise<UserGroupViewModel>;

    /**
     * Update group
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, group: UserGroupViewModel): Promise<UserGroupViewModel>;

    /**
     * Delete
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<UserGroupViewModel>;
}

export class UserGroupClient extends AIForgedBase implements IUserGroupClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get by id
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    get(id: number | undefined, x_Api_Version: string | null | undefined): Promise<UserGroupViewModel> {
        let url_ = this.baseUrl + "/api/UserGroup/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<UserGroupViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserGroupViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserGroupViewModel>(null as any);
    }

    /**
     * Get by users
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    getByUser(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<UserGroupViewModel[]> {
        let url_ = this.baseUrl + "/api/UserGroup/GetByUser?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetByUser(_response));
        });
    }

    protected processGetByUser(response: Response): Promise<UserGroupViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserGroupViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserGroupViewModel[]>(null as any);
    }

    /**
     * Create usergroup
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, group: UserGroupViewModel): Promise<UserGroupViewModel> {
        let url_ = this.baseUrl + "/api/UserGroup/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(group);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<UserGroupViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserGroupViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserGroupViewModel>(null as any);
    }

    /**
     * Update group
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, group: UserGroupViewModel): Promise<UserGroupViewModel> {
        let url_ = this.baseUrl + "/api/UserGroup/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(group);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<UserGroupViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserGroupViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserGroupViewModel>(null as any);
    }

    /**
     * Delete
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<UserGroupViewModel> {
        let url_ = this.baseUrl + "/api/UserGroup/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<UserGroupViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserGroupViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserGroupViewModel>(null as any);
    }
}

export interface IUserPreferencesClient {

    /**
     * Get the current user preferences
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    get(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string>;

    /**
     * Save current user preferences
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     * @param data In JSon format
     */
    save(userId: string | null | undefined, x_Api_Version: string | null | undefined, data: string): Promise<boolean>;
}

export class UserPreferencesClient extends AIForgedBase implements IUserPreferencesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get the current user preferences
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     */
    get(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/UserPreferences/Get?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Save current user preferences
     * @param userId (optional) 
     * @param x_Api_Version (optional) 
     * @param data In JSon format
     */
    save(userId: string | null | undefined, x_Api_Version: string | null | undefined, data: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/UserPreferences/Save?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSave(_response));
        });
    }

    protected processSave(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface IUserSettingsClient {

    /**
     * Get user setting by name
     * @param userId (optional) 
     * @param name (optional) 
     * @param key (optional) 
     * @param x_Api_Version (optional) 
     */
    get(userId: string | null | undefined, name: string | null | undefined, key: string | null | undefined, x_Api_Version: string | null | undefined): Promise<SettingViewModel>;

    /**
     * Get user settings
     * @param userId (optional) 
     * @param key (optional) 
     * @param onlyKeyValues (optional) 
     * @param x_Api_Version (optional) 
     */
    getAll(userId: string | null | undefined, key: string | null | undefined, onlyKeyValues: boolean | undefined, x_Api_Version: string | null | undefined): Promise<SettingViewModel[]>;

    /**
     * Save a user settings
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, setting: SettingViewModel): Promise<SettingViewModel>;

    /**
     * Update a user settings
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, setting: SettingViewModel): Promise<SettingViewModel>;

    /**
     * Delete a user settings
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<SettingViewModel>;

    /**
     * Get user profile picture
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    getPicture(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;

    /**
     * Get user profile picture
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     * @param file (optional) 
     */
    setPicture(userId: string | null | undefined, x_Api_Version: string | null | undefined, file: FileParameter | null | undefined): Promise<FileResponse>;
}

export class UserSettingsClient extends AIForgedBase implements IUserSettingsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get user setting by name
     * @param userId (optional) 
     * @param name (optional) 
     * @param key (optional) 
     * @param x_Api_Version (optional) 
     */
    get(userId: string | null | undefined, name: string | null | undefined, key: string | null | undefined, x_Api_Version: string | null | undefined): Promise<SettingViewModel> {
        let url_ = this.baseUrl + "/api/UserSettings/Get?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (key !== undefined && key !== null)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<SettingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SettingViewModel>(null as any);
    }

    /**
     * Get user settings
     * @param userId (optional) 
     * @param key (optional) 
     * @param onlyKeyValues (optional) 
     * @param x_Api_Version (optional) 
     */
    getAll(userId: string | null | undefined, key: string | null | undefined, onlyKeyValues: boolean | undefined, x_Api_Version: string | null | undefined): Promise<SettingViewModel[]> {
        let url_ = this.baseUrl + "/api/UserSettings/GetAll?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (key !== undefined && key !== null)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (onlyKeyValues === null)
            throw new Error("The parameter 'onlyKeyValues' cannot be null.");
        else if (onlyKeyValues !== undefined)
            url_ += "onlyKeyValues=" + encodeURIComponent("" + onlyKeyValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<SettingViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SettingViewModel[]>(null as any);
    }

    /**
     * Save a user settings
     * @param x_Api_Version (optional) 
     */
    create(x_Api_Version: string | null | undefined, setting: SettingViewModel): Promise<SettingViewModel> {
        let url_ = this.baseUrl + "/api/UserSettings/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setting);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<SettingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SettingViewModel>(null as any);
    }

    /**
     * Update a user settings
     * @param x_Api_Version (optional) 
     */
    update(x_Api_Version: string | null | undefined, setting: SettingViewModel): Promise<SettingViewModel> {
        let url_ = this.baseUrl + "/api/UserSettings/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setting);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<SettingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SettingViewModel>(null as any);
    }

    /**
     * Delete a user settings
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<SettingViewModel> {
        let url_ = this.baseUrl + "/api/UserSettings/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<SettingViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SettingViewModel>(null as any);
    }

    /**
     * Get user profile picture
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     */
    getPicture(userId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/UserSettings/GetPicture?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPicture(_response));
        });
    }

    protected processGetPicture(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get user profile picture
     * @param userId (optional) The user id
     * @param x_Api_Version (optional) 
     * @param file (optional) 
     */
    setPicture(userId: string | null | undefined, x_Api_Version: string | null | undefined, file: FileParameter | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/UserSettings/SetPicture?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSetPicture(_response));
        });
    }

    protected processSetPicture(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IVerificationClient {

    /**
     * Get a verification by id
     * @param verificationId (optional) Verification id
     * @param x_Api_Version (optional) 
     * @return A verificacation
     */
    get(verificationId: number | undefined, x_Api_Version: string | null | undefined): Promise<VerificationViewModel>;

    /**
     * Get verifications on a parameter
     * @param docId (optional) Document id
     * @param parameterId (optional) Parameter id
     * @param x_Api_Version (optional) 
     * @return A list of verifications
     */
    getAll(docId: number | undefined, parameterId: number | undefined, x_Api_Version: string | null | undefined): Promise<VerificationViewModel[]>;

    /**
     * Get latest verification on a parameter
     * @param docId (optional) Document id
     * @param parameterId (optional) Parameter id
     * @param pdId (optional) Definition id
     * @param x_Api_Version (optional) 
     * @return A verification
     */
    getLatest(docId: number | undefined, parameterId: number | null | undefined, pdId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<VerificationViewModel>;

    /**
     * Rerun verification on a parameter
     * @param docId (optional) The document id
     * @param parameterId (optional) 
     * @param restart (optional) 
     * @param x_Api_Version (optional) 
     */
    rerun(docId: number | undefined, parameterId: number | undefined, restart: boolean | undefined, x_Api_Version: string | null | undefined): Promise<VerificationViewModel[]>;

    /**
     * Rerun verification on a document
     * @param docId (optional) The document id
     * @param restart (optional) 
     * @param x_Api_Version (optional) 
     */
    rerunAll(docId: number | undefined, restart: boolean | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;

    /**
     * Create a list of verifications
     * @param docId (optional) The document id
     * @param x_Api_Version (optional) 
     */
    verify(docId: number | undefined, x_Api_Version: string | null | undefined, verifications: VerificationViewModel[]): Promise<VerificationViewModel[]>;

    /**
     * Get a verification image shred
     * @param userId (optional) User for the shred
     * @param docId (optional) Document id
     * @param parId (optional) Parameter id
     * @param verificationId (optional) Verification id
     * @param inline (optional) Should the image be inline
     * @param x_Api_Version (optional) 
     * @return A shred image
     */
    getShred(userId: string | null | undefined, docId: number | undefined, parId: number | undefined, verificationId: number | undefined, inline: boolean | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse>;

    /**
     * Get a summary of verifications
     * @param projectId (optional) Project id
     * @param stpdId (optional) Service id
     * @param pdId (optional) Definition id
     * @param latestOnly (optional) Only latest or history
     * @param x_Api_Version (optional) 
     * @return List of verifications
     */
    getSummary(projectId: number | null | undefined, stpdId: number | undefined, pdId: number | undefined, latestOnly: boolean | null | undefined, x_Api_Version: string | null | undefined): Promise<VerificationSummary[]>;

    /**
     * Get verification analytics
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param latestOnly (optional) Only the latest
     * @param x_Api_Version (optional) 
     * @return A summary of verifications
     */
    getHeatmap(projectId: number | null | undefined, stpdId: number | undefined, latestOnly: boolean | null | undefined, x_Api_Version: string | null | undefined): Promise<VerificationSummary[]>;

    /**
     * Get extended verification info
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param usage (optional) 
     * @param statuses (optional) 
     * @param classname (optional) 
     * @param filename (optional) 
     * @param filetype (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @param masterid (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param comment (optional) 
     * @param result (optional) 
     * @param x_Api_Version (optional) 
     */
    getExtended(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, usage: UsageType | null | undefined, statuses: DocumentStatus[] | null | undefined, classname: string | null | undefined, filename: string | null | undefined, filetype: string | null | undefined, start: Date | null | undefined, end: Date | null | undefined, masterid: number | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, comment: string | null | undefined, result: string | null | undefined, x_Api_Version: string | null | undefined): Promise<VerificationSummary[]>;
}

export class VerificationClient extends AIForgedBase implements IVerificationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get a verification by id
     * @param verificationId (optional) Verification id
     * @param x_Api_Version (optional) 
     * @return A verificacation
     */
    get(verificationId: number | undefined, x_Api_Version: string | null | undefined): Promise<VerificationViewModel> {
        let url_ = this.baseUrl + "/api/Verification/Get?";
        if (verificationId === null)
            throw new Error("The parameter 'verificationId' cannot be null.");
        else if (verificationId !== undefined)
            url_ += "verificationId=" + encodeURIComponent("" + verificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<VerificationViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerificationViewModel>(null as any);
    }

    /**
     * Get verifications on a parameter
     * @param docId (optional) Document id
     * @param parameterId (optional) Parameter id
     * @param x_Api_Version (optional) 
     * @return A list of verifications
     */
    getAll(docId: number | undefined, parameterId: number | undefined, x_Api_Version: string | null | undefined): Promise<VerificationViewModel[]> {
        let url_ = this.baseUrl + "/api/Verification/GetAll?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (parameterId === null)
            throw new Error("The parameter 'parameterId' cannot be null.");
        else if (parameterId !== undefined)
            url_ += "parameterId=" + encodeURIComponent("" + parameterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<VerificationViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerificationViewModel[]>(null as any);
    }

    /**
     * Get latest verification on a parameter
     * @param docId (optional) Document id
     * @param parameterId (optional) Parameter id
     * @param pdId (optional) Definition id
     * @param x_Api_Version (optional) 
     * @return A verification
     */
    getLatest(docId: number | undefined, parameterId: number | null | undefined, pdId: number | null | undefined, x_Api_Version: string | null | undefined): Promise<VerificationViewModel> {
        let url_ = this.baseUrl + "/api/Verification/GetLatest?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (parameterId !== undefined && parameterId !== null)
            url_ += "parameterId=" + encodeURIComponent("" + parameterId) + "&";
        if (pdId !== undefined && pdId !== null)
            url_ += "pdId=" + encodeURIComponent("" + pdId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetLatest(_response));
        });
    }

    protected processGetLatest(response: Response): Promise<VerificationViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerificationViewModel>(null as any);
    }

    /**
     * Rerun verification on a parameter
     * @param docId (optional) The document id
     * @param parameterId (optional) 
     * @param restart (optional) 
     * @param x_Api_Version (optional) 
     */
    rerun(docId: number | undefined, parameterId: number | undefined, restart: boolean | undefined, x_Api_Version: string | null | undefined): Promise<VerificationViewModel[]> {
        let url_ = this.baseUrl + "/api/Verification/Rerun?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (parameterId === null)
            throw new Error("The parameter 'parameterId' cannot be null.");
        else if (parameterId !== undefined)
            url_ += "parameterId=" + encodeURIComponent("" + parameterId) + "&";
        if (restart === null)
            throw new Error("The parameter 'restart' cannot be null.");
        else if (restart !== undefined)
            url_ += "restart=" + encodeURIComponent("" + restart) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRerun(_response));
        });
    }

    protected processRerun(response: Response): Promise<VerificationViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerificationViewModel[]>(null as any);
    }

    /**
     * Rerun verification on a document
     * @param docId (optional) The document id
     * @param restart (optional) 
     * @param x_Api_Version (optional) 
     */
    rerunAll(docId: number | undefined, restart: boolean | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Verification/RerunAll?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (restart === null)
            throw new Error("The parameter 'restart' cannot be null.");
        else if (restart !== undefined)
            url_ += "restart=" + encodeURIComponent("" + restart) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRerunAll(_response));
        });
    }

    protected processRerunAll(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Create a list of verifications
     * @param docId (optional) The document id
     * @param x_Api_Version (optional) 
     */
    verify(docId: number | undefined, x_Api_Version: string | null | undefined, verifications: VerificationViewModel[]): Promise<VerificationViewModel[]> {
        let url_ = this.baseUrl + "/api/Verification/Verify?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(verifications);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processVerify(_response));
        });
    }

    protected processVerify(response: Response): Promise<VerificationViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerificationViewModel[]>(null as any);
    }

    /**
     * Get a verification image shred
     * @param userId (optional) User for the shred
     * @param docId (optional) Document id
     * @param parId (optional) Parameter id
     * @param verificationId (optional) Verification id
     * @param inline (optional) Should the image be inline
     * @param x_Api_Version (optional) 
     * @return A shred image
     */
    getShred(userId: string | null | undefined, docId: number | undefined, parId: number | undefined, verificationId: number | undefined, inline: boolean | undefined, x_Api_Version: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Verification/GetShred?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (parId === null)
            throw new Error("The parameter 'parId' cannot be null.");
        else if (parId !== undefined)
            url_ += "parId=" + encodeURIComponent("" + parId) + "&";
        if (verificationId === null)
            throw new Error("The parameter 'verificationId' cannot be null.");
        else if (verificationId !== undefined)
            url_ += "verificationId=" + encodeURIComponent("" + verificationId) + "&";
        if (inline === null)
            throw new Error("The parameter 'inline' cannot be null.");
        else if (inline !== undefined)
            url_ += "inline=" + encodeURIComponent("" + inline) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetShred(_response));
        });
    }

    protected processGetShred(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get a summary of verifications
     * @param projectId (optional) Project id
     * @param stpdId (optional) Service id
     * @param pdId (optional) Definition id
     * @param latestOnly (optional) Only latest or history
     * @param x_Api_Version (optional) 
     * @return List of verifications
     */
    getSummary(projectId: number | null | undefined, stpdId: number | undefined, pdId: number | undefined, latestOnly: boolean | null | undefined, x_Api_Version: string | null | undefined): Promise<VerificationSummary[]> {
        let url_ = this.baseUrl + "/api/Verification/GetSummary?";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (pdId === null)
            throw new Error("The parameter 'pdId' cannot be null.");
        else if (pdId !== undefined)
            url_ += "pdId=" + encodeURIComponent("" + pdId) + "&";
        if (latestOnly !== undefined && latestOnly !== null)
            url_ += "latestOnly=" + encodeURIComponent("" + latestOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetSummary(_response));
        });
    }

    protected processGetSummary(response: Response): Promise<VerificationSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerificationSummary[]>(null as any);
    }

    /**
     * Get verification analytics
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param latestOnly (optional) Only the latest
     * @param x_Api_Version (optional) 
     * @return A summary of verifications
     */
    getHeatmap(projectId: number | null | undefined, stpdId: number | undefined, latestOnly: boolean | null | undefined, x_Api_Version: string | null | undefined): Promise<VerificationSummary[]> {
        let url_ = this.baseUrl + "/api/Verification/GetHeatmap?";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (latestOnly !== undefined && latestOnly !== null)
            url_ += "latestOnly=" + encodeURIComponent("" + latestOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetHeatmap(_response));
        });
    }

    protected processGetHeatmap(response: Response): Promise<VerificationSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerificationSummary[]>(null as any);
    }

    /**
     * Get extended verification info
     * @param userId (optional) The user id
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param usage (optional) 
     * @param statuses (optional) 
     * @param classname (optional) 
     * @param filename (optional) 
     * @param filetype (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @param masterid (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param comment (optional) 
     * @param result (optional) 
     * @param x_Api_Version (optional) 
     */
    getExtended(userId: string | null | undefined, projectId: number | undefined, stpdId: number | undefined, usage: UsageType | null | undefined, statuses: DocumentStatus[] | null | undefined, classname: string | null | undefined, filename: string | null | undefined, filetype: string | null | undefined, start: Date | null | undefined, end: Date | null | undefined, masterid: number | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, comment: string | null | undefined, result: string | null | undefined, x_Api_Version: string | null | undefined): Promise<VerificationSummary[]> {
        let url_ = this.baseUrl + "/api/Verification/GetExtended?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (usage !== undefined && usage !== null)
            url_ += "usage=" + encodeURIComponent("" + usage) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (classname !== undefined && classname !== null)
            url_ += "classname=" + encodeURIComponent("" + classname) + "&";
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        if (filetype !== undefined && filetype !== null)
            url_ += "filetype=" + encodeURIComponent("" + filetype) + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toISOString() : "") + "&";
        if (end !== undefined && end !== null)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toISOString() : "") + "&";
        if (masterid !== undefined && masterid !== null)
            url_ += "masterid=" + encodeURIComponent("" + masterid) + "&";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "pageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (result !== undefined && result !== null)
            url_ += "result=" + encodeURIComponent("" + result) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetExtended(_response));
        });
    }

    protected processGetExtended(response: Response): Promise<VerificationSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerificationSummary[]>(null as any);
    }
}

export interface IWizardClient {

    /**
     * Get all wizards steps for a project and services
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param validate (optional) 
     * @param x_Api_Version (optional) 
     */
    getAll(projectId: number | undefined, stpdId: number | undefined, validate: boolean | undefined, x_Api_Version: string | null | undefined): Promise<Wizard[]>;

    /**
     * Bootstrap a new serice and get the wizard steps required
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     */
    createService(projectId: number | undefined, x_Api_Version: string | null | undefined, stpd: ParameterDefViewModel): Promise<Wizard[]>;

    /**
     * Validate a visard step
     * @param projectId (optional) The project id
     * @param type (optional) 
     * @param x_Api_Version (optional) 
     */
    validate(projectId: number | undefined, type: WizardValidation | null | undefined, x_Api_Version: string | null | undefined, wizard: Wizard): Promise<Wizard>;

    /**
     * Validate miltiple wizard steps
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     */
    validateMulti(projectId: number | undefined, x_Api_Version: string | null | undefined, wizards: Wizard[]): Promise<Wizard[]>;

    /**
     * Save a wizard step
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     */
    save(projectId: number | undefined, x_Api_Version: string | null | undefined, wizard: Wizard): Promise<Wizard>;
}

export class WizardClient extends AIForgedBase implements IWizardClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get all wizards steps for a project and services
     * @param projectId (optional) The project id
     * @param stpdId (optional) Service id
     * @param validate (optional) 
     * @param x_Api_Version (optional) 
     */
    getAll(projectId: number | undefined, stpdId: number | undefined, validate: boolean | undefined, x_Api_Version: string | null | undefined): Promise<Wizard[]> {
        let url_ = this.baseUrl + "/api/Wizard/GetAll?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (stpdId === null)
            throw new Error("The parameter 'stpdId' cannot be null.");
        else if (stpdId !== undefined)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (validate === null)
            throw new Error("The parameter 'validate' cannot be null.");
        else if (validate !== undefined)
            url_ += "validate=" + encodeURIComponent("" + validate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<Wizard[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Wizard.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Wizard[]>(null as any);
    }

    /**
     * Bootstrap a new serice and get the wizard steps required
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     */
    createService(projectId: number | undefined, x_Api_Version: string | null | undefined, stpd: ParameterDefViewModel): Promise<Wizard[]> {
        let url_ = this.baseUrl + "/api/Wizard/CreateService?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(stpd);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateService(_response));
        });
    }

    protected processCreateService(response: Response): Promise<Wizard[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Wizard.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Wizard[]>(null as any);
    }

    /**
     * Validate a visard step
     * @param projectId (optional) The project id
     * @param type (optional) 
     * @param x_Api_Version (optional) 
     */
    validate(projectId: number | undefined, type: WizardValidation | null | undefined, x_Api_Version: string | null | undefined, wizard: Wizard): Promise<Wizard> {
        let url_ = this.baseUrl + "/api/Wizard/Validate?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(wizard);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processValidate(_response));
        });
    }

    protected processValidate(response: Response): Promise<Wizard> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Wizard.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Wizard>(null as any);
    }

    /**
     * Validate miltiple wizard steps
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     */
    validateMulti(projectId: number | undefined, x_Api_Version: string | null | undefined, wizards: Wizard[]): Promise<Wizard[]> {
        let url_ = this.baseUrl + "/api/Wizard/ValidateMulti?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(wizards);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processValidateMulti(_response));
        });
    }

    protected processValidateMulti(response: Response): Promise<Wizard[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Wizard.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Wizard[]>(null as any);
    }

    /**
     * Save a wizard step
     * @param projectId (optional) The project id
     * @param x_Api_Version (optional) 
     */
    save(projectId: number | undefined, x_Api_Version: string | null | undefined, wizard: Wizard): Promise<Wizard> {
        let url_ = this.baseUrl + "/api/Wizard/Save?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(wizard);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSave(_response));
        });
    }

    protected processSave(response: Response): Promise<Wizard> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Wizard.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Wizard>(null as any);
    }
}

export interface IWorkItemClient {

    /**
     * Get document work queue
     * @param userId (optional) The user id
     * @param stpdId (optional) Service id
     * @param usage (optional) 
     * @param statuses (optional) 
     * @param x_Api_Version (optional) 
     */
    getWorkQueue(userId: string | null | undefined, stpdId: number | null | undefined, usage: UsageType | null | undefined, statuses: DocumentStatus[] | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentsSummary[]>;

    /**
     * Get WorkItems Count
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param type (optional) 
     * @param action (optional) 
     * @param status (optional) 
     * @param docId (optional) 
     * @param shredId (optional) 
     * @param comment (optional) 
     * @param x_Api_Version (optional) 
     */
    getCount(userId: string | null | undefined, projectId: number | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, type: WorkItemType | null | undefined, action: WorkItemAction | null | undefined, status: WorkItemStatus | null | undefined, docId: number | null | undefined, shredId: number | null | undefined, comment: string | null | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Get WorkItems
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param type (optional) 
     * @param action (optional) 
     * @param status (optional) 
     * @param docId (optional) 
     * @param shredId (optional) 
     * @param comment (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param x_Api_Version (optional) 
     */
    get(userId: string | null | undefined, projectId: number | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, type: WorkItemType | null | undefined, action: WorkItemAction | null | undefined, status: WorkItemStatus | null | undefined, docId: number | null | undefined, shredId: number | null | undefined, comment: string | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]>;

    /**
     * Expire WorkItems
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param type (optional) 
     * @param action (optional) 
     * @param status (optional) 
     * @param docId (optional) 
     * @param shredId (optional) 
     * @param comment (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param x_Api_Version (optional) 
     */
    expire(userId: string | null | undefined, projectId: number | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, type: WorkItemType | null | undefined, action: WorkItemAction | null | undefined, status: WorkItemStatus | null | undefined, docId: number | null | undefined, shredId: number | null | undefined, comment: string | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, x_Api_Version: string | null | undefined): Promise<number>;

    /**
     * Get WorkItem By Id
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    getById(id: number | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel>;

    /**
     * Escelate to another user
     * @param id (optional) 
     * @param method (optional) 
     * @param comment (optional) 
     * @param toUserId (optional) 
     * @param graceperiod (optional) 
     * @param x_Api_Version (optional) 
     */
    escelate(id: number | undefined, method: WorkItemMethod | undefined, comment: string | null | undefined, toUserId: string | null | undefined, graceperiod: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]>;

    /**
     * Escelate to another user
     * @param id (optional) 
     * @param toUserId (optional) 
     * @param comment (optional) 
     * @param x_Api_Version (optional) 
     */
    transfer(id: number | undefined, toUserId: string | null | undefined, comment: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel>;

    /**
     * Reject work item
     * @param id (optional) 
     * @param method (optional) 
     * @param toUserId (optional) 
     * @param comment (optional) 
     * @param graceperiod (optional) 
     * @param x_Api_Version (optional) 
     */
    reject(id: number | undefined, method: WorkItemMethod | null | undefined, toUserId: string | null | undefined, comment: string | null | undefined, graceperiod: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]>;

    /**
     * Reject work items for a shred
     * @param docId (optional) 
     * @param shredId (optional) 
     * @param method (optional) 
     * @param toUserId (optional) 
     * @param comment (optional) 
     * @param graceperiod (optional) 
     * @param x_Api_Version (optional) 
     */
    rejectShred(docId: number | undefined, shredId: number | undefined, method: WorkItemMethod | null | undefined, toUserId: string | null | undefined, comment: string | null | undefined, graceperiod: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]>;

    /**
     * Update status
     * @param id (optional) 
     * @param status (optional) 
     * @param x_Api_Version (optional) 
     */
    setStatus(id: number | undefined, status: WorkItemStatus | undefined, x_Api_Version: string | null | undefined): Promise<boolean>;

    /**
     * Delete work item
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel>;

    /**
     * Create Workflow for Document / Shred
     * @param docId (optional) The document id
     * @param shredId (optional) Optional shred id for shred work items
     * @param comment (optional) Comment on the work item
     * @param method (optional) Work item assignment method
     * @param graceperiod (optional) Duration before work items gets escalated
     * @param toUserId (optional) Optional: a specific user id then Method is set to User
     * @param x_Api_Version (optional) 
     * @param roles Optional: When user not set - list of roles to choose from
     */
    create(docId: number | undefined, shredId: number | null | undefined, comment: string | null | undefined, method: WorkItemMethod | undefined, graceperiod: string | null | undefined, toUserId: string | null | undefined, x_Api_Version: string | null | undefined, roles: string[]): Promise<WorkItemViewModel[]>;

    /**
     * Finalize Workflow for Document
     * @param docId (optional) 
     * @param x_Api_Version (optional) 
     */
    finalize(docId: number | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]>;

    /**
     * Take Ownership of ourstanding Workflow items for Document
     * @param docId (optional) 
     * @param toUserId (optional) 
     * @param x_Api_Version (optional) 
     */
    ownership(docId: number | undefined, toUserId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]>;

    /**
     * Update status
     * @param docId (optional) 
     * @param method (optional) 
     * @param graceperiod (optional) 
     * @param x_Api_Version (optional) 
     */
    rebuild(docId: number | undefined, method: WorkItemMethod | null | undefined, graceperiod: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]>;

    /**
     * Get WorkItems Summary
     * @param userId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param x_Api_Version (optional) 
     */
    getSummary(userId: string | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, x_Api_Version: string | null | undefined): Promise<WorkFlowSummary[]>;

    /**
     * Get WorkItems Heatmap
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param x_Api_Version (optional) 
     */
    getHeatmap(userId: string | null | undefined, projectId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, x_Api_Version: string | null | undefined): Promise<WorkFlowSummary[]>;
}

export class WorkItemClient extends AIForgedBase implements IWorkItemClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AIForgedConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://portal.aiforged.com", baseUrl);
    }

    /**
     * Get document work queue
     * @param userId (optional) The user id
     * @param stpdId (optional) Service id
     * @param usage (optional) 
     * @param statuses (optional) 
     * @param x_Api_Version (optional) 
     */
    getWorkQueue(userId: string | null | undefined, stpdId: number | null | undefined, usage: UsageType | null | undefined, statuses: DocumentStatus[] | null | undefined, x_Api_Version: string | null | undefined): Promise<DocumentsSummary[]> {
        let url_ = this.baseUrl + "/api/WorkItem/GetWorkQueue?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (stpdId !== undefined && stpdId !== null)
            url_ += "stpdId=" + encodeURIComponent("" + stpdId) + "&";
        if (usage !== undefined && usage !== null)
            url_ += "usage=" + encodeURIComponent("" + usage) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetWorkQueue(_response));
        });
    }

    protected processGetWorkQueue(response: Response): Promise<DocumentsSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentsSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentsSummary[]>(null as any);
    }

    /**
     * Get WorkItems Count
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param type (optional) 
     * @param action (optional) 
     * @param status (optional) 
     * @param docId (optional) 
     * @param shredId (optional) 
     * @param comment (optional) 
     * @param x_Api_Version (optional) 
     */
    getCount(userId: string | null | undefined, projectId: number | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, type: WorkItemType | null | undefined, action: WorkItemAction | null | undefined, status: WorkItemStatus | null | undefined, docId: number | null | undefined, shredId: number | null | undefined, comment: string | null | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/WorkItem/GetCount?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (docId !== undefined && docId !== null)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (shredId !== undefined && shredId !== null)
            url_ += "shredId=" + encodeURIComponent("" + shredId) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCount(_response));
        });
    }

    protected processGetCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get WorkItems
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param type (optional) 
     * @param action (optional) 
     * @param status (optional) 
     * @param docId (optional) 
     * @param shredId (optional) 
     * @param comment (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param x_Api_Version (optional) 
     */
    get(userId: string | null | undefined, projectId: number | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, type: WorkItemType | null | undefined, action: WorkItemAction | null | undefined, status: WorkItemStatus | null | undefined, docId: number | null | undefined, shredId: number | null | undefined, comment: string | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]> {
        let url_ = this.baseUrl + "/api/WorkItem/Get?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (docId !== undefined && docId !== null)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (shredId !== undefined && shredId !== null)
            url_ += "shredId=" + encodeURIComponent("" + shredId) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "pageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<WorkItemViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkItemViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkItemViewModel[]>(null as any);
    }

    /**
     * Expire WorkItems
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param type (optional) 
     * @param action (optional) 
     * @param status (optional) 
     * @param docId (optional) 
     * @param shredId (optional) 
     * @param comment (optional) 
     * @param pageNo (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDirection (optional) 
     * @param x_Api_Version (optional) 
     */
    expire(userId: string | null | undefined, projectId: number | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, type: WorkItemType | null | undefined, action: WorkItemAction | null | undefined, status: WorkItemStatus | null | undefined, docId: number | null | undefined, shredId: number | null | undefined, comment: string | null | undefined, pageNo: number | null | undefined, pageSize: number | null | undefined, sortField: SortField | null | undefined, sortDirection: SortDirection | null | undefined, x_Api_Version: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/WorkItem/Expire?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (docId !== undefined && docId !== null)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (shredId !== undefined && shredId !== null)
            url_ += "shredId=" + encodeURIComponent("" + shredId) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "pageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processExpire(_response));
        });
    }

    protected processExpire(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get WorkItem By Id
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    getById(id: number | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel> {
        let url_ = this.baseUrl + "/api/WorkItem/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetById(_response));
        });
    }

    protected processGetById(response: Response): Promise<WorkItemViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkItemViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkItemViewModel>(null as any);
    }

    /**
     * Escelate to another user
     * @param id (optional) 
     * @param method (optional) 
     * @param comment (optional) 
     * @param toUserId (optional) 
     * @param graceperiod (optional) 
     * @param x_Api_Version (optional) 
     */
    escelate(id: number | undefined, method: WorkItemMethod | undefined, comment: string | null | undefined, toUserId: string | null | undefined, graceperiod: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]> {
        let url_ = this.baseUrl + "/api/WorkItem/Escelate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (method === null)
            throw new Error("The parameter 'method' cannot be null.");
        else if (method !== undefined)
            url_ += "method=" + encodeURIComponent("" + method) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (toUserId !== undefined && toUserId !== null)
            url_ += "toUserId=" + encodeURIComponent("" + toUserId) + "&";
        if (graceperiod !== undefined && graceperiod !== null)
            url_ += "graceperiod=" + encodeURIComponent("" + graceperiod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEscelate(_response));
        });
    }

    protected processEscelate(response: Response): Promise<WorkItemViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkItemViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkItemViewModel[]>(null as any);
    }

    /**
     * Escelate to another user
     * @param id (optional) 
     * @param toUserId (optional) 
     * @param comment (optional) 
     * @param x_Api_Version (optional) 
     */
    transfer(id: number | undefined, toUserId: string | null | undefined, comment: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel> {
        let url_ = this.baseUrl + "/api/WorkItem/Transfer?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (toUserId !== undefined && toUserId !== null)
            url_ += "toUserId=" + encodeURIComponent("" + toUserId) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTransfer(_response));
        });
    }

    protected processTransfer(response: Response): Promise<WorkItemViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkItemViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkItemViewModel>(null as any);
    }

    /**
     * Reject work item
     * @param id (optional) 
     * @param method (optional) 
     * @param toUserId (optional) 
     * @param comment (optional) 
     * @param graceperiod (optional) 
     * @param x_Api_Version (optional) 
     */
    reject(id: number | undefined, method: WorkItemMethod | null | undefined, toUserId: string | null | undefined, comment: string | null | undefined, graceperiod: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]> {
        let url_ = this.baseUrl + "/api/WorkItem/Reject?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (method !== undefined && method !== null)
            url_ += "method=" + encodeURIComponent("" + method) + "&";
        if (toUserId !== undefined && toUserId !== null)
            url_ += "toUserId=" + encodeURIComponent("" + toUserId) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (graceperiod !== undefined && graceperiod !== null)
            url_ += "graceperiod=" + encodeURIComponent("" + graceperiod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processReject(_response));
        });
    }

    protected processReject(response: Response): Promise<WorkItemViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkItemViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkItemViewModel[]>(null as any);
    }

    /**
     * Reject work items for a shred
     * @param docId (optional) 
     * @param shredId (optional) 
     * @param method (optional) 
     * @param toUserId (optional) 
     * @param comment (optional) 
     * @param graceperiod (optional) 
     * @param x_Api_Version (optional) 
     */
    rejectShred(docId: number | undefined, shredId: number | undefined, method: WorkItemMethod | null | undefined, toUserId: string | null | undefined, comment: string | null | undefined, graceperiod: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]> {
        let url_ = this.baseUrl + "/api/WorkItem/RejectShred?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (shredId === null)
            throw new Error("The parameter 'shredId' cannot be null.");
        else if (shredId !== undefined)
            url_ += "shredId=" + encodeURIComponent("" + shredId) + "&";
        if (method !== undefined && method !== null)
            url_ += "method=" + encodeURIComponent("" + method) + "&";
        if (toUserId !== undefined && toUserId !== null)
            url_ += "toUserId=" + encodeURIComponent("" + toUserId) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (graceperiod !== undefined && graceperiod !== null)
            url_ += "graceperiod=" + encodeURIComponent("" + graceperiod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRejectShred(_response));
        });
    }

    protected processRejectShred(response: Response): Promise<WorkItemViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkItemViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkItemViewModel[]>(null as any);
    }

    /**
     * Update status
     * @param id (optional) 
     * @param status (optional) 
     * @param x_Api_Version (optional) 
     */
    setStatus(id: number | undefined, status: WorkItemStatus | undefined, x_Api_Version: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/WorkItem/SetStatus?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSetStatus(_response));
        });
    }

    protected processSetStatus(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Delete work item
     * @param id (optional) 
     * @param x_Api_Version (optional) 
     */
    delete(id: number | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel> {
        let url_ = this.baseUrl + "/api/WorkItem/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<WorkItemViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkItemViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkItemViewModel>(null as any);
    }

    /**
     * Create Workflow for Document / Shred
     * @param docId (optional) The document id
     * @param shredId (optional) Optional shred id for shred work items
     * @param comment (optional) Comment on the work item
     * @param method (optional) Work item assignment method
     * @param graceperiod (optional) Duration before work items gets escalated
     * @param toUserId (optional) Optional: a specific user id then Method is set to User
     * @param x_Api_Version (optional) 
     * @param roles Optional: When user not set - list of roles to choose from
     */
    create(docId: number | undefined, shredId: number | null | undefined, comment: string | null | undefined, method: WorkItemMethod | undefined, graceperiod: string | null | undefined, toUserId: string | null | undefined, x_Api_Version: string | null | undefined, roles: string[]): Promise<WorkItemViewModel[]> {
        let url_ = this.baseUrl + "/api/WorkItem/Create?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (shredId !== undefined && shredId !== null)
            url_ += "shredId=" + encodeURIComponent("" + shredId) + "&";
        if (comment !== undefined && comment !== null)
            url_ += "comment=" + encodeURIComponent("" + comment) + "&";
        if (method === null)
            throw new Error("The parameter 'method' cannot be null.");
        else if (method !== undefined)
            url_ += "method=" + encodeURIComponent("" + method) + "&";
        if (graceperiod !== undefined && graceperiod !== null)
            url_ += "graceperiod=" + encodeURIComponent("" + graceperiod) + "&";
        if (toUserId !== undefined && toUserId !== null)
            url_ += "toUserId=" + encodeURIComponent("" + toUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roles);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<WorkItemViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkItemViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkItemViewModel[]>(null as any);
    }

    /**
     * Finalize Workflow for Document
     * @param docId (optional) 
     * @param x_Api_Version (optional) 
     */
    finalize(docId: number | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]> {
        let url_ = this.baseUrl + "/api/WorkItem/Finalize?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processFinalize(_response));
        });
    }

    protected processFinalize(response: Response): Promise<WorkItemViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkItemViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkItemViewModel[]>(null as any);
    }

    /**
     * Take Ownership of ourstanding Workflow items for Document
     * @param docId (optional) 
     * @param toUserId (optional) 
     * @param x_Api_Version (optional) 
     */
    ownership(docId: number | undefined, toUserId: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]> {
        let url_ = this.baseUrl + "/api/WorkItem/Ownership?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (toUserId !== undefined && toUserId !== null)
            url_ += "toUserId=" + encodeURIComponent("" + toUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processOwnership(_response));
        });
    }

    protected processOwnership(response: Response): Promise<WorkItemViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkItemViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkItemViewModel[]>(null as any);
    }

    /**
     * Update status
     * @param docId (optional) 
     * @param method (optional) 
     * @param graceperiod (optional) 
     * @param x_Api_Version (optional) 
     */
    rebuild(docId: number | undefined, method: WorkItemMethod | null | undefined, graceperiod: string | null | undefined, x_Api_Version: string | null | undefined): Promise<WorkItemViewModel[]> {
        let url_ = this.baseUrl + "/api/WorkItem/Rebuild?";
        if (docId === null)
            throw new Error("The parameter 'docId' cannot be null.");
        else if (docId !== undefined)
            url_ += "docId=" + encodeURIComponent("" + docId) + "&";
        if (method !== undefined && method !== null)
            url_ += "method=" + encodeURIComponent("" + method) + "&";
        if (graceperiod !== undefined && graceperiod !== null)
            url_ += "graceperiod=" + encodeURIComponent("" + graceperiod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRebuild(_response));
        });
    }

    protected processRebuild(response: Response): Promise<WorkItemViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkItemViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkItemViewModel[]>(null as any);
    }

    /**
     * Get WorkItems Summary
     * @param userId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param x_Api_Version (optional) 
     */
    getSummary(userId: string | null | undefined, fromDate: Date | undefined, toDate: Date | undefined, x_Api_Version: string | null | undefined): Promise<WorkFlowSummary[]> {
        let url_ = this.baseUrl + "/api/WorkItem/GetSummary?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetSummary(_response));
        });
    }

    protected processGetSummary(response: Response): Promise<WorkFlowSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkFlowSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkFlowSummary[]>(null as any);
    }

    /**
     * Get WorkItems Heatmap
     * @param userId (optional) 
     * @param projectId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param x_Api_Version (optional) 
     */
    getHeatmap(userId: string | null | undefined, projectId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, x_Api_Version: string | null | undefined): Promise<WorkFlowSummary[]> {
        let url_ = this.baseUrl + "/api/WorkItem/GetHeatmap?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Api-Version": x_Api_Version !== undefined && x_Api_Version !== null ? "" + x_Api_Version : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetHeatmap(_response));
        });
    }

    protected processGetHeatmap(response: Response): Promise<WorkFlowSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkFlowSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkFlowSummary[]>(null as any);
    }
}

/** User information */
export class UserViewModel implements IUserViewModel {
    id?: string | undefined;
    userName!: string;
    fullName?: string | undefined;
    email!: string;
    jobTitle?: string | undefined;
    phoneNumber?: string | undefined;
    configuration?: string | undefined;
    isEnabled?: boolean;
    isLockedOut?: boolean;
    friendlyName?: string | undefined;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    roles?: string[] | undefined;

    constructor(data?: IUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.jobTitle = _data["jobTitle"];
            this.phoneNumber = _data["phoneNumber"];
            this.configuration = _data["configuration"];
            this.isEnabled = _data["isEnabled"];
            this.isLockedOut = _data["isLockedOut"];
            this.friendlyName = _data["friendlyName"];
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["jobTitle"] = this.jobTitle;
        data["phoneNumber"] = this.phoneNumber;
        data["configuration"] = this.configuration;
        data["isEnabled"] = this.isEnabled;
        data["isLockedOut"] = this.isLockedOut;
        data["friendlyName"] = this.friendlyName;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

/** User information */
export interface IUserViewModel {
    id?: string | undefined;
    userName: string;
    fullName?: string | undefined;
    email: string;
    jobTitle?: string | undefined;
    phoneNumber?: string | undefined;
    configuration?: string | undefined;
    isEnabled?: boolean;
    isLockedOut?: boolean;
    friendlyName?: string | undefined;
    createdBy?: string | undefined;
    updatedBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    roles?: string[] | undefined;
}

/** User information */
export class UserEditViewModel extends UserViewModel implements IUserEditViewModel {
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
    confirmPassword?: string | undefined;
    captchaToken?: string | undefined;

    constructor(data?: IUserEditViewModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
            this.captchaToken = _data["captchaToken"];
        }
    }

    static override fromJS(data: any): UserEditViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditViewModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        data["captchaToken"] = this.captchaToken;
        super.toJSON(data);
        return data;
    }
}

/** User information */
export interface IUserEditViewModel extends IUserViewModel {
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
    confirmPassword?: string | undefined;
    captchaToken?: string | undefined;
}

export class OperationBase implements IOperationBase {
    path?: string | undefined;
    op?: string | undefined;
    from?: string | undefined;

    constructor(data?: IOperationBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"];
            this.op = _data["op"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): OperationBase {
        data = typeof data === 'object' ? data : {};
        let result = new OperationBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["op"] = this.op;
        data["from"] = this.from;
        return data;
    }
}

export interface IOperationBase {
    path?: string | undefined;
    op?: string | undefined;
    from?: string | undefined;
}

export class Operation extends OperationBase implements IOperation {
    value?: any | undefined;

    constructor(data?: IOperation) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): Operation {
        data = typeof data === 'object' ? data : {};
        let result = new Operation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IOperation extends IOperationBase {
    value?: any | undefined;
}

export class UserActivateViewModel implements IUserActivateViewModel {
    userName!: string;
    token!: string;

    constructor(data?: IUserActivateViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): UserActivateViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserActivateViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["token"] = this.token;
        return data;
    }
}

export interface IUserActivateViewModel {
    userName: string;
    token: string;
}

export class UserPasswordResetViewModel implements IUserPasswordResetViewModel {
    userName!: string;
    token!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IUserPasswordResetViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.token = _data["token"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): UserPasswordResetViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserPasswordResetViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["token"] = this.token;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IUserPasswordResetViewModel {
    userName: string;
    token: string;
    password: string;
    confirmPassword: string;
}

export class UserLoginInfo implements IUserLoginInfo {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    providerDisplayName?: string | undefined;

    constructor(data?: IUserLoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.providerDisplayName = _data["providerDisplayName"];
        }
    }

    static fromJS(data: any): UserLoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["providerDisplayName"] = this.providerDisplayName;
        return data;
    }
}

export interface IUserLoginInfo {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    providerDisplayName?: string | undefined;
}

export class AuditViewModel implements IAuditViewModel {
    id!: number;
    userId?: string | undefined;
    entity?: AuditEntity;
    access?: AuditAccessType;
    keyId?: number;
    keyValue?: string | undefined;
    dt?: Date;
    field?: string | undefined;
    value?: string | undefined;
    data?: string | undefined;
    comment?: string | undefined;
    /** Projects is a container for billing and services */
    project?: ProjectViewModel | undefined;
    /** Service, settings abd rules definitions */
    service?: ParameterDefViewModel | undefined;
    /** Document metadata info */
    document?: DocumentViewModel | undefined;
    /** Service, settings abd rules definitions */
    def?: ParameterDefViewModel | undefined;
    /** Fields values linked ot extracted from documents */
    parameter?: DocumentParameterViewModel | undefined;
    /** System and user verification info for fields on documents */
    verification?: VerificationViewModel | undefined;
    /** Worflow record to manage assignments of verification tasks */
    workItem?: WorkItemViewModel | undefined;
    transaction?: TransactionsAuditViewModel | undefined;
    event?: ServiceEventViewModel | undefined;
    userName?: string | undefined;
    userFullName?: string | undefined;

    constructor(data?: IAuditViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.entity = _data["entity"];
            this.access = _data["access"];
            this.keyId = _data["keyId"];
            this.keyValue = _data["keyValue"];
            this.dt = _data["dt"] ? new Date(_data["dt"].toString()) : <any>undefined;
            this.field = _data["field"];
            this.value = _data["value"];
            this.data = _data["data"];
            this.comment = _data["comment"];
            this.project = _data["project"] ? ProjectViewModel.fromJS(_data["project"]) : <any>undefined;
            this.service = _data["service"] ? ParameterDefViewModel.fromJS(_data["service"]) : <any>undefined;
            this.document = _data["document"] ? DocumentViewModel.fromJS(_data["document"]) : <any>undefined;
            this.def = _data["def"] ? ParameterDefViewModel.fromJS(_data["def"]) : <any>undefined;
            this.parameter = _data["parameter"] ? DocumentParameterViewModel.fromJS(_data["parameter"]) : <any>undefined;
            this.verification = _data["verification"] ? VerificationViewModel.fromJS(_data["verification"]) : <any>undefined;
            this.workItem = _data["workItem"] ? WorkItemViewModel.fromJS(_data["workItem"]) : <any>undefined;
            this.transaction = _data["transaction"] ? TransactionsAuditViewModel.fromJS(_data["transaction"]) : <any>undefined;
            this.event = _data["event"] ? ServiceEventViewModel.fromJS(_data["event"]) : <any>undefined;
            this.userName = _data["userName"];
            this.userFullName = _data["userFullName"];
        }
    }

    static fromJS(data: any): AuditViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuditViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["entity"] = this.entity;
        data["access"] = this.access;
        data["keyId"] = this.keyId;
        data["keyValue"] = this.keyValue;
        data["dt"] = this.dt ? this.dt.toISOString() : <any>undefined;
        data["field"] = this.field;
        data["value"] = this.value;
        data["data"] = this.data;
        data["comment"] = this.comment;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["service"] = this.service ? this.service.toJSON() : <any>undefined;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["def"] = this.def ? this.def.toJSON() : <any>undefined;
        data["parameter"] = this.parameter ? this.parameter.toJSON() : <any>undefined;
        data["verification"] = this.verification ? this.verification.toJSON() : <any>undefined;
        data["workItem"] = this.workItem ? this.workItem.toJSON() : <any>undefined;
        data["transaction"] = this.transaction ? this.transaction.toJSON() : <any>undefined;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["userFullName"] = this.userFullName;
        return data;
    }
}

export interface IAuditViewModel {
    id: number;
    userId?: string | undefined;
    entity?: AuditEntity;
    access?: AuditAccessType;
    keyId?: number;
    keyValue?: string | undefined;
    dt?: Date;
    field?: string | undefined;
    value?: string | undefined;
    data?: string | undefined;
    comment?: string | undefined;
    /** Projects is a container for billing and services */
    project?: ProjectViewModel | undefined;
    /** Service, settings abd rules definitions */
    service?: ParameterDefViewModel | undefined;
    /** Document metadata info */
    document?: DocumentViewModel | undefined;
    /** Service, settings abd rules definitions */
    def?: ParameterDefViewModel | undefined;
    /** Fields values linked ot extracted from documents */
    parameter?: DocumentParameterViewModel | undefined;
    /** System and user verification info for fields on documents */
    verification?: VerificationViewModel | undefined;
    /** Worflow record to manage assignments of verification tasks */
    workItem?: WorkItemViewModel | undefined;
    transaction?: TransactionsAuditViewModel | undefined;
    event?: ServiceEventViewModel | undefined;
    userName?: string | undefined;
    userFullName?: string | undefined;
}

export enum AuditEntity {
    Project = 0,
    Service = 1,
    Document = 2,
    Work = 3,
    Contact = 4,
    Notification = 5,
    Payment = 6,
    Verification = 7,
    DataSet = 8,
    Reports = 9,
    Group = 10,
    ParamDef = 11,
    Parameter = 12,
    Audit = 13,
}

export enum AuditAccessType {
    Create = 0,
    Read = 1,
    Update = 2,
    Delete = 3,
    Move = 4,
    Copy = 5,
    Clone = 6,
    Elevate = 7,
    Work = 8,
    Init = 9,
    Train = 10,
    Process = 11,
    UnDelete = 12,
}

/** Projects is a container for billing and services */
export class ProjectViewModel implements IProjectViewModel {
    id?: number;
    userId?: string | undefined;
    status?: ProjectStatus;
    name?: string | undefined;
    description?: string | undefined;
    comment?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    /** Accounting info for projects and services */
    balance?: AccountBalanceItem | undefined;
    totalDocsCount?: number | undefined;
    services?: ParameterDefViewModel[] | undefined;

    constructor(data?: IProjectViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.comment = _data["comment"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.balance = _data["balance"] ? AccountBalanceItem.fromJS(_data["balance"]) : <any>undefined;
            this.totalDocsCount = _data["totalDocsCount"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(ParameterDefViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["name"] = this.name;
        data["description"] = this.description;
        data["comment"] = this.comment;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["balance"] = this.balance ? this.balance.toJSON() : <any>undefined;
        data["totalDocsCount"] = this.totalDocsCount;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        return data;
    }
}

/** Projects is a container for billing and services */
export interface IProjectViewModel {
    id?: number;
    userId?: string | undefined;
    status?: ProjectStatus;
    name?: string | undefined;
    description?: string | undefined;
    comment?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    /** Accounting info for projects and services */
    balance?: AccountBalanceItem | undefined;
    totalDocsCount?: number | undefined;
    services?: ParameterDefViewModel[] | undefined;
}

export enum ProjectStatus {
    None = 0,
    Active = 1,
    Disabled = 2,
    Requested = 10,
    Verification = 11,
    Rejected = 20,
    Deleted = 90,
    Error = 99,
}

/** Accounting info for projects and services */
export class AccountBalanceItem implements IAccountBalanceItem {
    id?: string;
    serviceId?: number | undefined;
    serviceTypeId?: number | undefined;
    projectId?: number | undefined;
    groupId?: number | undefined;
    bundleId?: number | undefined;
    userId?: string | undefined;
    drCount?: number | undefined;
    crCount?: number | undefined;
    drQty?: number | undefined;
    crQry?: number | undefined;
    dr?: number | undefined;
    cr?: number | undefined;
    balance?: number | undefined;
    project?: string | undefined;
    service?: string | undefined;
    serviceType?: string | undefined;
    bundle?: string | undefined;
    name?: string | undefined;
    userName?: string | undefined;

    constructor(data?: IAccountBalanceItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceId = _data["serviceId"];
            this.serviceTypeId = _data["serviceTypeId"];
            this.projectId = _data["projectId"];
            this.groupId = _data["groupId"];
            this.bundleId = _data["bundleId"];
            this.userId = _data["userId"];
            this.drCount = _data["drCount"];
            this.crCount = _data["crCount"];
            this.drQty = _data["drQty"];
            this.crQry = _data["crQry"];
            this.dr = _data["dr"];
            this.cr = _data["cr"];
            this.balance = _data["balance"];
            this.project = _data["project"];
            this.service = _data["service"];
            this.serviceType = _data["serviceType"];
            this.bundle = _data["bundle"];
            this.name = _data["name"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): AccountBalanceItem {
        data = typeof data === 'object' ? data : {};
        let result = new AccountBalanceItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceId"] = this.serviceId;
        data["serviceTypeId"] = this.serviceTypeId;
        data["projectId"] = this.projectId;
        data["groupId"] = this.groupId;
        data["bundleId"] = this.bundleId;
        data["userId"] = this.userId;
        data["drCount"] = this.drCount;
        data["crCount"] = this.crCount;
        data["drQty"] = this.drQty;
        data["crQry"] = this.crQry;
        data["dr"] = this.dr;
        data["cr"] = this.cr;
        data["balance"] = this.balance;
        data["project"] = this.project;
        data["service"] = this.service;
        data["serviceType"] = this.serviceType;
        data["bundle"] = this.bundle;
        data["name"] = this.name;
        data["userName"] = this.userName;
        return data;
    }
}

/** Accounting info for projects and services */
export interface IAccountBalanceItem {
    id?: string;
    serviceId?: number | undefined;
    serviceTypeId?: number | undefined;
    projectId?: number | undefined;
    groupId?: number | undefined;
    bundleId?: number | undefined;
    userId?: string | undefined;
    drCount?: number | undefined;
    crCount?: number | undefined;
    drQty?: number | undefined;
    crQry?: number | undefined;
    dr?: number | undefined;
    cr?: number | undefined;
    balance?: number | undefined;
    project?: string | undefined;
    service?: string | undefined;
    serviceType?: string | undefined;
    bundle?: string | undefined;
    name?: string | undefined;
    userName?: string | undefined;
}

/** Service, settings abd rules definitions */
export class ParameterDefViewModel implements IParameterDefViewModel {
    id?: number;
    projectId?: number;
    serviceTypeId?: number;
    serviceId?: number | undefined;
    classId?: number | undefined;
    parentId?: number | undefined;
    name?: string | undefined;
    label?: string | undefined;
    tags?: string | undefined;
    description?: string | undefined;
    dtc?: Date | undefined;
    dtm?: Date | undefined;
    status?: ParameterDefinitionStatus;
    category?: ParameterDefinitionCategory | undefined;
    grouping?: GroupingType | undefined;
    valueType?: ValueType;
    valueTypeName?: string | undefined;
    defaultValue?: string | undefined;
    required?: RequiredOption;
    index?: number | undefined;
    info?: string | undefined;
    reference?: string | undefined;
    rating?: number | undefined;
    availability?: Availability | undefined;
    children?: ParameterDefViewModel[] | undefined;
    settings?: ParameterDefSettingViewModel[] | undefined;
    totalCharge?: number | undefined;
    userCount?: number;
    parameterCount?: number;
    documentCount?: number;
    validation?: string | undefined;

    constructor(data?: IParameterDefViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.serviceTypeId = _data["serviceTypeId"];
            this.serviceId = _data["serviceId"];
            this.classId = _data["classId"];
            this.parentId = _data["parentId"];
            this.name = _data["name"];
            this.label = _data["label"];
            this.tags = _data["tags"];
            this.description = _data["description"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.category = _data["category"];
            this.grouping = _data["grouping"];
            this.valueType = _data["valueType"];
            this.valueTypeName = _data["valueTypeName"];
            this.defaultValue = _data["defaultValue"];
            this.required = _data["required"];
            this.index = _data["index"];
            this.info = _data["info"];
            this.reference = _data["reference"];
            this.rating = _data["rating"];
            this.availability = _data["availability"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(ParameterDefViewModel.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ParameterDefSettingViewModel.fromJS(item));
            }
            this.totalCharge = _data["totalCharge"];
            this.userCount = _data["userCount"];
            this.parameterCount = _data["parameterCount"];
            this.documentCount = _data["documentCount"];
            this.validation = _data["validation"];
        }
    }

    static fromJS(data: any): ParameterDefViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterDefViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["serviceTypeId"] = this.serviceTypeId;
        data["serviceId"] = this.serviceId;
        data["classId"] = this.classId;
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["label"] = this.label;
        data["tags"] = this.tags;
        data["description"] = this.description;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["category"] = this.category;
        data["grouping"] = this.grouping;
        data["valueType"] = this.valueType;
        data["valueTypeName"] = this.valueTypeName;
        data["defaultValue"] = this.defaultValue;
        data["required"] = this.required;
        data["index"] = this.index;
        data["info"] = this.info;
        data["reference"] = this.reference;
        data["rating"] = this.rating;
        data["availability"] = this.availability;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["totalCharge"] = this.totalCharge;
        data["userCount"] = this.userCount;
        data["parameterCount"] = this.parameterCount;
        data["documentCount"] = this.documentCount;
        data["validation"] = this.validation;
        return data;
    }
}

/** Service, settings abd rules definitions */
export interface IParameterDefViewModel {
    id?: number;
    projectId?: number;
    serviceTypeId?: number;
    serviceId?: number | undefined;
    classId?: number | undefined;
    parentId?: number | undefined;
    name?: string | undefined;
    label?: string | undefined;
    tags?: string | undefined;
    description?: string | undefined;
    dtc?: Date | undefined;
    dtm?: Date | undefined;
    status?: ParameterDefinitionStatus;
    category?: ParameterDefinitionCategory | undefined;
    grouping?: GroupingType | undefined;
    valueType?: ValueType;
    valueTypeName?: string | undefined;
    defaultValue?: string | undefined;
    required?: RequiredOption;
    index?: number | undefined;
    info?: string | undefined;
    reference?: string | undefined;
    rating?: number | undefined;
    availability?: Availability | undefined;
    children?: ParameterDefViewModel[] | undefined;
    settings?: ParameterDefSettingViewModel[] | undefined;
    totalCharge?: number | undefined;
    userCount?: number;
    parameterCount?: number;
    documentCount?: number;
    validation?: string | undefined;
}

export enum ParameterDefinitionStatus {
    Default = 0,
    Deleted = 99,
}

export enum ParameterDefinitionCategory {
    None = 0,
    Setting = 1,
    Service = 2,
    Statistics = 3,
    Results = 4,
    Dependency = 5,
    Verification = 6,
    DataSet = 7,
    PreProcessor = 20,
    Processor = 21,
    PostProcessor = 22,
    Extraction = 40,
}

export enum GroupingType {
    None = 0,
    Page = 1,
    Cluster = 2,
    Table = 3,
    Row = 4,
    Column = 5,
    Paragraph = 7,
    Line = 8,
    Word = 9,
    Array = 10,
    Form = 11,
    Field = 12,
    Anchor = 13,
    Unknown = 99,
}

export enum ValueType {
    None = 0,
    String = 1,
    Number = 2,
    Currency = 3,
    Boolean = 4,
    DateTime = 5,
    TimeSpan = 6,
    Email = 7,
    Enum = 8,
    Picture = 9,
    Password = 10,
    SecureString = 11,
    Address = 12,
    IDNo = 13,
    Country = 14,
    Code = 15,
    TelephoneNo = 17,
    GPS = 18,
    ServiceType = 19,
    Service = 20,
    Data = 90,
    DataSet = 91,
    System = 98,
    Unknown = 99,
}

export enum RequiredOption {
    Required = 1,
    Optional = 2,
    UseDefault = 4,
    UseBestFit = 8,
    Hidden = 16,
    Utility = 32,
    VerificationService = 64,
    Trained = 128,
    Conditional = 256,
}

export enum Availability {
    None = 0,
    Private = 1,
    Public = 2,
    Marketplace = 3,
    Inherit = 4,
    Internal = 5,
    Training = 6,
    DataSet = 7,
    Hidden = 9,
    Readonly = 10,
    Deleted = 99,
}

/** Detailed settings for rules and settings */
export class ParameterDefSettingViewModel implements IParameterDefSettingViewModel {
    id?: number;
    parameterDefId?: number;
    type?: SettingType;
    status?: SettingStatus;
    dtc?: Date;
    dtm?: Date;
    comment?: string | undefined;
    info?: string | undefined;
    data?: string | undefined;
    minValue?: string | undefined;
    maxValue?: string | undefined;
    confidence?: number | undefined;
    minConfidence?: number | undefined;
    maxConfidence?: number | undefined;
    isCaseSensative?: boolean;
    invert?: boolean;
    oneLine?: boolean;
    oneWord?: boolean;
    isHandwriting?: boolean;
    orientation?: Orientation | undefined;
    marking?: MarkingType | undefined;
    cells?: number | undefined;
    clearBefore?: OptionStatusFlags;
    clearAfter?: OptionStatusFlags;
    cleanupValuesBefore?: boolean;
    cleanupValuesAfter?: boolean;
    validateValuesBefore?: boolean;
    validateValuesAfter?: boolean;
    abortOnValidationError?: boolean;
    isReplacementCaseSensative?: boolean;
    compileResults?: string | undefined;
    maxRetry?: number;
    timeout?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IParameterDefSettingViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parameterDefId = _data["parameterDefId"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.info = _data["info"];
            this.data = _data["data"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
            this.confidence = _data["confidence"];
            this.minConfidence = _data["minConfidence"];
            this.maxConfidence = _data["maxConfidence"];
            this.isCaseSensative = _data["isCaseSensative"];
            this.invert = _data["invert"];
            this.oneLine = _data["oneLine"];
            this.oneWord = _data["oneWord"];
            this.isHandwriting = _data["isHandwriting"];
            this.orientation = _data["orientation"];
            this.marking = _data["marking"];
            this.cells = _data["cells"];
            this.clearBefore = _data["clearBefore"];
            this.clearAfter = _data["clearAfter"];
            this.cleanupValuesBefore = _data["cleanupValuesBefore"];
            this.cleanupValuesAfter = _data["cleanupValuesAfter"];
            this.validateValuesBefore = _data["validateValuesBefore"];
            this.validateValuesAfter = _data["validateValuesAfter"];
            this.abortOnValidationError = _data["abortOnValidationError"];
            this.isReplacementCaseSensative = _data["isReplacementCaseSensative"];
            this.compileResults = _data["compileResults"];
            this.maxRetry = _data["maxRetry"];
            this.timeout = _data["timeout"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ParameterDefSettingViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterDefSettingViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parameterDefId"] = this.parameterDefId;
        data["type"] = this.type;
        data["status"] = this.status;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["info"] = this.info;
        data["data"] = this.data;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        data["confidence"] = this.confidence;
        data["minConfidence"] = this.minConfidence;
        data["maxConfidence"] = this.maxConfidence;
        data["isCaseSensative"] = this.isCaseSensative;
        data["invert"] = this.invert;
        data["oneLine"] = this.oneLine;
        data["oneWord"] = this.oneWord;
        data["isHandwriting"] = this.isHandwriting;
        data["orientation"] = this.orientation;
        data["marking"] = this.marking;
        data["cells"] = this.cells;
        data["clearBefore"] = this.clearBefore;
        data["clearAfter"] = this.clearAfter;
        data["cleanupValuesBefore"] = this.cleanupValuesBefore;
        data["cleanupValuesAfter"] = this.cleanupValuesAfter;
        data["validateValuesBefore"] = this.validateValuesBefore;
        data["validateValuesAfter"] = this.validateValuesAfter;
        data["abortOnValidationError"] = this.abortOnValidationError;
        data["isReplacementCaseSensative"] = this.isReplacementCaseSensative;
        data["compileResults"] = this.compileResults;
        data["maxRetry"] = this.maxRetry;
        data["timeout"] = this.timeout;
        data["userId"] = this.userId;
        return data;
    }
}

/** Detailed settings for rules and settings */
export interface IParameterDefSettingViewModel {
    id?: number;
    parameterDefId?: number;
    type?: SettingType;
    status?: SettingStatus;
    dtc?: Date;
    dtm?: Date;
    comment?: string | undefined;
    info?: string | undefined;
    data?: string | undefined;
    minValue?: string | undefined;
    maxValue?: string | undefined;
    confidence?: number | undefined;
    minConfidence?: number | undefined;
    maxConfidence?: number | undefined;
    isCaseSensative?: boolean;
    invert?: boolean;
    oneLine?: boolean;
    oneWord?: boolean;
    isHandwriting?: boolean;
    orientation?: Orientation | undefined;
    marking?: MarkingType | undefined;
    cells?: number | undefined;
    clearBefore?: OptionStatusFlags;
    clearAfter?: OptionStatusFlags;
    cleanupValuesBefore?: boolean;
    cleanupValuesAfter?: boolean;
    validateValuesBefore?: boolean;
    validateValuesAfter?: boolean;
    abortOnValidationError?: boolean;
    isReplacementCaseSensative?: boolean;
    compileResults?: string | undefined;
    maxRetry?: number;
    timeout?: string | undefined;
    userId?: string | undefined;
}

export enum SettingType {
    None = 0,
    Setting = 1,
    Rule = 2,
    Dependency = 3,
    Template = 9,
    Runtime = 10,
}

export enum SettingStatus {
    Active = 0,
    Disabled = 1,
    Deleted = 99,
}

export enum Orientation {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
    VerticalReverse = 3,
}

export enum MarkingType {
    None = 0,
    Simple = 1,
    Undelined = 2,
    SimpleComb = 3,
    TextInFrame = 4,
    CombInFrame = 5,
    PartitionedFrame = 6,
    CharBox = 7,
    GreyBox = 8,
}

export enum OptionStatusFlags {
    Required = 1,
    Suspicious = 2,
    DefaultUsed = 4,
    Verified = 8,
    Bypassed = 16,
    Error = 32,
    Done = 64,
    Success = 128,
    RangeProblem = 256,
    IsValid = 512,
    Warnings = 1024,
}

/** Document metadata info */
export class DocumentViewModel implements IDocumentViewModel {
    id?: number;
    userId?: string | undefined;
    projectId?: number;
    serviceId?: number;
    status?: DocumentStatus;
    usage?: UsageType;
    classId?: number | undefined;
    contentType?: string | undefined;
    filename?: string | undefined;
    fileType?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    documentId?: string | undefined;
    externalId?: string | undefined;
    masterId?: number | undefined;
    result?: string | undefined;
    resultId?: string | undefined;
    resultIndex?: number | undefined;
    comment?: string | undefined;
    availability?: Availability | undefined;
    resultParameters?: DocumentParameterViewModel[] | undefined;
    data?: DocumentDataViewModel[] | undefined;
    documents?: DocumentViewModel[] | undefined;
    info?: string[] | undefined;
    originId?: number | undefined;
    canVerify?: boolean;
    canClassify?: boolean;
    canTrain?: boolean;
    trained?: boolean;
    linkedDocsCount?: number | undefined;
    trainingFieldCount?: number | undefined;
    trainedParametersCount?: number | undefined;

    constructor(data?: IDocumentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.projectId = _data["projectId"];
            this.serviceId = _data["serviceId"];
            this.status = _data["status"];
            this.usage = _data["usage"];
            this.classId = _data["classId"];
            this.contentType = _data["contentType"];
            this.filename = _data["filename"];
            this.fileType = _data["fileType"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.documentId = _data["documentId"];
            this.externalId = _data["externalId"];
            this.masterId = _data["masterId"];
            this.result = _data["result"];
            this.resultId = _data["resultId"];
            this.resultIndex = _data["resultIndex"];
            this.comment = _data["comment"];
            this.availability = _data["availability"];
            if (Array.isArray(_data["resultParameters"])) {
                this.resultParameters = [] as any;
                for (let item of _data["resultParameters"])
                    this.resultParameters!.push(DocumentParameterViewModel.fromJS(item));
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DocumentDataViewModel.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentViewModel.fromJS(item));
            }
            if (Array.isArray(_data["info"])) {
                this.info = [] as any;
                for (let item of _data["info"])
                    this.info!.push(item);
            }
            this.originId = _data["originId"];
            this.canVerify = _data["canVerify"];
            this.canClassify = _data["canClassify"];
            this.canTrain = _data["canTrain"];
            this.trained = _data["trained"];
            this.linkedDocsCount = _data["linkedDocsCount"];
            this.trainingFieldCount = _data["trainingFieldCount"];
            this.trainedParametersCount = _data["trainedParametersCount"];
        }
    }

    static fromJS(data: any): DocumentViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["projectId"] = this.projectId;
        data["serviceId"] = this.serviceId;
        data["status"] = this.status;
        data["usage"] = this.usage;
        data["classId"] = this.classId;
        data["contentType"] = this.contentType;
        data["filename"] = this.filename;
        data["fileType"] = this.fileType;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["documentId"] = this.documentId;
        data["externalId"] = this.externalId;
        data["masterId"] = this.masterId;
        data["result"] = this.result;
        data["resultId"] = this.resultId;
        data["resultIndex"] = this.resultIndex;
        data["comment"] = this.comment;
        data["availability"] = this.availability;
        if (Array.isArray(this.resultParameters)) {
            data["resultParameters"] = [];
            for (let item of this.resultParameters)
                data["resultParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.info)) {
            data["info"] = [];
            for (let item of this.info)
                data["info"].push(item);
        }
        data["originId"] = this.originId;
        data["canVerify"] = this.canVerify;
        data["canClassify"] = this.canClassify;
        data["canTrain"] = this.canTrain;
        data["trained"] = this.trained;
        data["linkedDocsCount"] = this.linkedDocsCount;
        data["trainingFieldCount"] = this.trainingFieldCount;
        data["trainedParametersCount"] = this.trainedParametersCount;
        return data;
    }
}

/** Document metadata info */
export interface IDocumentViewModel {
    id?: number;
    userId?: string | undefined;
    projectId?: number;
    serviceId?: number;
    status?: DocumentStatus;
    usage?: UsageType;
    classId?: number | undefined;
    contentType?: string | undefined;
    filename?: string | undefined;
    fileType?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    documentId?: string | undefined;
    externalId?: string | undefined;
    masterId?: number | undefined;
    result?: string | undefined;
    resultId?: string | undefined;
    resultIndex?: number | undefined;
    comment?: string | undefined;
    availability?: Availability | undefined;
    resultParameters?: DocumentParameterViewModel[] | undefined;
    data?: DocumentDataViewModel[] | undefined;
    documents?: DocumentViewModel[] | undefined;
    info?: string[] | undefined;
    originId?: number | undefined;
    canVerify?: boolean;
    canClassify?: boolean;
    canTrain?: boolean;
    trained?: boolean;
    linkedDocsCount?: number | undefined;
    trainingFieldCount?: number | undefined;
    trainedParametersCount?: number | undefined;
}

export enum DocumentStatus {
    None = 0,
    Received = 3,
    Analyzed = 4,
    Trained = 5,
    Processing = 8,
    Verification = 9,
    Processed = 10,
    Queued = 11,
    Verifying = 12,
    InsufficientBalance = 81,
    Error = 90,
    Archive = 98,
    Deleted = 99,
    CustomReceived = 103,
    CustomBusy = 108,
    CustomVerification = 109,
    CustomProcessed = 110,
    CustomError = 190,
}

export enum UsageType {
    Definition = 0,
    Training = 1,
    Inbox = 2,
    Outbox = 3,
    Label = 4,
    DataSet = 10,
    System = 90,
    Sample = 98,
    Preview = 99,
}

/** Fields values linked ot extracted from documents */
export class DocumentParameterViewModel implements IDocumentParameterViewModel {
    id!: number;
    documentId?: number;
    paramDefId?: number | undefined;
    parentId?: number | undefined;
    sourceId?: number | undefined;
    value?: string | undefined;
    data?: string | undefined;
    index?: number | undefined;
    colIndex?: number | undefined;
    colSpan?: number | undefined;
    rowIndex?: number | undefined;
    rowSpan?: number | undefined;
    availability?: Availability | undefined;
    /** Service, settings abd rules definitions */
    paramDef?: ParameterDefViewModel | undefined;
    children?: DocumentParameterViewModel[] | undefined;
    verifications?: VerificationViewModel[] | undefined;

    constructor(data?: IDocumentParameterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentId = _data["documentId"];
            this.paramDefId = _data["paramDefId"];
            this.parentId = _data["parentId"];
            this.sourceId = _data["sourceId"];
            this.value = _data["value"];
            this.data = _data["data"];
            this.index = _data["index"];
            this.colIndex = _data["colIndex"];
            this.colSpan = _data["colSpan"];
            this.rowIndex = _data["rowIndex"];
            this.rowSpan = _data["rowSpan"];
            this.availability = _data["availability"];
            this.paramDef = _data["paramDef"] ? ParameterDefViewModel.fromJS(_data["paramDef"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(DocumentParameterViewModel.fromJS(item));
            }
            if (Array.isArray(_data["verifications"])) {
                this.verifications = [] as any;
                for (let item of _data["verifications"])
                    this.verifications!.push(VerificationViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentParameterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentParameterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentId"] = this.documentId;
        data["paramDefId"] = this.paramDefId;
        data["parentId"] = this.parentId;
        data["sourceId"] = this.sourceId;
        data["value"] = this.value;
        data["data"] = this.data;
        data["index"] = this.index;
        data["colIndex"] = this.colIndex;
        data["colSpan"] = this.colSpan;
        data["rowIndex"] = this.rowIndex;
        data["rowSpan"] = this.rowSpan;
        data["availability"] = this.availability;
        data["paramDef"] = this.paramDef ? this.paramDef.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        if (Array.isArray(this.verifications)) {
            data["verifications"] = [];
            for (let item of this.verifications)
                data["verifications"].push(item.toJSON());
        }
        return data;
    }
}

/** Fields values linked ot extracted from documents */
export interface IDocumentParameterViewModel {
    id: number;
    documentId?: number;
    paramDefId?: number | undefined;
    parentId?: number | undefined;
    sourceId?: number | undefined;
    value?: string | undefined;
    data?: string | undefined;
    index?: number | undefined;
    colIndex?: number | undefined;
    colSpan?: number | undefined;
    rowIndex?: number | undefined;
    rowSpan?: number | undefined;
    availability?: Availability | undefined;
    /** Service, settings abd rules definitions */
    paramDef?: ParameterDefViewModel | undefined;
    children?: DocumentParameterViewModel[] | undefined;
    verifications?: VerificationViewModel[] | undefined;
}

/** System and user verification info for fields on documents */
export class VerificationViewModel implements IVerificationViewModel {
    id!: number;
    parameterId!: number;
    userId?: string | undefined;
    value?: string | undefined;
    dt?: Date;
    confidence?: number | undefined;
    symbolsConfidence?: string | undefined;
    type?: VerificationType;
    status?: VerificationStatus;
    result?: string | undefined;
    box?: string | undefined;
    info?: string | undefined;
    data?: string | undefined;
    userName?: string | undefined;
    serviceId?: number | undefined;
    serviceDocId?: number | undefined;
    provider?: string | undefined;
    settingId?: number | undefined;
    workItem?: number | undefined;
    transactionId?: number | undefined;
    charge?: number;

    constructor(data?: IVerificationViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parameterId = _data["parameterId"];
            this.userId = _data["userId"];
            this.value = _data["value"];
            this.dt = _data["dt"] ? new Date(_data["dt"].toString()) : <any>undefined;
            this.confidence = _data["confidence"];
            this.symbolsConfidence = _data["symbolsConfidence"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.result = _data["result"];
            this.box = _data["box"];
            this.info = _data["info"];
            this.data = _data["data"];
            this.userName = _data["userName"];
            this.serviceId = _data["serviceId"];
            this.serviceDocId = _data["serviceDocId"];
            this.provider = _data["provider"];
            this.settingId = _data["settingId"];
            this.workItem = _data["workItem"];
            this.transactionId = _data["transactionId"];
            this.charge = _data["charge"];
        }
    }

    static fromJS(data: any): VerificationViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parameterId"] = this.parameterId;
        data["userId"] = this.userId;
        data["value"] = this.value;
        data["dt"] = this.dt ? this.dt.toISOString() : <any>undefined;
        data["confidence"] = this.confidence;
        data["symbolsConfidence"] = this.symbolsConfidence;
        data["type"] = this.type;
        data["status"] = this.status;
        data["result"] = this.result;
        data["box"] = this.box;
        data["info"] = this.info;
        data["data"] = this.data;
        data["userName"] = this.userName;
        data["serviceId"] = this.serviceId;
        data["serviceDocId"] = this.serviceDocId;
        data["provider"] = this.provider;
        data["settingId"] = this.settingId;
        data["workItem"] = this.workItem;
        data["transactionId"] = this.transactionId;
        data["charge"] = this.charge;
        return data;
    }
}

/** System and user verification info for fields on documents */
export interface IVerificationViewModel {
    id: number;
    parameterId: number;
    userId?: string | undefined;
    value?: string | undefined;
    dt?: Date;
    confidence?: number | undefined;
    symbolsConfidence?: string | undefined;
    type?: VerificationType;
    status?: VerificationStatus;
    result?: string | undefined;
    box?: string | undefined;
    info?: string | undefined;
    data?: string | undefined;
    userName?: string | undefined;
    serviceId?: number | undefined;
    serviceDocId?: number | undefined;
    provider?: string | undefined;
    settingId?: number | undefined;
    workItem?: number | undefined;
    transactionId?: number | undefined;
    charge?: number;
}

export enum VerificationType {
    None = 0,
    Provider = 1,
    System = 2,
    User = 3,
    Service = 4,
    Training = 5,
    RPA = 6,
    API = 7,
    DataSet = 8,
}

export enum VerificationStatus {
    Required = 1,
    Suspicious = 2,
    DefaultUsed = 4,
    Verified = 8,
    Bypassed = 16,
    Error = 32,
    Done = 64,
    Success = 128,
    RangeProblem = 256,
    IsValid = 512,
    Warnings = 1024,
    Service = 2048,
    Training = 4096,
    Scripted = 8192,
    Deleted = 16384,
}

/** Document blob data */
export class DocumentDataViewModel implements IDocumentDataViewModel {
    id?: number;
    documentId?: number;
    blobId?: number | undefined;
    type?: DocumentDataType | undefined;
    data?: string | undefined;
    preview?: string | undefined;
    text?: string | undefined;
    info?: string | undefined;
    contentType?: string | undefined;
    resultId?: string | undefined;
    index?: number | undefined;
    width?: number | undefined;
    height?: number | undefined;
    resolution?: number | undefined;
    availability?: Availability | undefined;

    constructor(data?: IDocumentDataViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentId = _data["documentId"];
            this.blobId = _data["blobId"];
            this.type = _data["type"];
            this.data = _data["data"];
            this.preview = _data["preview"];
            this.text = _data["text"];
            this.info = _data["info"];
            this.contentType = _data["contentType"];
            this.resultId = _data["resultId"];
            this.index = _data["index"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.resolution = _data["resolution"];
            this.availability = _data["availability"];
        }
    }

    static fromJS(data: any): DocumentDataViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDataViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentId"] = this.documentId;
        data["blobId"] = this.blobId;
        data["type"] = this.type;
        data["data"] = this.data;
        data["preview"] = this.preview;
        data["text"] = this.text;
        data["info"] = this.info;
        data["contentType"] = this.contentType;
        data["resultId"] = this.resultId;
        data["index"] = this.index;
        data["width"] = this.width;
        data["height"] = this.height;
        data["resolution"] = this.resolution;
        data["availability"] = this.availability;
        return data;
    }
}

/** Document blob data */
export interface IDocumentDataViewModel {
    id?: number;
    documentId?: number;
    blobId?: number | undefined;
    type?: DocumentDataType | undefined;
    data?: string | undefined;
    preview?: string | undefined;
    text?: string | undefined;
    info?: string | undefined;
    contentType?: string | undefined;
    resultId?: string | undefined;
    index?: number | undefined;
    width?: number | undefined;
    height?: number | undefined;
    resolution?: number | undefined;
    availability?: Availability | undefined;
}

export enum DocumentDataType {
    Image = 0,
    Result = 1,
    Page = 2,
    Definition = 10,
    Training = 11,
}

/** Worflow record to manage assignments of verification tasks */
export class WorkItemViewModel implements IWorkItemViewModel {
    id!: number;
    puId!: number;
    serviceId?: number | undefined;
    documentId?: number | undefined;
    defId?: number | undefined;
    shredId?: number | undefined;
    verificationId?: number | undefined;
    transactionId?: number | undefined;
    workItemId?: number | undefined;
    type?: WorkItemType;
    action?: WorkItemAction;
    status?: WorkItemStatus;
    method?: WorkItemMethod | undefined;
    info?: string | undefined;
    comment?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    dueDate?: Date;
    open?: Date | undefined;
    closed?: Date | undefined;
    duration?: string | undefined;
    /** Relationship between users, projects, services and groups */
    pu?: ProjectUserViewModel | undefined;
    /** Service, settings abd rules definitions */
    service?: ParameterDefViewModel | undefined;
    /** Document metadata info */
    document?: DocumentViewModel | undefined;
    /** Fields values linked ot extracted from documents */
    shred?: DocumentParameterViewModel | undefined;
    /** Service, settings abd rules definitions */
    def?: ParameterDefViewModel | undefined;
    /** System and user verification info for fields on documents */
    verification?: VerificationViewModel | undefined;
    /** Worflow record to manage assignments of verification tasks */
    parent?: WorkItemViewModel | undefined;
    /** Projects is a container for billing and services */
    project?: ProjectViewModel | undefined;
    /** User information */
    user?: UserViewModel | undefined;
    docCategory?: string | undefined;

    constructor(data?: IWorkItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.puId = _data["puId"];
            this.serviceId = _data["serviceId"];
            this.documentId = _data["documentId"];
            this.defId = _data["defId"];
            this.shredId = _data["shredId"];
            this.verificationId = _data["verificationId"];
            this.transactionId = _data["transactionId"];
            this.workItemId = _data["workItemId"];
            this.type = _data["type"];
            this.action = _data["action"];
            this.status = _data["status"];
            this.method = _data["method"];
            this.info = _data["info"];
            this.comment = _data["comment"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.open = _data["open"] ? new Date(_data["open"].toString()) : <any>undefined;
            this.closed = _data["closed"] ? new Date(_data["closed"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.pu = _data["pu"] ? ProjectUserViewModel.fromJS(_data["pu"]) : <any>undefined;
            this.service = _data["service"] ? ParameterDefViewModel.fromJS(_data["service"]) : <any>undefined;
            this.document = _data["document"] ? DocumentViewModel.fromJS(_data["document"]) : <any>undefined;
            this.shred = _data["shred"] ? DocumentParameterViewModel.fromJS(_data["shred"]) : <any>undefined;
            this.def = _data["def"] ? ParameterDefViewModel.fromJS(_data["def"]) : <any>undefined;
            this.verification = _data["verification"] ? VerificationViewModel.fromJS(_data["verification"]) : <any>undefined;
            this.parent = _data["parent"] ? WorkItemViewModel.fromJS(_data["parent"]) : <any>undefined;
            this.project = _data["project"] ? ProjectViewModel.fromJS(_data["project"]) : <any>undefined;
            this.user = _data["user"] ? UserViewModel.fromJS(_data["user"]) : <any>undefined;
            this.docCategory = _data["docCategory"];
        }
    }

    static fromJS(data: any): WorkItemViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new WorkItemViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["puId"] = this.puId;
        data["serviceId"] = this.serviceId;
        data["documentId"] = this.documentId;
        data["defId"] = this.defId;
        data["shredId"] = this.shredId;
        data["verificationId"] = this.verificationId;
        data["transactionId"] = this.transactionId;
        data["workItemId"] = this.workItemId;
        data["type"] = this.type;
        data["action"] = this.action;
        data["status"] = this.status;
        data["method"] = this.method;
        data["info"] = this.info;
        data["comment"] = this.comment;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["open"] = this.open ? this.open.toISOString() : <any>undefined;
        data["closed"] = this.closed ? this.closed.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["pu"] = this.pu ? this.pu.toJSON() : <any>undefined;
        data["service"] = this.service ? this.service.toJSON() : <any>undefined;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["shred"] = this.shred ? this.shred.toJSON() : <any>undefined;
        data["def"] = this.def ? this.def.toJSON() : <any>undefined;
        data["verification"] = this.verification ? this.verification.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["docCategory"] = this.docCategory;
        return data;
    }
}

/** Worflow record to manage assignments of verification tasks */
export interface IWorkItemViewModel {
    id: number;
    puId: number;
    serviceId?: number | undefined;
    documentId?: number | undefined;
    defId?: number | undefined;
    shredId?: number | undefined;
    verificationId?: number | undefined;
    transactionId?: number | undefined;
    workItemId?: number | undefined;
    type?: WorkItemType;
    action?: WorkItemAction;
    status?: WorkItemStatus;
    method?: WorkItemMethod | undefined;
    info?: string | undefined;
    comment?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    dueDate?: Date;
    open?: Date | undefined;
    closed?: Date | undefined;
    duration?: string | undefined;
    /** Relationship between users, projects, services and groups */
    pu?: ProjectUserViewModel | undefined;
    /** Service, settings abd rules definitions */
    service?: ParameterDefViewModel | undefined;
    /** Document metadata info */
    document?: DocumentViewModel | undefined;
    /** Fields values linked ot extracted from documents */
    shred?: DocumentParameterViewModel | undefined;
    /** Service, settings abd rules definitions */
    def?: ParameterDefViewModel | undefined;
    /** System and user verification info for fields on documents */
    verification?: VerificationViewModel | undefined;
    /** Worflow record to manage assignments of verification tasks */
    parent?: WorkItemViewModel | undefined;
    /** Projects is a container for billing and services */
    project?: ProjectViewModel | undefined;
    /** User information */
    user?: UserViewModel | undefined;
    docCategory?: string | undefined;
}

export enum WorkItemType {
    None = 0,
    Document = 1,
    Shred = 2,
    DataSet = 3,
    Support = 4,
    Error = 99,
}

export enum WorkItemAction {
    None = 0,
    Verify = 1,
    Investigate = 2,
    Forensic = 3,
    Fraudulant = 4,
    Classify = 5,
    Reprocess = 10,
}

export enum WorkItemStatus {
    None = 0,
    Created = 1,
    Completed = 2,
    EscalateTx = 3,
    EscalateRx = 4,
    Transfer = 5,
    Received = 6,
    Verified = 8,
    RelatedVerified = 9,
    Rejected = 10,
    Deleted = 90,
    Error = 99,
}

export enum WorkItemMethod {
    Random = 0,
    HighThroughput = 1,
    Idle = 2,
    ProjectOwner = 3,
    DocumentOwner = 4,
    User = 5,
}

/** Relationship between users, projects, services and groups */
export class ProjectUserViewModel implements IProjectUserViewModel {
    id?: number;
    userId?: string | undefined;
    userName?: string | undefined;
    userFullName?: string | undefined;
    projectId?: number;
    serviceId?: number | undefined;
    groupId?: number | undefined;
    role!: string;
    permission?: string | undefined;
    type?: LinkType;
    status?: ProjectUserStatus;
    dtc?: Date;
    dtm?: Date;
    /** User information */
    user?: UserViewModel | undefined;
    /** Projects is a container for billing and services */
    project?: ProjectViewModel | undefined;
    /** Service, settings abd rules definitions */
    service?: ParameterDefViewModel | undefined;
    /** User groups for sharing services and billing */
    group?: UserGroupViewModel | undefined;
    balances?: AccountBalanceItem[] | undefined;
    related?: ProjectUserViewModel[] | undefined;
    constraints?: ProjectUserConstraintViewModel[] | undefined;

    constructor(data?: IProjectUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userFullName = _data["userFullName"];
            this.projectId = _data["projectId"];
            this.serviceId = _data["serviceId"];
            this.groupId = _data["groupId"];
            this.role = _data["role"];
            this.permission = _data["permission"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.user = _data["user"] ? UserViewModel.fromJS(_data["user"]) : <any>undefined;
            this.project = _data["project"] ? ProjectViewModel.fromJS(_data["project"]) : <any>undefined;
            this.service = _data["service"] ? ParameterDefViewModel.fromJS(_data["service"]) : <any>undefined;
            this.group = _data["group"] ? UserGroupViewModel.fromJS(_data["group"]) : <any>undefined;
            if (Array.isArray(_data["balances"])) {
                this.balances = [] as any;
                for (let item of _data["balances"])
                    this.balances!.push(AccountBalanceItem.fromJS(item));
            }
            if (Array.isArray(_data["related"])) {
                this.related = [] as any;
                for (let item of _data["related"])
                    this.related!.push(ProjectUserViewModel.fromJS(item));
            }
            if (Array.isArray(_data["constraints"])) {
                this.constraints = [] as any;
                for (let item of _data["constraints"])
                    this.constraints!.push(ProjectUserConstraintViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectUserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectUserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userFullName"] = this.userFullName;
        data["projectId"] = this.projectId;
        data["serviceId"] = this.serviceId;
        data["groupId"] = this.groupId;
        data["role"] = this.role;
        data["permission"] = this.permission;
        data["type"] = this.type;
        data["status"] = this.status;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["service"] = this.service ? this.service.toJSON() : <any>undefined;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        if (Array.isArray(this.balances)) {
            data["balances"] = [];
            for (let item of this.balances)
                data["balances"].push(item.toJSON());
        }
        if (Array.isArray(this.related)) {
            data["related"] = [];
            for (let item of this.related)
                data["related"].push(item.toJSON());
        }
        if (Array.isArray(this.constraints)) {
            data["constraints"] = [];
            for (let item of this.constraints)
                data["constraints"].push(item.toJSON());
        }
        return data;
    }
}

/** Relationship between users, projects, services and groups */
export interface IProjectUserViewModel {
    id?: number;
    userId?: string | undefined;
    userName?: string | undefined;
    userFullName?: string | undefined;
    projectId?: number;
    serviceId?: number | undefined;
    groupId?: number | undefined;
    role: string;
    permission?: string | undefined;
    type?: LinkType;
    status?: ProjectUserStatus;
    dtc?: Date;
    dtm?: Date;
    /** User information */
    user?: UserViewModel | undefined;
    /** Projects is a container for billing and services */
    project?: ProjectViewModel | undefined;
    /** Service, settings abd rules definitions */
    service?: ParameterDefViewModel | undefined;
    /** User groups for sharing services and billing */
    group?: UserGroupViewModel | undefined;
    balances?: AccountBalanceItem[] | undefined;
    related?: ProjectUserViewModel[] | undefined;
    constraints?: ProjectUserConstraintViewModel[] | undefined;
}

export enum LinkType {
    None = 0,
    Owner = 1,
    Shared = 2,
    Marketplace = 3,
    Error = 99,
}

export enum ProjectUserStatus {
    None = 0,
    Requested = 1,
    Rejected = 2,
    Approved = 3,
    Removed = 4,
    Error = 99,
}

/** User groups for sharing services and billing */
export class UserGroupViewModel implements IUserGroupViewModel {
    id!: number;
    type?: UserGroupType;
    status?: UserGroupStatus;
    userId!: string;
    name?: string | undefined;
    dtc?: Date;
    dtm?: Date;

    constructor(data?: IUserGroupViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserGroupViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserGroupViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["status"] = this.status;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        return data;
    }
}

/** User groups for sharing services and billing */
export interface IUserGroupViewModel {
    id: number;
    type?: UserGroupType;
    status?: UserGroupStatus;
    userId: string;
    name?: string | undefined;
    dtc?: Date;
    dtm?: Date;
}

export enum UserGroupType {
    Default = 0,
    Partner = 1,
    Reseller = 2,
    Corporate = 3,
    Company = 4,
    Individual = 5,
}

export enum UserGroupStatus {
    Active = 0,
    Deleted = 99,
}

export class ProjectUserConstraintViewModel implements IProjectUserConstraintViewModel {
    id!: number;
    projectUserId!: number;
    type?: ConstraintType;
    status?: ConstraintStatus;
    intervalType?: ConstraintIntervalType;
    interval?: string | undefined;
    fromDate?: Date;
    toDate?: Date | undefined;
    key?: string | undefined;
    value?: number | undefined;
    comment?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IProjectUserConstraintViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectUserId = _data["projectUserId"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.intervalType = _data["intervalType"];
            this.interval = _data["interval"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.key = _data["key"];
            this.value = _data["value"];
            this.comment = _data["comment"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ProjectUserConstraintViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectUserConstraintViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectUserId"] = this.projectUserId;
        data["type"] = this.type;
        data["status"] = this.status;
        data["intervalType"] = this.intervalType;
        data["interval"] = this.interval;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["key"] = this.key;
        data["value"] = this.value;
        data["comment"] = this.comment;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IProjectUserConstraintViewModel {
    id: number;
    projectUserId: number;
    type?: ConstraintType;
    status?: ConstraintStatus;
    intervalType?: ConstraintIntervalType;
    interval?: string | undefined;
    fromDate?: Date;
    toDate?: Date | undefined;
    key?: string | undefined;
    value?: number | undefined;
    comment?: string | undefined;
    userId?: string | undefined;
}

export enum ConstraintType {
    Count = 1,
    Credit = 2,
}

export enum ConstraintStatus {
    Active = 0,
    Deleted = 99,
}

export enum ConstraintIntervalType {
    OnceOff = 0,
    Day = 1,
    Week = 2,
    Month = 3,
    Year = 4,
    Timespan = 5,
}

export class TransactionsAuditViewModel implements ITransactionsAuditViewModel {
    id!: number;
    serviceId?: number | undefined;
    projectId?: number | undefined;
    bundleId?: number | undefined;
    paymentId?: number | undefined;
    chargeId?: number | undefined;
    relatedTxnId?: number | undefined;
    userId?: string | undefined;
    runId?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    qty?: number;
    price?: number;
    cost?: number;
    isCredit?: boolean;

    constructor(data?: ITransactionsAuditViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceId = _data["serviceId"];
            this.projectId = _data["projectId"];
            this.bundleId = _data["bundleId"];
            this.paymentId = _data["paymentId"];
            this.chargeId = _data["chargeId"];
            this.relatedTxnId = _data["relatedTxnId"];
            this.userId = _data["userId"];
            this.runId = _data["runId"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.qty = _data["qty"];
            this.price = _data["price"];
            this.cost = _data["cost"];
            this.isCredit = _data["isCredit"];
        }
    }

    static fromJS(data: any): TransactionsAuditViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionsAuditViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceId"] = this.serviceId;
        data["projectId"] = this.projectId;
        data["bundleId"] = this.bundleId;
        data["paymentId"] = this.paymentId;
        data["chargeId"] = this.chargeId;
        data["relatedTxnId"] = this.relatedTxnId;
        data["userId"] = this.userId;
        data["runId"] = this.runId;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["qty"] = this.qty;
        data["price"] = this.price;
        data["cost"] = this.cost;
        data["isCredit"] = this.isCredit;
        return data;
    }
}

export interface ITransactionsAuditViewModel {
    id: number;
    serviceId?: number | undefined;
    projectId?: number | undefined;
    bundleId?: number | undefined;
    paymentId?: number | undefined;
    chargeId?: number | undefined;
    relatedTxnId?: number | undefined;
    userId?: string | undefined;
    runId?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    qty?: number;
    price?: number;
    cost?: number;
    isCredit?: boolean;
}

export class ServiceEventViewModel implements IServiceEventViewModel {
    id!: number;
    userId?: string | undefined;
    projectId?: number | undefined;
    serviceId?: number | undefined;
    eventType?: ServiceEventType;
    status?: ServiceEventStatus;
    description?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    start?: Date | undefined;
    end?: Date | undefined;
    sourceType?: ReferenceType | undefined;
    sourceId?: string | undefined;
    resultType?: ReferenceType | undefined;
    resultId?: string | undefined;
    resultBody?: string | undefined;
    resultCount?: number | undefined;
    resultStatusId?: number | undefined;
    resultClassId?: number | undefined;
    masterId?: number | undefined;
    master?: ServiceEventViewModel | undefined;
    related?: ServiceEventViewModel[] | undefined;

    constructor(data?: IServiceEventViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.projectId = _data["projectId"];
            this.serviceId = _data["serviceId"];
            this.eventType = _data["eventType"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.sourceType = _data["sourceType"];
            this.sourceId = _data["sourceId"];
            this.resultType = _data["resultType"];
            this.resultId = _data["resultId"];
            this.resultBody = _data["resultBody"];
            this.resultCount = _data["resultCount"];
            this.resultStatusId = _data["resultStatusId"];
            this.resultClassId = _data["resultClassId"];
            this.masterId = _data["masterId"];
            this.master = _data["master"] ? ServiceEventViewModel.fromJS(_data["master"]) : <any>undefined;
            if (Array.isArray(_data["related"])) {
                this.related = [] as any;
                for (let item of _data["related"])
                    this.related!.push(ServiceEventViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceEventViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceEventViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["projectId"] = this.projectId;
        data["serviceId"] = this.serviceId;
        data["eventType"] = this.eventType;
        data["status"] = this.status;
        data["description"] = this.description;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["sourceType"] = this.sourceType;
        data["sourceId"] = this.sourceId;
        data["resultType"] = this.resultType;
        data["resultId"] = this.resultId;
        data["resultBody"] = this.resultBody;
        data["resultCount"] = this.resultCount;
        data["resultStatusId"] = this.resultStatusId;
        data["resultClassId"] = this.resultClassId;
        data["masterId"] = this.masterId;
        data["master"] = this.master ? this.master.toJSON() : <any>undefined;
        if (Array.isArray(this.related)) {
            data["related"] = [];
            for (let item of this.related)
                data["related"].push(item.toJSON());
        }
        return data;
    }
}

export interface IServiceEventViewModel {
    id: number;
    userId?: string | undefined;
    projectId?: number | undefined;
    serviceId?: number | undefined;
    eventType?: ServiceEventType;
    status?: ServiceEventStatus;
    description?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    start?: Date | undefined;
    end?: Date | undefined;
    sourceType?: ReferenceType | undefined;
    sourceId?: string | undefined;
    resultType?: ReferenceType | undefined;
    resultId?: string | undefined;
    resultBody?: string | undefined;
    resultCount?: number | undefined;
    resultStatusId?: number | undefined;
    resultClassId?: number | undefined;
    masterId?: number | undefined;
    master?: ServiceEventViewModel | undefined;
    related?: ServiceEventViewModel[] | undefined;
}

export enum ServiceEventType {
    None = 0,
    Classification = 1,
    Extraction = 2,
    Verification = 3,
    Index = 4,
    Expert = 5,
    Extractor = 6,
    Train = 10,
    Define = 11,
    Process = 12,
}

export enum ServiceEventStatus {
    None = 0,
    Start = 1,
    End = 2,
    Cancelled = 3,
    Terminated = 4,
    Error = 5,
}

export enum ReferenceType {
    None = 0,
    Document = 1,
    Index = 2,
    Schedule = 3,
    Expert = 4,
    Extractor = 5,
    Unknown = 99,
}

/** A bundle for payments and credits */
export class BundlesViewModel implements IBundlesViewModel {
    id!: number;
    type!: BundleType;
    name!: string;
    description?: string | undefined;
    count?: number;
    price?: number;
    discount?: number;
    dtc?: Date;
    dtm?: Date;
    isActive?: boolean;
    expiryDate?: Date | undefined;
    productCode?: string | undefined;

    constructor(data?: IBundlesViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.count = _data["count"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.expiryDate = _data["expiryDate"] ? new Date(_data["expiryDate"].toString()) : <any>undefined;
            this.productCode = _data["productCode"];
        }
    }

    static fromJS(data: any): BundlesViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new BundlesViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["name"] = this.name;
        data["description"] = this.description;
        data["count"] = this.count;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["productCode"] = this.productCode;
        return data;
    }
}

/** A bundle for payments and credits */
export interface IBundlesViewModel {
    id: number;
    type: BundleType;
    name: string;
    description?: string | undefined;
    count?: number;
    price?: number;
    discount?: number;
    dtc?: Date;
    dtm?: Date;
    isActive?: boolean;
    expiryDate?: Date | undefined;
    productCode?: string | undefined;
}

export enum BundleType {
    PrePaid = 1,
    PostPaid = 2,
    Gift = 3,
    Signon = 4,
    Marketplace = 5,
}

/** Categories/Classes for training and classification */
export class ClassesViewModel implements IClassesViewModel {
    id?: number;
    userId?: string | undefined;
    projectId?: number;
    name?: string | undefined;
    description?: string | undefined;
    comment?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    type?: ClassType | undefined;
    status?: CategoryStatus | undefined;
    related?: number | undefined;
    reference?: string | undefined;

    constructor(data?: IClassesViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.projectId = _data["projectId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.comment = _data["comment"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.status = _data["status"];
            this.related = _data["related"];
            this.reference = _data["reference"];
        }
    }

    static fromJS(data: any): ClassesViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ClassesViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["projectId"] = this.projectId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["comment"] = this.comment;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["status"] = this.status;
        data["related"] = this.related;
        data["reference"] = this.reference;
        return data;
    }
}

/** Categories/Classes for training and classification */
export interface IClassesViewModel {
    id?: number;
    userId?: string | undefined;
    projectId?: number;
    name?: string | undefined;
    description?: string | undefined;
    comment?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    type?: ClassType | undefined;
    status?: CategoryStatus | undefined;
    related?: number | undefined;
    reference?: string | undefined;
}

export enum ClassType {
    System = 0,
    Definition = 1,
    Other = 2,
}

export enum CategoryStatus {
    Enabled = 0,
    Disabled = 1,
    Deleted = 99,
}

export enum DictionaryLookupMethod {
    Exact = 0,
    LevenshteinDistance = 1,
    HammingDistance = 2,
    RegEx = 3,
    None = 4,
}

export class ContactViewModel implements IContactViewModel {
    id?: number;
    userId?: string | undefined;
    status?: ContactStatus;
    type?: NotificationType;
    address?: string | undefined;
    name?: string | undefined;
    comment?: string | undefined;
    dtc?: Date;
    dtm?: Date;

    constructor(data?: IContactViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.type = _data["type"];
            this.address = _data["address"];
            this.name = _data["name"];
            this.comment = _data["comment"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ContactViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["type"] = this.type;
        data["address"] = this.address;
        data["name"] = this.name;
        data["comment"] = this.comment;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        return data;
    }
}

export interface IContactViewModel {
    id?: number;
    userId?: string | undefined;
    status?: ContactStatus;
    type?: NotificationType;
    address?: string | undefined;
    name?: string | undefined;
    comment?: string | undefined;
    dtc?: Date;
    dtm?: Date;
}

export enum ContactStatus {
    None = 0,
    Active = 1,
    Disabled = 2,
    Deleted = 90,
}

export enum NotificationType {
    None = 0,
    Email = 1,
    SMS = 2,
    WhatsApp = 3,
    Bot = 4,
    Application = 5,
}

export class CustomDataSet implements ICustomDataSet {
    projectId?: number;
    stpdId?: number;
    docId?: number;
    keyDefId?: number;
    /** Service, settings abd rules definitions */
    keyDef?: ParameterDefViewModel | undefined;
    /** Document metadata info */
    document?: DocumentViewModel | undefined;
    definitions?: ParameterDefViewModel[] | undefined;
    data?: CustomDataSetRecord[] | undefined;
    status?: number;
    info?: string | undefined;
    includeData?: boolean;
    pageNo?: number | undefined;
    pageSize?: number | undefined;
    sortFieldDefId?: number | undefined;
    sortDirection?: SortDirection | undefined;
    includeVerifications?: boolean;
    searchField?: string | undefined;
    searchValue?: string | undefined;

    constructor(data?: ICustomDataSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.stpdId = _data["stpdId"];
            this.docId = _data["docId"];
            this.keyDefId = _data["keyDefId"];
            this.keyDef = _data["keyDef"] ? ParameterDefViewModel.fromJS(_data["keyDef"]) : <any>undefined;
            this.document = _data["document"] ? DocumentViewModel.fromJS(_data["document"]) : <any>undefined;
            if (Array.isArray(_data["definitions"])) {
                this.definitions = [] as any;
                for (let item of _data["definitions"])
                    this.definitions!.push(ParameterDefViewModel.fromJS(item));
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CustomDataSetRecord.fromJS(item));
            }
            this.status = _data["status"];
            this.info = _data["info"];
            this.includeData = _data["includeData"];
            this.pageNo = _data["pageNo"];
            this.pageSize = _data["pageSize"];
            this.sortFieldDefId = _data["sortFieldDefId"];
            this.sortDirection = _data["sortDirection"];
            this.includeVerifications = _data["includeVerifications"];
            this.searchField = _data["searchField"];
            this.searchValue = _data["searchValue"];
        }
    }

    static fromJS(data: any): CustomDataSet {
        data = typeof data === 'object' ? data : {};
        let result = new CustomDataSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["stpdId"] = this.stpdId;
        data["docId"] = this.docId;
        data["keyDefId"] = this.keyDefId;
        data["keyDef"] = this.keyDef ? this.keyDef.toJSON() : <any>undefined;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        if (Array.isArray(this.definitions)) {
            data["definitions"] = [];
            for (let item of this.definitions)
                data["definitions"].push(item.toJSON());
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["info"] = this.info;
        data["includeData"] = this.includeData;
        data["pageNo"] = this.pageNo;
        data["pageSize"] = this.pageSize;
        data["sortFieldDefId"] = this.sortFieldDefId;
        data["sortDirection"] = this.sortDirection;
        data["includeVerifications"] = this.includeVerifications;
        data["searchField"] = this.searchField;
        data["searchValue"] = this.searchValue;
        return data;
    }
}

export interface ICustomDataSet {
    projectId?: number;
    stpdId?: number;
    docId?: number;
    keyDefId?: number;
    /** Service, settings abd rules definitions */
    keyDef?: ParameterDefViewModel | undefined;
    /** Document metadata info */
    document?: DocumentViewModel | undefined;
    definitions?: ParameterDefViewModel[] | undefined;
    data?: CustomDataSetRecord[] | undefined;
    status?: number;
    info?: string | undefined;
    includeData?: boolean;
    pageNo?: number | undefined;
    pageSize?: number | undefined;
    sortFieldDefId?: number | undefined;
    sortDirection?: SortDirection | undefined;
    includeVerifications?: boolean;
    searchField?: string | undefined;
    searchValue?: string | undefined;
}

export class CustomDataSetRecord implements ICustomDataSetRecord {
    keyId?: number;
    keyDefId?: number;
    keyValue?: string | undefined;
    availability?: Availability | undefined;
    values?: CustomDataSetValue[] | undefined;

    constructor(data?: ICustomDataSetRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyId = _data["keyId"];
            this.keyDefId = _data["keyDefId"];
            this.keyValue = _data["keyValue"];
            this.availability = _data["availability"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(CustomDataSetValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomDataSetRecord {
        data = typeof data === 'object' ? data : {};
        let result = new CustomDataSetRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyId"] = this.keyId;
        data["keyDefId"] = this.keyDefId;
        data["keyValue"] = this.keyValue;
        data["availability"] = this.availability;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomDataSetRecord {
    keyId?: number;
    keyDefId?: number;
    keyValue?: string | undefined;
    availability?: Availability | undefined;
    values?: CustomDataSetValue[] | undefined;
}

export class CustomDataSetValue implements ICustomDataSetValue {
    defId?: number;
    id?: number;
    parentId?: number | undefined;
    index?: number | undefined;
    value?: string | undefined;
    availability?: Availability | undefined;
    verificationId?: number | undefined;
    verValue?: string | undefined;
    dt?: Date | undefined;
    confidence?: number | undefined;
    type?: VerificationType | undefined;
    status?: VerificationStatus | undefined;
    provider?: string | undefined;
    result?: string | undefined;

    constructor(data?: ICustomDataSetValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defId = _data["defId"];
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.index = _data["index"];
            this.value = _data["value"];
            this.availability = _data["availability"];
            this.verificationId = _data["verificationId"];
            this.verValue = _data["verValue"];
            this.dt = _data["dt"] ? new Date(_data["dt"].toString()) : <any>undefined;
            this.confidence = _data["confidence"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.provider = _data["provider"];
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): CustomDataSetValue {
        data = typeof data === 'object' ? data : {};
        let result = new CustomDataSetValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defId"] = this.defId;
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["value"] = this.value;
        data["availability"] = this.availability;
        data["verificationId"] = this.verificationId;
        data["verValue"] = this.verValue;
        data["dt"] = this.dt ? this.dt.toISOString() : <any>undefined;
        data["confidence"] = this.confidence;
        data["type"] = this.type;
        data["status"] = this.status;
        data["provider"] = this.provider;
        data["result"] = this.result;
        return data;
    }
}

export interface ICustomDataSetValue {
    defId?: number;
    id?: number;
    parentId?: number | undefined;
    index?: number | undefined;
    value?: string | undefined;
    availability?: Availability | undefined;
    verificationId?: number | undefined;
    verValue?: string | undefined;
    dt?: Date | undefined;
    confidence?: number | undefined;
    type?: VerificationType | undefined;
    status?: VerificationStatus | undefined;
    provider?: string | undefined;
    result?: string | undefined;
}

export enum SortDirection {
    Ascending = 0,
    Descending = 1,
}

export enum SortField {
    Id = 0,
    Name = 1,
    Description = 2,
    Date = 3,
    Status = 4,
    Category = 5,
}

export class DocumentsSummary implements IDocumentsSummary {
    projectId?: number | undefined;
    serviceType?: number;
    serviceId?: number;
    usage?: UsageType;
    status?: DocumentStatus;
    name?: string | undefined;
    classId?: number | undefined;
    className?: string | undefined;
    serviceName?: string | undefined;
    fileType?: string | undefined;
    dt?: Date | undefined;
    count?: number;
    labelledCount?: number | undefined;

    constructor(data?: IDocumentsSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.serviceType = _data["serviceType"];
            this.serviceId = _data["serviceId"];
            this.usage = _data["usage"];
            this.status = _data["status"];
            this.name = _data["name"];
            this.classId = _data["classId"];
            this.className = _data["className"];
            this.serviceName = _data["serviceName"];
            this.fileType = _data["fileType"];
            this.dt = _data["dt"] ? new Date(_data["dt"].toString()) : <any>undefined;
            this.count = _data["count"];
            this.labelledCount = _data["labelledCount"];
        }
    }

    static fromJS(data: any): DocumentsSummary {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentsSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["serviceType"] = this.serviceType;
        data["serviceId"] = this.serviceId;
        data["usage"] = this.usage;
        data["status"] = this.status;
        data["name"] = this.name;
        data["classId"] = this.classId;
        data["className"] = this.className;
        data["serviceName"] = this.serviceName;
        data["fileType"] = this.fileType;
        data["dt"] = this.dt ? this.dt.toISOString() : <any>undefined;
        data["count"] = this.count;
        data["labelledCount"] = this.labelledCount;
        return data;
    }
}

export interface IDocumentsSummary {
    projectId?: number | undefined;
    serviceType?: number;
    serviceId?: number;
    usage?: UsageType;
    status?: DocumentStatus;
    name?: string | undefined;
    classId?: number | undefined;
    className?: string | undefined;
    serviceName?: string | undefined;
    fileType?: string | undefined;
    dt?: Date | undefined;
    count?: number;
    labelledCount?: number | undefined;
}

export enum OperationOption {
    None = 0,
    All = 1,
    Latest = 2,
}

export class LogViewModel implements ILogViewModel {
    id!: number;
    type?: LogType | undefined;
    projectId?: number | undefined;
    serviceId?: number | undefined;
    documentId?: number | undefined;
    defId?: number | undefined;
    parameterId?: number | undefined;
    verificationId?: number | undefined;
    workItemId?: number | undefined;
    transactionId?: number | undefined;
    eventId?: number | undefined;
    userId?: string | undefined;
    dtc?: Date;
    comment?: string | undefined;
    stackTrace?: string | undefined;
    errorMessage?: string | undefined;
    page?: string | undefined;
    /** Projects is a container for billing and services */
    project?: ProjectViewModel | undefined;
    /** Service, settings abd rules definitions */
    service?: ParameterDefViewModel | undefined;
    /** Document metadata info */
    document?: DocumentViewModel | undefined;
    /** Service, settings abd rules definitions */
    def?: ParameterDefViewModel | undefined;
    /** Fields values linked ot extracted from documents */
    parameter?: DocumentParameterViewModel | undefined;
    /** System and user verification info for fields on documents */
    verification?: VerificationViewModel | undefined;
    /** Worflow record to manage assignments of verification tasks */
    workItem?: WorkItemViewModel | undefined;
    transaction?: TransactionsAuditViewModel | undefined;
    event?: ServiceEventViewModel | undefined;

    constructor(data?: ILogViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.projectId = _data["projectId"];
            this.serviceId = _data["serviceId"];
            this.documentId = _data["documentId"];
            this.defId = _data["defId"];
            this.parameterId = _data["parameterId"];
            this.verificationId = _data["verificationId"];
            this.workItemId = _data["workItemId"];
            this.transactionId = _data["transactionId"];
            this.eventId = _data["eventId"];
            this.userId = _data["userId"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.stackTrace = _data["stackTrace"];
            this.errorMessage = _data["errorMessage"];
            this.page = _data["page"];
            this.project = _data["project"] ? ProjectViewModel.fromJS(_data["project"]) : <any>undefined;
            this.service = _data["service"] ? ParameterDefViewModel.fromJS(_data["service"]) : <any>undefined;
            this.document = _data["document"] ? DocumentViewModel.fromJS(_data["document"]) : <any>undefined;
            this.def = _data["def"] ? ParameterDefViewModel.fromJS(_data["def"]) : <any>undefined;
            this.parameter = _data["parameter"] ? DocumentParameterViewModel.fromJS(_data["parameter"]) : <any>undefined;
            this.verification = _data["verification"] ? VerificationViewModel.fromJS(_data["verification"]) : <any>undefined;
            this.workItem = _data["workItem"] ? WorkItemViewModel.fromJS(_data["workItem"]) : <any>undefined;
            this.transaction = _data["transaction"] ? TransactionsAuditViewModel.fromJS(_data["transaction"]) : <any>undefined;
            this.event = _data["event"] ? ServiceEventViewModel.fromJS(_data["event"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LogViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LogViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["projectId"] = this.projectId;
        data["serviceId"] = this.serviceId;
        data["documentId"] = this.documentId;
        data["defId"] = this.defId;
        data["parameterId"] = this.parameterId;
        data["verificationId"] = this.verificationId;
        data["workItemId"] = this.workItemId;
        data["transactionId"] = this.transactionId;
        data["eventId"] = this.eventId;
        data["userId"] = this.userId;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["stackTrace"] = this.stackTrace;
        data["errorMessage"] = this.errorMessage;
        data["page"] = this.page;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["service"] = this.service ? this.service.toJSON() : <any>undefined;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["def"] = this.def ? this.def.toJSON() : <any>undefined;
        data["parameter"] = this.parameter ? this.parameter.toJSON() : <any>undefined;
        data["verification"] = this.verification ? this.verification.toJSON() : <any>undefined;
        data["workItem"] = this.workItem ? this.workItem.toJSON() : <any>undefined;
        data["transaction"] = this.transaction ? this.transaction.toJSON() : <any>undefined;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILogViewModel {
    id: number;
    type?: LogType | undefined;
    projectId?: number | undefined;
    serviceId?: number | undefined;
    documentId?: number | undefined;
    defId?: number | undefined;
    parameterId?: number | undefined;
    verificationId?: number | undefined;
    workItemId?: number | undefined;
    transactionId?: number | undefined;
    eventId?: number | undefined;
    userId?: string | undefined;
    dtc?: Date;
    comment?: string | undefined;
    stackTrace?: string | undefined;
    errorMessage?: string | undefined;
    page?: string | undefined;
    /** Projects is a container for billing and services */
    project?: ProjectViewModel | undefined;
    /** Service, settings abd rules definitions */
    service?: ParameterDefViewModel | undefined;
    /** Document metadata info */
    document?: DocumentViewModel | undefined;
    /** Service, settings abd rules definitions */
    def?: ParameterDefViewModel | undefined;
    /** Fields values linked ot extracted from documents */
    parameter?: DocumentParameterViewModel | undefined;
    /** System and user verification info for fields on documents */
    verification?: VerificationViewModel | undefined;
    /** Worflow record to manage assignments of verification tasks */
    workItem?: WorkItemViewModel | undefined;
    transaction?: TransactionsAuditViewModel | undefined;
    event?: ServiceEventViewModel | undefined;
}

export enum LogType {
    Info = 0,
    Debug = 1,
    Warning = 2,
    Error = 3,
    Exception = 4,
    Critical = 5,
}

export class RatingViewModel implements IRatingViewModel {
    id!: number;
    paramDefId!: number;
    parameterId?: number | undefined;
    verificationId?: number | undefined;
    type?: RatingType;
    status?: RatingStatus | undefined;
    userId?: string | undefined;
    dt?: Date;
    value?: number;
    comment?: string | undefined;
    userName?: string | undefined;

    constructor(data?: IRatingViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paramDefId = _data["paramDefId"];
            this.parameterId = _data["parameterId"];
            this.verificationId = _data["verificationId"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.userId = _data["userId"];
            this.dt = _data["dt"] ? new Date(_data["dt"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.comment = _data["comment"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): RatingViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RatingViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paramDefId"] = this.paramDefId;
        data["parameterId"] = this.parameterId;
        data["verificationId"] = this.verificationId;
        data["type"] = this.type;
        data["status"] = this.status;
        data["userId"] = this.userId;
        data["dt"] = this.dt ? this.dt.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["comment"] = this.comment;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IRatingViewModel {
    id: number;
    paramDefId: number;
    parameterId?: number | undefined;
    verificationId?: number | undefined;
    type?: RatingType;
    status?: RatingStatus | undefined;
    userId?: string | undefined;
    dt?: Date;
    value?: number;
    comment?: string | undefined;
    userName?: string | undefined;
}

export enum RatingType {
    User = 0,
    Agerage = 1,
    Error = 99,
}

export enum RatingStatus {
    Enabled = 0,
    Disabled = 1,
    Deleted = 99,
}

export class UserInviteViewModel implements IUserInviteViewModel {
    email!: string;
    projectId?: number;
    serviceId?: number;
    message?: string | undefined;

    constructor(data?: IUserInviteViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.projectId = _data["projectId"];
            this.serviceId = _data["serviceId"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): UserInviteViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserInviteViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["projectId"] = this.projectId;
        data["serviceId"] = this.serviceId;
        data["message"] = this.message;
        return data;
    }
}

export interface IUserInviteViewModel {
    email: string;
    projectId?: number;
    serviceId?: number;
    message?: string | undefined;
}

export class NotificationPreferences implements INotificationPreferences {
    preferences?: { [key in keyof typeof NotificationArea]?: NotificationOption; } | undefined;
    map?: { [key in keyof typeof NotificationArea]?: NotificationEvent[]; } | undefined;

    constructor(data?: INotificationPreferences) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["preferences"]) {
                this.preferences = {} as any;
                for (let key in _data["preferences"]) {
                    if (_data["preferences"].hasOwnProperty(key))
                        (<any>this.preferences)![key] = _data["preferences"][key] ? NotificationOption.fromJS(_data["preferences"][key]) : new NotificationOption();
                }
            }
            if (_data["map"]) {
                this.map = {} as any;
                for (let key in _data["map"]) {
                    if (_data["map"].hasOwnProperty(key))
                        (<any>this.map)![key] = _data["map"][key] !== undefined ? _data["map"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): NotificationPreferences {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationPreferences();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.preferences) {
            data["preferences"] = {};
            for (let key in this.preferences) {
                if (this.preferences.hasOwnProperty(key))
                    (<any>data["preferences"])[key] = this.preferences[key] ? this.preferences[key]?.toJSON() : <any>undefined;
            }
        }
        if (this.map) {
            data["map"] = {};
            for (let key in this.map) {
                if (this.map.hasOwnProperty(key))
                    (<any>data["map"])[key] = this.map[key];
            }
        }
        return data;
    }
}

export interface INotificationPreferences {
    preferences?: { [key in keyof typeof NotificationArea]?: NotificationOption; } | undefined;
    map?: { [key in keyof typeof NotificationArea]?: NotificationEvent[]; } | undefined;
}

export enum NotificationArea {
    None = 0,
    Login = 1,
    Project = 2,
    Service = 3,
    Document = 4,
    Verification = 5,
    Marketplace = 6,
    Payment = 7,
    Preferences = 8,
    Settings = 9,
    Support = 10,
    WorkItem = 11,
}

export class NotificationOption implements INotificationOption {
    name?: string | undefined;
    settings?: NotificationSetting[] | undefined;

    constructor(data?: INotificationOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(NotificationSetting.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationOption {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        return data;
    }
}

export interface INotificationOption {
    name?: string | undefined;
    settings?: NotificationSetting[] | undefined;
}

export class NotificationSetting implements INotificationSetting {
    name?: string | undefined;
    event?: NotificationEvent;
    type?: NotificationType;
    enabled?: boolean;
    contacts?: { [key: string]: string; } | undefined;
    contactIds?: number[] | undefined;

    constructor(data?: INotificationSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.event = _data["event"];
            this.type = _data["type"];
            this.enabled = _data["enabled"];
            if (_data["contacts"]) {
                this.contacts = {} as any;
                for (let key in _data["contacts"]) {
                    if (_data["contacts"].hasOwnProperty(key))
                        (<any>this.contacts)![key] = _data["contacts"][key];
                }
            }
            if (Array.isArray(_data["contactIds"])) {
                this.contactIds = [] as any;
                for (let item of _data["contactIds"])
                    this.contactIds!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationSetting {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["event"] = this.event;
        data["type"] = this.type;
        data["enabled"] = this.enabled;
        if (this.contacts) {
            data["contacts"] = {};
            for (let key in this.contacts) {
                if (this.contacts.hasOwnProperty(key))
                    (<any>data["contacts"])[key] = this.contacts[key];
            }
        }
        if (Array.isArray(this.contactIds)) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        return data;
    }
}

export interface INotificationSetting {
    name?: string | undefined;
    event?: NotificationEvent;
    type?: NotificationType;
    enabled?: boolean;
    contacts?: { [key: string]: string; } | undefined;
    contactIds?: number[] | undefined;
}

export enum NotificationEvent {
    Create = 1,
    Update = 2,
    Delete = 4,
    Process = 8,
    Training = 16,
    Upload = 32,
    Request = 64,
    Invite = 128,
    Approve = 256,
    Error = 512,
    Status = 1024,
    Monitor = 2048,
    Reset = 4096,
    Bug = 8092,
    Info = 16384,
    Progress = 65536,
    Toast = 131072,
    Confirm = 262144,
    Transfer = 524288,
    Escelate = 1048576,
    Verify = 2097152,
    Linked = 4194304,
    Reject = 8388608,
    UnDelete = 16777216,
}

export enum NotificationStatus {
    None = 0,
    Created = 1,
    Sent = 2,
    Delivered = 3,
    Display = 4,
    Ignore = 5,
    Deleted = 90,
    Error = 99,
}

/** System Notifications */
export class NotificationViewModel implements INotificationViewModel {
    id!: number;
    userId!: string;
    projectId?: number | undefined;
    classId?: number | undefined;
    serviceId?: number | undefined;
    documentId?: number | undefined;
    workItemId?: number | undefined;
    shredId?: number | undefined;
    verificationId?: number | undefined;
    contactId?: number | undefined;
    type?: NotificationType;
    status?: NotificationStatus;
    area?: NotificationArea;
    event?: NotificationEvent;
    level?: NotificationLevel;
    to?: string | undefined;
    address?: string | undefined;
    subject?: string | undefined;
    contentType?: string | undefined;
    body?: string | undefined;
    error?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    sent?: Date | undefined;
    delivered?: Date | undefined;
    readDate?: Date | undefined;
    contact?: ContactViewModel | undefined;
    attachments?: NotificationAttachmentViewModel[] | undefined;

    constructor(data?: INotificationViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.projectId = _data["projectId"];
            this.classId = _data["classId"];
            this.serviceId = _data["serviceId"];
            this.documentId = _data["documentId"];
            this.workItemId = _data["workItemId"];
            this.shredId = _data["shredId"];
            this.verificationId = _data["verificationId"];
            this.contactId = _data["contactId"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.area = _data["area"];
            this.event = _data["event"];
            this.level = _data["level"];
            this.to = _data["to"];
            this.address = _data["address"];
            this.subject = _data["subject"];
            this.contentType = _data["contentType"];
            this.body = _data["body"];
            this.error = _data["error"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.sent = _data["sent"] ? new Date(_data["sent"].toString()) : <any>undefined;
            this.delivered = _data["delivered"] ? new Date(_data["delivered"].toString()) : <any>undefined;
            this.readDate = _data["readDate"] ? new Date(_data["readDate"].toString()) : <any>undefined;
            this.contact = _data["contact"] ? ContactViewModel.fromJS(_data["contact"]) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(NotificationAttachmentViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["projectId"] = this.projectId;
        data["classId"] = this.classId;
        data["serviceId"] = this.serviceId;
        data["documentId"] = this.documentId;
        data["workItemId"] = this.workItemId;
        data["shredId"] = this.shredId;
        data["verificationId"] = this.verificationId;
        data["contactId"] = this.contactId;
        data["type"] = this.type;
        data["status"] = this.status;
        data["area"] = this.area;
        data["event"] = this.event;
        data["level"] = this.level;
        data["to"] = this.to;
        data["address"] = this.address;
        data["subject"] = this.subject;
        data["contentType"] = this.contentType;
        data["body"] = this.body;
        data["error"] = this.error;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["sent"] = this.sent ? this.sent.toISOString() : <any>undefined;
        data["delivered"] = this.delivered ? this.delivered.toISOString() : <any>undefined;
        data["readDate"] = this.readDate ? this.readDate.toISOString() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

/** System Notifications */
export interface INotificationViewModel {
    id: number;
    userId: string;
    projectId?: number | undefined;
    classId?: number | undefined;
    serviceId?: number | undefined;
    documentId?: number | undefined;
    workItemId?: number | undefined;
    shredId?: number | undefined;
    verificationId?: number | undefined;
    contactId?: number | undefined;
    type?: NotificationType;
    status?: NotificationStatus;
    area?: NotificationArea;
    event?: NotificationEvent;
    level?: NotificationLevel;
    to?: string | undefined;
    address?: string | undefined;
    subject?: string | undefined;
    contentType?: string | undefined;
    body?: string | undefined;
    error?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    sent?: Date | undefined;
    delivered?: Date | undefined;
    readDate?: Date | undefined;
    contact?: ContactViewModel | undefined;
    attachments?: NotificationAttachmentViewModel[] | undefined;
}

export enum NotificationLevel {
    Error = 1,
    Exception = 2,
    Warning = 4,
    Info = 8,
    Debug = 16,
    Trace = 32,
}

/** Attachment to system notifications */
export class NotificationAttachmentViewModel implements INotificationAttachmentViewModel {
    id!: number;
    notificationId!: number;
    contentType?: string | undefined;
    contentId?: string | undefined;
    data?: string | undefined;

    constructor(data?: INotificationAttachmentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.notificationId = _data["notificationId"];
            this.contentType = _data["contentType"];
            this.contentId = _data["contentId"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): NotificationAttachmentViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationAttachmentViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["notificationId"] = this.notificationId;
        data["contentType"] = this.contentType;
        data["contentId"] = this.contentId;
        data["data"] = this.data;
        return data;
    }
}

/** Attachment to system notifications */
export interface INotificationAttachmentViewModel {
    id: number;
    notificationId: number;
    contentType?: string | undefined;
    contentId?: string | undefined;
    data?: string | undefined;
}

export class DocParamSummary implements IDocParamSummary {
    projectId?: number | undefined;
    serviceType?: number;
    serviceId?: number;
    usage?: UsageType;
    status?: DocumentStatus;
    name?: string | undefined;
    classId?: number | undefined;
    className?: string | undefined;
    serviceName?: string | undefined;
    fileType?: string | undefined;
    dt?: Date | undefined;
    count?: number;
    labelledCount?: number | undefined;
    pdId?: number;
    paramDefName?: string | undefined;
    category?: ParameterDefinitionCategory | undefined;
    grouping?: GroupingType | undefined;
    valueType?: ValueType;
    value?: string | undefined;
    index?: number | undefined;

    constructor(data?: IDocParamSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.serviceType = _data["serviceType"];
            this.serviceId = _data["serviceId"];
            this.usage = _data["usage"];
            this.status = _data["status"];
            this.name = _data["name"];
            this.classId = _data["classId"];
            this.className = _data["className"];
            this.serviceName = _data["serviceName"];
            this.fileType = _data["fileType"];
            this.dt = _data["dt"] ? new Date(_data["dt"].toString()) : <any>undefined;
            this.count = _data["count"];
            this.labelledCount = _data["labelledCount"];
            this.pdId = _data["pdId"];
            this.paramDefName = _data["paramDefName"];
            this.category = _data["category"];
            this.grouping = _data["grouping"];
            this.valueType = _data["valueType"];
            this.value = _data["value"];
            this.index = _data["index"];
        }
    }

    static fromJS(data: any): DocParamSummary {
        data = typeof data === 'object' ? data : {};
        let result = new DocParamSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["serviceType"] = this.serviceType;
        data["serviceId"] = this.serviceId;
        data["usage"] = this.usage;
        data["status"] = this.status;
        data["name"] = this.name;
        data["classId"] = this.classId;
        data["className"] = this.className;
        data["serviceName"] = this.serviceName;
        data["fileType"] = this.fileType;
        data["dt"] = this.dt ? this.dt.toISOString() : <any>undefined;
        data["count"] = this.count;
        data["labelledCount"] = this.labelledCount;
        data["pdId"] = this.pdId;
        data["paramDefName"] = this.paramDefName;
        data["category"] = this.category;
        data["grouping"] = this.grouping;
        data["valueType"] = this.valueType;
        data["value"] = this.value;
        data["index"] = this.index;
        return data;
    }
}

export interface IDocParamSummary {
    projectId?: number | undefined;
    serviceType?: number;
    serviceId?: number;
    usage?: UsageType;
    status?: DocumentStatus;
    name?: string | undefined;
    classId?: number | undefined;
    className?: string | undefined;
    serviceName?: string | undefined;
    fileType?: string | undefined;
    dt?: Date | undefined;
    count?: number;
    labelledCount?: number | undefined;
    pdId?: number;
    paramDefName?: string | undefined;
    category?: ParameterDefinitionCategory | undefined;
    grouping?: GroupingType | undefined;
    valueType?: ValueType;
    value?: string | undefined;
    index?: number | undefined;
}

export class DocumentExtraction implements IDocumentExtraction {
    id?: number;
    parentId?: number | undefined;
    name?: string | undefined;
    label?: string | undefined;
    category?: ParameterDefinitionCategory | undefined;
    grouping?: GroupingType | undefined;
    valueType?: ValueType;
    index?: number | undefined;
    paramId?: number;
    parentParamId?: number | undefined;
    paramIndex?: number | undefined;
    paramValue?: string | undefined;
    verificationId?: number | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    value?: string | undefined;
    dt?: Date | undefined;
    confidence?: number | undefined;
    type?: VerificationType | undefined;
    status?: VerificationStatus | undefined;
    charge?: number | undefined;
    provider?: string | undefined;
    result?: string | undefined;

    constructor(data?: IDocumentExtraction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.name = _data["name"];
            this.label = _data["label"];
            this.category = _data["category"];
            this.grouping = _data["grouping"];
            this.valueType = _data["valueType"];
            this.index = _data["index"];
            this.paramId = _data["paramId"];
            this.parentParamId = _data["parentParamId"];
            this.paramIndex = _data["paramIndex"];
            this.paramValue = _data["paramValue"];
            this.verificationId = _data["verificationId"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.value = _data["value"];
            this.dt = _data["dt"] ? new Date(_data["dt"].toString()) : <any>undefined;
            this.confidence = _data["confidence"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.charge = _data["charge"];
            this.provider = _data["provider"];
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): DocumentExtraction {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentExtraction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["label"] = this.label;
        data["category"] = this.category;
        data["grouping"] = this.grouping;
        data["valueType"] = this.valueType;
        data["index"] = this.index;
        data["paramId"] = this.paramId;
        data["parentParamId"] = this.parentParamId;
        data["paramIndex"] = this.paramIndex;
        data["paramValue"] = this.paramValue;
        data["verificationId"] = this.verificationId;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["value"] = this.value;
        data["dt"] = this.dt ? this.dt.toISOString() : <any>undefined;
        data["confidence"] = this.confidence;
        data["type"] = this.type;
        data["status"] = this.status;
        data["charge"] = this.charge;
        data["provider"] = this.provider;
        data["result"] = this.result;
        return data;
    }
}

export interface IDocumentExtraction {
    id?: number;
    parentId?: number | undefined;
    name?: string | undefined;
    label?: string | undefined;
    category?: ParameterDefinitionCategory | undefined;
    grouping?: GroupingType | undefined;
    valueType?: ValueType;
    index?: number | undefined;
    paramId?: number;
    parentParamId?: number | undefined;
    paramIndex?: number | undefined;
    paramValue?: string | undefined;
    verificationId?: number | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    value?: string | undefined;
    dt?: Date | undefined;
    confidence?: number | undefined;
    type?: VerificationType | undefined;
    status?: VerificationStatus | undefined;
    charge?: number | undefined;
    provider?: string | undefined;
    result?: string | undefined;
}

/** Credit card transaction order information */
export class OrderViewModel implements IOrderViewModel {
    orderId?: string | undefined;
    authorizationId?: string | undefined;

    constructor(data?: IOrderViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.authorizationId = _data["authorizationId"];
        }
    }

    static fromJS(data: any): OrderViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["authorizationId"] = this.authorizationId;
        return data;
    }
}

/** Credit card transaction order information */
export interface IOrderViewModel {
    orderId?: string | undefined;
    authorizationId?: string | undefined;
}

export class PaymentViewModel implements IPaymentViewModel {
    id?: number;
    userId?: string | undefined;
    projectId?: number | undefined;
    bundleId?: number | undefined;
    amount?: number;
    status?: PaymentStatus;
    reference?: string | undefined;
    resultCode?: string | undefined;
    result?: string | undefined;
    reason?: string | undefined;
    description?: string | undefined;
    error?: string | undefined;
    data?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    /** Projects is a container for billing and services */
    project?: ProjectViewModel | undefined;
    /** A bundle for payments and credits */
    bundle?: BundlesViewModel | undefined;

    constructor(data?: IPaymentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.projectId = _data["projectId"];
            this.bundleId = _data["bundleId"];
            this.amount = _data["amount"];
            this.status = _data["status"];
            this.reference = _data["reference"];
            this.resultCode = _data["resultCode"];
            this.result = _data["result"];
            this.reason = _data["reason"];
            this.description = _data["description"];
            this.error = _data["error"];
            this.data = _data["data"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.project = _data["project"] ? ProjectViewModel.fromJS(_data["project"]) : <any>undefined;
            this.bundle = _data["bundle"] ? BundlesViewModel.fromJS(_data["bundle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["projectId"] = this.projectId;
        data["bundleId"] = this.bundleId;
        data["amount"] = this.amount;
        data["status"] = this.status;
        data["reference"] = this.reference;
        data["resultCode"] = this.resultCode;
        data["result"] = this.result;
        data["reason"] = this.reason;
        data["description"] = this.description;
        data["error"] = this.error;
        data["data"] = this.data;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["bundle"] = this.bundle ? this.bundle.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPaymentViewModel {
    id?: number;
    userId?: string | undefined;
    projectId?: number | undefined;
    bundleId?: number | undefined;
    amount?: number;
    status?: PaymentStatus;
    reference?: string | undefined;
    resultCode?: string | undefined;
    result?: string | undefined;
    reason?: string | undefined;
    description?: string | undefined;
    error?: string | undefined;
    data?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    /** Projects is a container for billing and services */
    project?: ProjectViewModel | undefined;
    /** A bundle for payments and credits */
    bundle?: BundlesViewModel | undefined;
}

export enum PaymentStatus {
    None = 0,
    Captured = 10,
    Authorization = 11,
    Processing = 20,
    Complete = 30,
    Credit = 40,
    Rejected = 50,
    Declined = 60,
    Error = 70,
    Deleted = 90,
    Unknown = 99,
}

export class Group implements IGroup {
    id?: string;
    name?: string | undefined;
    isReadOnly?: boolean | undefined;
    isOnDedicatedCapacity?: boolean | undefined;
    capacityId?: string | undefined;
    dataflowStorageId?: string | undefined;

    constructor(data?: IGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isReadOnly = _data["isReadOnly"];
            this.isOnDedicatedCapacity = _data["isOnDedicatedCapacity"];
            this.capacityId = _data["capacityId"];
            this.dataflowStorageId = _data["dataflowStorageId"];
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isReadOnly"] = this.isReadOnly;
        data["isOnDedicatedCapacity"] = this.isOnDedicatedCapacity;
        data["capacityId"] = this.capacityId;
        data["dataflowStorageId"] = this.dataflowStorageId;
        return data;
    }
}

export interface IGroup {
    id?: string;
    name?: string | undefined;
    isReadOnly?: boolean | undefined;
    isOnDedicatedCapacity?: boolean | undefined;
    capacityId?: string | undefined;
    dataflowStorageId?: string | undefined;
}

export class User implements IUser {
    emailAddress?: string | undefined;
    displayName?: string | undefined;
    identifier?: string | undefined;
    graphId?: string | undefined;
    principalType?: PrincipalType;
    profile?: ServicePrincipalProfile | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.displayName = _data["displayName"];
            this.identifier = _data["identifier"];
            this.graphId = _data["graphId"];
            this.principalType = _data["principalType"] ? PrincipalType.fromJS(_data["principalType"]) : <any>undefined;
            this.profile = _data["profile"] ? ServicePrincipalProfile.fromJS(_data["profile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["displayName"] = this.displayName;
        data["identifier"] = this.identifier;
        data["graphId"] = this.graphId;
        data["principalType"] = this.principalType ? this.principalType.toJSON() : <any>undefined;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUser {
    emailAddress?: string | undefined;
    displayName?: string | undefined;
    identifier?: string | undefined;
    graphId?: string | undefined;
    principalType?: PrincipalType;
    profile?: ServicePrincipalProfile | undefined;
}

export class GroupUser extends User implements IGroupUser {
    groupUserAccessRight?: GroupUserAccessRight;

    constructor(data?: IGroupUser) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupUserAccessRight = _data["groupUserAccessRight"] ? GroupUserAccessRight.fromJS(_data["groupUserAccessRight"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): GroupUser {
        data = typeof data === 'object' ? data : {};
        let result = new GroupUser();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupUserAccessRight"] = this.groupUserAccessRight ? this.groupUserAccessRight.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IGroupUser extends IUser {
    groupUserAccessRight?: GroupUserAccessRight;
}

export class GroupUserAccessRight implements IGroupUserAccessRight {

    constructor(data?: IGroupUserAccessRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GroupUserAccessRight {
        data = typeof data === 'object' ? data : {};
        let result = new GroupUserAccessRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGroupUserAccessRight {
}

export class PrincipalType implements IPrincipalType {

    constructor(data?: IPrincipalType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): PrincipalType {
        data = typeof data === 'object' ? data : {};
        let result = new PrincipalType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IPrincipalType {
}

export class ServicePrincipalProfile implements IServicePrincipalProfile {
    id?: string;
    displayName?: string | undefined;

    constructor(data?: IServicePrincipalProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ServicePrincipalProfile {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePrincipalProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IServicePrincipalProfile {
    id?: string;
    displayName?: string | undefined;
}

export class Report implements IReport {
    id?: string;
    name?: string | undefined;
    datasetId?: string | undefined;
    appId?: string | undefined;
    description?: string | undefined;
    reportType?: string | undefined;
    webUrl?: string | undefined;
    embedUrl?: string | undefined;
    users?: ReportUser[] | undefined;
    subscriptions?: Subscription[] | undefined;

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.datasetId = _data["datasetId"];
            this.appId = _data["appId"];
            this.description = _data["description"];
            this.reportType = _data["reportType"];
            this.webUrl = _data["webUrl"];
            this.embedUrl = _data["embedUrl"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(ReportUser.fromJS(item));
            }
            if (Array.isArray(_data["subscriptions"])) {
                this.subscriptions = [] as any;
                for (let item of _data["subscriptions"])
                    this.subscriptions!.push(Subscription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["datasetId"] = this.datasetId;
        data["appId"] = this.appId;
        data["description"] = this.description;
        data["reportType"] = this.reportType;
        data["webUrl"] = this.webUrl;
        data["embedUrl"] = this.embedUrl;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (Array.isArray(this.subscriptions)) {
            data["subscriptions"] = [];
            for (let item of this.subscriptions)
                data["subscriptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReport {
    id?: string;
    name?: string | undefined;
    datasetId?: string | undefined;
    appId?: string | undefined;
    description?: string | undefined;
    reportType?: string | undefined;
    webUrl?: string | undefined;
    embedUrl?: string | undefined;
    users?: ReportUser[] | undefined;
    subscriptions?: Subscription[] | undefined;
}

export class ReportUser extends User implements IReportUser {
    reportUserAccessRight?: ReportUserAccessRight;

    constructor(data?: IReportUser) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reportUserAccessRight = _data["reportUserAccessRight"] ? ReportUserAccessRight.fromJS(_data["reportUserAccessRight"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ReportUser {
        data = typeof data === 'object' ? data : {};
        let result = new ReportUser();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportUserAccessRight"] = this.reportUserAccessRight ? this.reportUserAccessRight.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IReportUser extends IUser {
    reportUserAccessRight?: ReportUserAccessRight;
}

export class ReportUserAccessRight implements IReportUserAccessRight {

    constructor(data?: IReportUserAccessRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ReportUserAccessRight {
        data = typeof data === 'object' ? data : {};
        let result = new ReportUserAccessRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IReportUserAccessRight {
}

export class Subscription implements ISubscription {
    id?: string;
    title?: string | undefined;
    artifactId?: string | undefined;
    artifactDisplayName?: string | undefined;
    subArtifactDisplayName?: string | undefined;
    artifactType?: string | undefined;
    isEnabled?: boolean | undefined;
    frequency?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    linkToContent?: boolean | undefined;
    previewImage?: boolean | undefined;
    attachmentFormat?: string | undefined;
    users?: SubscriptionUser[] | undefined;

    constructor(data?: ISubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.artifactId = _data["artifactId"];
            this.artifactDisplayName = _data["artifactDisplayName"];
            this.subArtifactDisplayName = _data["subArtifactDisplayName"];
            this.artifactType = _data["artifactType"];
            this.isEnabled = _data["isEnabled"];
            this.frequency = _data["frequency"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.linkToContent = _data["linkToContent"];
            this.previewImage = _data["previewImage"];
            this.attachmentFormat = _data["attachmentFormat"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(SubscriptionUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Subscription {
        data = typeof data === 'object' ? data : {};
        let result = new Subscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["artifactId"] = this.artifactId;
        data["artifactDisplayName"] = this.artifactDisplayName;
        data["subArtifactDisplayName"] = this.subArtifactDisplayName;
        data["artifactType"] = this.artifactType;
        data["isEnabled"] = this.isEnabled;
        data["frequency"] = this.frequency;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["linkToContent"] = this.linkToContent;
        data["previewImage"] = this.previewImage;
        data["attachmentFormat"] = this.attachmentFormat;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubscription {
    id?: string;
    title?: string | undefined;
    artifactId?: string | undefined;
    artifactDisplayName?: string | undefined;
    subArtifactDisplayName?: string | undefined;
    artifactType?: string | undefined;
    isEnabled?: boolean | undefined;
    frequency?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    linkToContent?: boolean | undefined;
    previewImage?: boolean | undefined;
    attachmentFormat?: string | undefined;
    users?: SubscriptionUser[] | undefined;
}

export class SubscriptionUser extends User implements ISubscriptionUser {

    constructor(data?: ISubscriptionUser) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SubscriptionUser {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionUser();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISubscriptionUser extends IUser {
}

export class Page implements IPage {
    name?: string | undefined;
    displayName?: string | undefined;
    order?: number | undefined;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["order"] = this.order;
        return data;
    }
}

export interface IPage {
    name?: string | undefined;
    displayName?: string | undefined;
    order?: number | undefined;
}

export class RoleViewModel implements IRoleViewModel {
    id?: string | undefined;
    name!: string;
    description?: string | undefined;
    usersCount?: number;
    permissions?: PermissionViewModel[] | undefined;

    constructor(data?: IRoleViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.usersCount = _data["usersCount"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["usersCount"] = this.usersCount;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRoleViewModel {
    id?: string | undefined;
    name: string;
    description?: string | undefined;
    usersCount?: number;
    permissions?: PermissionViewModel[] | undefined;
}

export class PermissionViewModel implements IPermissionViewModel {
    name?: string | undefined;
    value?: string | undefined;
    groupName?: string | undefined;
    description?: string | undefined;

    constructor(data?: IPermissionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
            this.groupName = _data["groupName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        data["groupName"] = this.groupName;
        data["description"] = this.description;
        return data;
    }
}

export interface IPermissionViewModel {
    name?: string | undefined;
    value?: string | undefined;
    groupName?: string | undefined;
    description?: string | undefined;
}

export class ServiceChargeViewModel implements IServiceChargeViewModel {
    id!: number;
    serviceId!: number;
    status?: ChargeStatus;
    dtc?: Date;
    dtm?: Date;
    fromDate?: Date;
    toDate?: Date | undefined;
    cost?: number | undefined;
    charge?: number | undefined;
    comment?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IServiceChargeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceId = _data["serviceId"];
            this.status = _data["status"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.cost = _data["cost"];
            this.charge = _data["charge"];
            this.comment = _data["comment"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ServiceChargeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceChargeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceId"] = this.serviceId;
        data["status"] = this.status;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["cost"] = this.cost;
        data["charge"] = this.charge;
        data["comment"] = this.comment;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IServiceChargeViewModel {
    id: number;
    serviceId: number;
    status?: ChargeStatus;
    dtc?: Date;
    dtm?: Date;
    fromDate?: Date;
    toDate?: Date | undefined;
    cost?: number | undefined;
    charge?: number | undefined;
    comment?: string | undefined;
    userId?: string | undefined;
}

export enum ChargeStatus {
    Active = 0,
    Deleted = 99,
}

/** Service type information */
export class ServiceTypeViewModel implements IServiceTypeViewModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    group?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    status?: ServiceTypeStatus;
    options?: ServiceOptions;
    availability?: Availability;
    logo?: string | undefined;
    icon?: string | undefined;
    info?: string | undefined;
    engine?: string | undefined;
    cost?: number | undefined;
    charge?: number | undefined;
    valueType?: ValueType | undefined;
    charges?: ServiceTypeChargeViewModel[] | undefined;

    constructor(data?: IServiceTypeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.group = _data["group"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.options = _data["options"];
            this.availability = _data["availability"];
            this.logo = _data["logo"];
            this.icon = _data["icon"];
            this.info = _data["info"];
            this.engine = _data["engine"];
            this.cost = _data["cost"];
            this.charge = _data["charge"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["charges"])) {
                this.charges = [] as any;
                for (let item of _data["charges"])
                    this.charges!.push(ServiceTypeChargeViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceTypeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceTypeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["group"] = this.group;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["options"] = this.options;
        data["availability"] = this.availability;
        data["logo"] = this.logo;
        data["icon"] = this.icon;
        data["info"] = this.info;
        data["engine"] = this.engine;
        data["cost"] = this.cost;
        data["charge"] = this.charge;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.charges)) {
            data["charges"] = [];
            for (let item of this.charges)
                data["charges"].push(item.toJSON());
        }
        return data;
    }
}

/** Service type information */
export interface IServiceTypeViewModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    group?: string | undefined;
    dtc?: Date;
    dtm?: Date;
    status?: ServiceTypeStatus;
    options?: ServiceOptions;
    availability?: Availability;
    logo?: string | undefined;
    icon?: string | undefined;
    info?: string | undefined;
    engine?: string | undefined;
    cost?: number | undefined;
    charge?: number | undefined;
    valueType?: ValueType | undefined;
    charges?: ServiceTypeChargeViewModel[] | undefined;
}

export enum ServiceTypeStatus {
    Disabled = 0,
    Enabled = 1,
}

export enum ServiceOptions {
    Definition = 2,
    Training = 4,
    Classification = 8,
    Code = 16,
    Verification = 32,
    Scraping = 64,
    Attachment = 128,
    Indexing = 256,
    Inbox = 512,
    Outbox = 1024,
    Processor = 2048,
    Configure = 4096,
    Classes = 8192,
    Keys = 16384,
    Speech = 32768,
    Video = 65536,
    Analysis = 131072,
    Labelling = 262144,
    Vendors = 524288,
    BusinessUnits = 1048576,
    PurchaseOrders = 2097152,
    GLCodes = 4194304,
}

export class ServiceTypeChargeViewModel implements IServiceTypeChargeViewModel {
    id!: number;
    serviceTypeId!: number;
    status?: ChargeStatus;
    fromDate?: Date;
    toDate?: Date | undefined;
    cost?: number | undefined;
    charge?: number | undefined;
    comment?: string | undefined;
    userId?: string | undefined;
    /** Service type information */
    serviceType?: ServiceTypeViewModel | undefined;

    constructor(data?: IServiceTypeChargeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceTypeId = _data["serviceTypeId"];
            this.status = _data["status"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.cost = _data["cost"];
            this.charge = _data["charge"];
            this.comment = _data["comment"];
            this.userId = _data["userId"];
            this.serviceType = _data["serviceType"] ? ServiceTypeViewModel.fromJS(_data["serviceType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceTypeChargeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceTypeChargeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceTypeId"] = this.serviceTypeId;
        data["status"] = this.status;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["cost"] = this.cost;
        data["charge"] = this.charge;
        data["comment"] = this.comment;
        data["userId"] = this.userId;
        data["serviceType"] = this.serviceType ? this.serviceType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServiceTypeChargeViewModel {
    id: number;
    serviceTypeId: number;
    status?: ChargeStatus;
    fromDate?: Date;
    toDate?: Date | undefined;
    cost?: number | undefined;
    charge?: number | undefined;
    comment?: string | undefined;
    userId?: string | undefined;
    /** Service type information */
    serviceType?: ServiceTypeViewModel | undefined;
}

/** Data types used for rules and internal processing */
export class DataTypeViewModel implements IDataTypeViewModel {
    id!: ValueType;
    name!: string;
    description?: string | undefined;
    category?: DataTypeCategory | undefined;
    valueTypeName?: string | undefined;
    defaultValue?: string | undefined;
    data?: string | undefined;

    constructor(data?: IDataTypeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.valueTypeName = _data["valueTypeName"];
            this.defaultValue = _data["defaultValue"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): DataTypeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new DataTypeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        data["valueTypeName"] = this.valueTypeName;
        data["defaultValue"] = this.defaultValue;
        data["data"] = this.data;
        return data;
    }
}

/** Data types used for rules and internal processing */
export interface IDataTypeViewModel {
    id: ValueType;
    name: string;
    description?: string | undefined;
    category?: DataTypeCategory | undefined;
    valueTypeName?: string | undefined;
    defaultValue?: string | undefined;
    data?: string | undefined;
}

export enum DataTypeCategory {
    None = 1,
    Setting = 2,
    Service = 4,
    Statistics = 8,
    Result = 16,
    Dependency = 32,
    Verification = 64,
    PreProcessor = 128,
    Processor = 256,
    PostProcessor = 512,
}

/** List of system Enums and basic UI info */
export class EnumDataViewModel implements IEnumDataViewModel {
    id!: number;
    type?: EnumType;
    typeName!: string;
    name!: string;
    value?: number;
    description?: string | undefined;
    info?: string | undefined;
    icon?: string | undefined;
    color?: string | undefined;

    constructor(data?: IEnumDataViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.typeName = _data["typeName"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.info = _data["info"];
            this.icon = _data["icon"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): EnumDataViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new EnumDataViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["typeName"] = this.typeName;
        data["name"] = this.name;
        data["value"] = this.value;
        data["description"] = this.description;
        data["info"] = this.info;
        data["icon"] = this.icon;
        data["color"] = this.color;
        return data;
    }
}

/** List of system Enums and basic UI info */
export interface IEnumDataViewModel {
    id: number;
    type?: EnumType;
    typeName: string;
    name: string;
    value?: number;
    description?: string | undefined;
    info?: string | undefined;
    icon?: string | undefined;
    color?: string | undefined;
}

export enum EnumType {
    EnumType = 0,
    DataTypeCategory = 1,
    CategoryStatus = 5,
    ProjectStatus = 10,
    ServiceOptions = 13,
    ServiceStatus = 14,
    ProjectUserStatus = 15,
    LinkType = 16,
    ConstraintType = 17,
    ConstraintStatus = 18,
    ConstraintIntervalType = 19,
    DocumentStatus = 21,
    UsageType = 22,
    ParameterDefinitionCategory = 24,
    ParameterDefinitionStatus = 26,
    DocumentDataType = 27,
    ChargeStatus = 29,
    ServiceEventType = 30,
    ServiceEventStatus = 31,
    BundleType = 35,
    PaymentStatus = 41,
    VerificationStatus = 50,
    FieldRequired = 51,
    VerificationType = 52,
    Availability = 55,
    WorkItemType = 60,
    WorkItemStatus = 61,
    WorkItemAction = 62,
    WorkItemMethod = 63,
    NotificationType = 70,
    NotificationStatus = 71,
    NotificationEvent = 72,
    SettingType = 80,
    SettingStatus = 81,
    MarkingType = 85,
    Orientation = 86,
    ReferenceType = 90,
    ValueType = 91,
    GroupingType = 92,
    OptionStatusFlags = 95,
    RatingType = 96,
    RatingStatus = 97,
    UserGroupType = 100,
    UserGroupStatus = 101,
    LogType = 110,
    AuditEntity = 200,
    AuditAccessType = 201,
    WizardState = 1000,
    WizardType = 1001,
    SortField = 2000,
    SortDirection = 2001,
}

export class BackgoundWorkItem implements IBackgoundWorkItem {
    connId?: string | undefined;
    userId?: string | undefined;
    id?: string;
    info?: string | undefined;
    exception?: string | undefined;
    progress?: number;
    start?: Date | undefined;
    end?: Date | undefined;
    lastMsgDT?: Date;

    constructor(data?: IBackgoundWorkItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connId = _data["connId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.info = _data["info"];
            this.exception = _data["exception"];
            this.progress = _data["progress"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.lastMsgDT = _data["lastMsgDT"] ? new Date(_data["lastMsgDT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BackgoundWorkItem {
        data = typeof data === 'object' ? data : {};
        let result = new BackgoundWorkItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connId"] = this.connId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["info"] = this.info;
        data["exception"] = this.exception;
        data["progress"] = this.progress;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["lastMsgDT"] = this.lastMsgDT ? this.lastMsgDT.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBackgoundWorkItem {
    connId?: string | undefined;
    userId?: string | undefined;
    id?: string;
    info?: string | undefined;
    exception?: string | undefined;
    progress?: number;
    start?: Date | undefined;
    end?: Date | undefined;
    lastMsgDT?: Date;
}

export class LogEvent implements ILogEvent {
    timestamp?: Date;
    level?: string;
    message?: string;
    exception?: string | undefined;
    context?: string | undefined;

    constructor(data?: ILogEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.level = _data["level"];
            this.message = _data["message"];
            this.exception = _data["exception"];
            this.context = _data["context"];
        }
    }

    static fromJS(data: any): LogEvent {
        data = typeof data === 'object' ? data : {};
        let result = new LogEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["level"] = this.level;
        data["message"] = this.message;
        data["exception"] = this.exception;
        data["context"] = this.context;
        return data;
    }
}

export interface ILogEvent {
    timestamp?: Date;
    level?: string;
    message?: string;
    exception?: string | undefined;
    context?: string | undefined;
}

export class SettingViewModel implements ISettingViewModel {
    id?: number;
    userId?: string | undefined;
    name?: string | undefined;
    key?: string | undefined;
    description?: string | undefined;
    value?: string | undefined;
    status?: SettingStatus;
    dtc?: Date;
    dtm?: Date;

    constructor(data?: ISettingViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.key = _data["key"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.status = _data["status"];
            this.dtc = _data["dtc"] ? new Date(_data["dtc"].toString()) : <any>undefined;
            this.dtm = _data["dtm"] ? new Date(_data["dtm"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SettingViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SettingViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["key"] = this.key;
        data["description"] = this.description;
        data["value"] = this.value;
        data["status"] = this.status;
        data["dtc"] = this.dtc ? this.dtc.toISOString() : <any>undefined;
        data["dtm"] = this.dtm ? this.dtm.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISettingViewModel {
    id?: number;
    userId?: string | undefined;
    name?: string | undefined;
    key?: string | undefined;
    description?: string | undefined;
    value?: string | undefined;
    status?: SettingStatus;
    dtc?: Date;
    dtm?: Date;
}

/** System and user verification info for fields on documents */
export class VerificationSummary implements IVerificationSummary {
    id!: number;
    parameterId!: number;
    userId?: string | undefined;
    value?: string | undefined;
    dt?: Date;
    confidence?: number | undefined;
    symbolsConfidence?: string | undefined;
    type?: VerificationType;
    status?: VerificationStatus;
    result?: string | undefined;
    box?: string | undefined;
    info?: string | undefined;
    data?: string | undefined;
    userName?: string | undefined;
    serviceId?: number | undefined;
    serviceDocId?: number | undefined;
    provider?: string | undefined;
    settingId?: number | undefined;
    workItem?: number | undefined;
    transactionId?: number | undefined;
    charge?: number;
    paramDefId?: number;
    paramDefName?: string | undefined;
    projectId?: number;
    projectName?: string | undefined;
    docId?: number;
    docFileName?: string | undefined;
    docContentType?: string | undefined;
    docUsage?: UsageType | undefined;
    docStatus?: DocumentStatus | undefined;
    classId?: number | undefined;
    className?: string | undefined;
    year?: number;
    month?: number;
    day?: number;
    dayOfWeek?: DayOfWeek;
    count?: number;
    average?: number | undefined;
    min?: number | undefined;
    max?: number | undefined;

    constructor(data?: IVerificationSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parameterId = _data["parameterId"];
            this.userId = _data["userId"];
            this.value = _data["value"];
            this.dt = _data["dt"] ? new Date(_data["dt"].toString()) : <any>undefined;
            this.confidence = _data["confidence"];
            this.symbolsConfidence = _data["symbolsConfidence"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.result = _data["result"];
            this.box = _data["box"];
            this.info = _data["info"];
            this.data = _data["data"];
            this.userName = _data["userName"];
            this.serviceId = _data["serviceId"];
            this.serviceDocId = _data["serviceDocId"];
            this.provider = _data["provider"];
            this.settingId = _data["settingId"];
            this.workItem = _data["workItem"];
            this.transactionId = _data["transactionId"];
            this.charge = _data["charge"];
            this.paramDefId = _data["paramDefId"];
            this.paramDefName = _data["paramDefName"];
            this.projectId = _data["projectId"];
            this.projectName = _data["projectName"];
            this.docId = _data["docId"];
            this.docFileName = _data["docFileName"];
            this.docContentType = _data["docContentType"];
            this.docUsage = _data["docUsage"];
            this.docStatus = _data["docStatus"];
            this.classId = _data["classId"];
            this.className = _data["className"];
            this.year = _data["year"];
            this.month = _data["month"];
            this.day = _data["day"];
            this.dayOfWeek = _data["dayOfWeek"];
            this.count = _data["count"];
            this.average = _data["average"];
            this.min = _data["min"];
            this.max = _data["max"];
        }
    }

    static fromJS(data: any): VerificationSummary {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parameterId"] = this.parameterId;
        data["userId"] = this.userId;
        data["value"] = this.value;
        data["dt"] = this.dt ? this.dt.toISOString() : <any>undefined;
        data["confidence"] = this.confidence;
        data["symbolsConfidence"] = this.symbolsConfidence;
        data["type"] = this.type;
        data["status"] = this.status;
        data["result"] = this.result;
        data["box"] = this.box;
        data["info"] = this.info;
        data["data"] = this.data;
        data["userName"] = this.userName;
        data["serviceId"] = this.serviceId;
        data["serviceDocId"] = this.serviceDocId;
        data["provider"] = this.provider;
        data["settingId"] = this.settingId;
        data["workItem"] = this.workItem;
        data["transactionId"] = this.transactionId;
        data["charge"] = this.charge;
        data["paramDefId"] = this.paramDefId;
        data["paramDefName"] = this.paramDefName;
        data["projectId"] = this.projectId;
        data["projectName"] = this.projectName;
        data["docId"] = this.docId;
        data["docFileName"] = this.docFileName;
        data["docContentType"] = this.docContentType;
        data["docUsage"] = this.docUsage;
        data["docStatus"] = this.docStatus;
        data["classId"] = this.classId;
        data["className"] = this.className;
        data["year"] = this.year;
        data["month"] = this.month;
        data["day"] = this.day;
        data["dayOfWeek"] = this.dayOfWeek;
        data["count"] = this.count;
        data["average"] = this.average;
        data["min"] = this.min;
        data["max"] = this.max;
        return data;
    }
}

/** System and user verification info for fields on documents */
export interface IVerificationSummary {
    id: number;
    parameterId: number;
    userId?: string | undefined;
    value?: string | undefined;
    dt?: Date;
    confidence?: number | undefined;
    symbolsConfidence?: string | undefined;
    type?: VerificationType;
    status?: VerificationStatus;
    result?: string | undefined;
    box?: string | undefined;
    info?: string | undefined;
    data?: string | undefined;
    userName?: string | undefined;
    serviceId?: number | undefined;
    serviceDocId?: number | undefined;
    provider?: string | undefined;
    settingId?: number | undefined;
    workItem?: number | undefined;
    transactionId?: number | undefined;
    charge?: number;
    paramDefId?: number;
    paramDefName?: string | undefined;
    projectId?: number;
    projectName?: string | undefined;
    docId?: number;
    docFileName?: string | undefined;
    docContentType?: string | undefined;
    docUsage?: UsageType | undefined;
    docStatus?: DocumentStatus | undefined;
    classId?: number | undefined;
    className?: string | undefined;
    year?: number;
    month?: number;
    day?: number;
    dayOfWeek?: DayOfWeek;
    count?: number;
    average?: number | undefined;
    min?: number | undefined;
    max?: number | undefined;
}

export enum DayOfWeek {
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}

export class Wizard implements IWizard {
    index?: number;
    name?: string | undefined;
    description?: string | undefined;
    type?: WizardType;
    state?: WizardState;
    info?: string | undefined;
    error?: string | undefined;
    warning?: string | undefined;
    information?: string | undefined;
    /** Service, settings abd rules definitions */
    stpd?: ParameterDefViewModel | undefined;
    /** Service, settings abd rules definitions */
    dependencyPD?: ParameterDefViewModel | undefined;
    /** Service, settings abd rules definitions */
    pd?: ParameterDefViewModel | undefined;
    removePDId?: number | undefined;
    docsCount?: number;

    constructor(data?: IWizard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.state = _data["state"];
            this.info = _data["info"];
            this.error = _data["error"];
            this.warning = _data["warning"];
            this.information = _data["information"];
            this.stpd = _data["stpd"] ? ParameterDefViewModel.fromJS(_data["stpd"]) : <any>undefined;
            this.dependencyPD = _data["dependencyPD"] ? ParameterDefViewModel.fromJS(_data["dependencyPD"]) : <any>undefined;
            this.pd = _data["pd"] ? ParameterDefViewModel.fromJS(_data["pd"]) : <any>undefined;
            this.removePDId = _data["removePDId"];
            this.docsCount = _data["docsCount"];
        }
    }

    static fromJS(data: any): Wizard {
        data = typeof data === 'object' ? data : {};
        let result = new Wizard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        data["state"] = this.state;
        data["info"] = this.info;
        data["error"] = this.error;
        data["warning"] = this.warning;
        data["information"] = this.information;
        data["stpd"] = this.stpd ? this.stpd.toJSON() : <any>undefined;
        data["dependencyPD"] = this.dependencyPD ? this.dependencyPD.toJSON() : <any>undefined;
        data["pd"] = this.pd ? this.pd.toJSON() : <any>undefined;
        data["removePDId"] = this.removePDId;
        data["docsCount"] = this.docsCount;
        return data;
    }
}

export interface IWizard {
    index?: number;
    name?: string | undefined;
    description?: string | undefined;
    type?: WizardType;
    state?: WizardState;
    info?: string | undefined;
    error?: string | undefined;
    warning?: string | undefined;
    information?: string | undefined;
    /** Service, settings abd rules definitions */
    stpd?: ParameterDefViewModel | undefined;
    /** Service, settings abd rules definitions */
    dependencyPD?: ParameterDefViewModel | undefined;
    /** Service, settings abd rules definitions */
    pd?: ParameterDefViewModel | undefined;
    removePDId?: number | undefined;
    docsCount?: number;
}

export enum WizardType {
    Service = 0,
    Dependency = 1,
    Categories = 2,
    Class = 3,
    Definition = 4,
    Training = 5,
    Verification = 6,
    Analysis = 7,
    Upload = 8,
    Labelling = 9,
    Vendors = 10,
    BusinessUnits = 11,
    PurchaseOrders = 12,
    PurchaseOrdersItems = 13,
    GLCodes = 14,
}

export enum WizardState {
    Complete = 0,
    Error = 1,
    Partial = 2,
    Warning = 3,
}

export enum WizardValidation {
    NA = 0,
    Steps = 1,
    Options = 2,
    BeforeSave = 3,
    AfterSave = 4,
}

export class WorkFlowSummary implements IWorkFlowSummary {
    projectId?: number | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    serviceId?: number | undefined;
    defId?: number | undefined;
    docId?: number | undefined;
    filename?: string | undefined;
    docStatus?: DocumentStatus | undefined;
    docUsage?: UsageType | undefined;
    docClassId?: number | undefined;
    docClassName?: string | undefined;
    action?: WorkItemAction;
    type?: WorkItemType;
    status?: WorkItemStatus;
    method?: WorkItemMethod | undefined;
    dt?: Date | undefined;
    duration?: string | undefined;
    activeDuration?: string | undefined;
    count?: number;

    constructor(data?: IWorkFlowSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.serviceId = _data["serviceId"];
            this.defId = _data["defId"];
            this.docId = _data["docId"];
            this.filename = _data["filename"];
            this.docStatus = _data["docStatus"];
            this.docUsage = _data["docUsage"];
            this.docClassId = _data["docClassId"];
            this.docClassName = _data["docClassName"];
            this.action = _data["action"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.method = _data["method"];
            this.dt = _data["dt"] ? new Date(_data["dt"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.activeDuration = _data["activeDuration"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): WorkFlowSummary {
        data = typeof data === 'object' ? data : {};
        let result = new WorkFlowSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["serviceId"] = this.serviceId;
        data["defId"] = this.defId;
        data["docId"] = this.docId;
        data["filename"] = this.filename;
        data["docStatus"] = this.docStatus;
        data["docUsage"] = this.docUsage;
        data["docClassId"] = this.docClassId;
        data["docClassName"] = this.docClassName;
        data["action"] = this.action;
        data["type"] = this.type;
        data["status"] = this.status;
        data["method"] = this.method;
        data["dt"] = this.dt ? this.dt.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["activeDuration"] = this.activeDuration;
        data["count"] = this.count;
        return data;
    }
}

export interface IWorkFlowSummary {
    projectId?: number | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    serviceId?: number | undefined;
    defId?: number | undefined;
    docId?: number | undefined;
    filename?: string | undefined;
    docStatus?: DocumentStatus | undefined;
    docUsage?: UsageType | undefined;
    docClassId?: number | undefined;
    docClassName?: string | undefined;
    action?: WorkItemAction;
    type?: WorkItemType;
    status?: WorkItemStatus;
    method?: WorkItemMethod | undefined;
    dt?: Date | undefined;
    duration?: string | undefined;
    activeDuration?: string | undefined;
    count?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}